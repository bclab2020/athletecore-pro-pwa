<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AthleteCore Pro">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1E3A8A">
    <title>AthleteCore Pro - AI姿勢分析システム</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS用アイコン -->
    <link rel="apple-touch-icon" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link rel="apple-touch-icon" sizes="152x152" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link rel="apple-touch-icon" sizes="180x180" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    
    <!-- スプラッシュスクリーン用 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="apple-touch-startup-image" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- MediaPipe Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .phone-frame {
            width: 100vw;
            height: 100vh;
            background: #000;
            border-radius: 0;
            padding: 0;
            margin: 0;
            position: relative;
            box-shadow: none;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* デスクトップ表示時のみフレーム効果 */
        @media (min-width: 768px) {
            .phone-frame {
                width: 375px;
                height: 812px;
                border-radius: 40px;
                padding: 8px;
                margin: 0 auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
        }
        
        .phone-screen {
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 0;
            overflow: hidden;
            position: relative;
        }
        
        /* デスクトップ表示時のみフレーム効果 */
        @media (min-width: 768px) {
            .phone-screen {
                border-radius: 32px;
            }
        }
        
        .home-indicator {
            position: absolute;
            bottom: max(8px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 134px;
            height: 5px;
            background: #000;
            border-radius: 3px;
            opacity: 0.4;
        }
        
        /* スマートフォンでは非表示 */
        @media (max-width: 767px) {
            .home-indicator {
                display: none;
            }
        }
        
        .app-screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            overflow-y: auto;
        }
        
        .app-screen.active {
            display: flex;
            flex-direction: column;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-up {
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        
        .brand-color {
            color: #1E3A8A;
        }
        
        .brand-bg {
            background-color: #1E3A8A;
        }
        
        .accent-color {
            color: #F59E0B;
        }
        
        .accent-bg {
            background-color: #F59E0B;
        }
        
        /* Fullscreen Camera Mode */
        .fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
        }
        
        .hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        
        /* Floating Capture Button */
        .floating-capture-btn {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 80px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            padding: 16px 32px;
            background: #1E3A8A;
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(30, 58, 138, 0.4);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        
        .floating-capture-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .floating-capture-btn:hover {
            background: #1D4ED8;
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 12px 30px rgba(30, 58, 138, 0.5);
        }
        
        .floating-capture-btn:active {
            transform: translateX(-50%) translateY(0px);
        }
        
        /* Mobile Adjustments for Floating Button */
        @media (max-width: 767px) {
            .floating-capture-btn {
                bottom: calc(env(safe-area-inset-bottom) + 100px);
                padding: 18px 36px;
                font-size: 18px;
            }
        }
        
        /* PWA & Mobile Optimizations */
        .installed {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* タッチ操作の改善 */
        button, .sport-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        button:active, .sport-btn:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }
        
        /* スクロール改善 */
        .app-screen {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        /* フォーカス状態の改善 */
        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(30, 58, 138, 0.3);
        }
        
        /* カメラビューの改善 */
        video {
            object-fit: cover;
            /* ミラー効果は個別に適用するように変更 */
        }
        
        /* プルツーリフレッシュの無効化 */
        body {
            overscroll-behavior-y: contain;
        }
        
        /* Enhanced Countdown Animations */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }
        
        @keyframes countdownPulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.1);
                filter: brightness(1.3);
            }
            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }
        
        @keyframes progressGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(16,185,129,0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(16,185,129,0.8), 0 0 30px rgba(16,185,129,0.4);
            }
        }
        
        @keyframes flashEffect {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
            }
        }
        
        /* Countdown Number Special Effects - Compact Version */
        #staticCountdownNumber {
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Arial Black', Arial, sans-serif;
            letter-spacing: -0.02em;
            line-height: 1;
        }
        
        #countdownProgress {
            transition: all 0.5s ease-out;
            animation: progressGlow 2s ease-in-out infinite;
        }
        
        /* バッテリー効率のためのGPUアクセラレーション */
        .phone-frame, .app-screen, .fade-in, .slide-up {
            will-change: transform;
            transform: translateZ(0);
        }
        
        /* ダークモード対応 */
        @media (prefers-color-scheme: dark) {
            .phone-screen {
                background: #1f2937;
                color: #f9fafb;
            }
            
            .bg-white {
                background-color: #374151 !important;
                color: #f9fafb;
            }
            
            .bg-gray-50 {
                background-color: #111827 !important;
            }
            
            .text-gray-600 {
                color: #d1d5db !important;
            }
            
            .text-gray-500 {
                color: #9ca3af !important;
            }
        }
        
        /* スマートフォン全般の最適化 */
        @media (max-width: 767px) {
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100vh;
            }
            
            .phone-frame {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                padding: 0;
                margin: 0;
                box-shadow: none;
                position: fixed;
                top: 0;
                left: 0;
            }
            
            .phone-screen {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }
            
            .app-screen {
                height: 100vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px));
                box-sizing: border-box;
            }
            
            /* セーフエリア対応の強化 */
            .app-screen > div:first-child {
                padding-top: max(20px, env(safe-area-inset-top, 20px));
            }
            
            /* ボタンエリアのパディング確保 */
            .app-screen .px-6:last-child,
            .app-screen .px-8:last-child {
                padding-bottom: max(40px, env(safe-area-inset-bottom, 40px));
            }
        }
        
        /* 横画面での調整 */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            .phone-frame {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                padding: 0;
                margin: 0;
            }
            
            .phone-screen {
                border-radius: 0;
            }
            
            .home-indicator {
                display: none;
            }
        }
        
        /* タッチ操作の改善 */
        @media (max-width: 767px) {
            button {
                min-height: 50px;
                padding: 16px 20px;
                font-size: 18px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            }
            
            input, select {
                min-height: 50px;
                font-size: 16px;
                padding: 12px 16px;
            }
            
            /* Get Startedボタンの特別対応 */
            .welcome-button {
                min-height: 60px;
                padding: 20px 24px;
                font-size: 20px;
                margin: 20px 0;
                position: relative;
                z-index: 10;
                box-shadow: 0 4px 12px rgba(30, 58, 138, 0.3);
            }
            
            /* Welcome画面専用のレイアウト調整 */
            #welcome {
                display: flex !important;
                flex-direction: column !important;
                min-height: 100vh !important;
                overflow: hidden !important;
            }
            
            #welcome .flex-1 {
                display: flex !important;
                flex-direction: column !important;
                min-height: calc(100vh - max(100px, env(safe-area-inset-bottom, 100px))) !important;
                justify-content: space-between !important;
                padding-bottom: max(60px, env(safe-area-inset-bottom, 60px)) !important;
                overflow-y: auto !important;
            }
            
            /* Get Startedボタンのコンテナ修正 */
            #welcome .text-center:last-child {
                margin-top: auto !important;
                padding-top: 20px !important;
                position: relative !important;
                z-index: 25 !important;
            }
            
            /* 撮影画面の修正 */
            #static-analysis .flex-shrink-0:last-child,
            #dynamic-analysis .flex-shrink-0:last-child {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
                background: white !important;
                position: sticky !important;
                bottom: 0 !important;
                z-index: 20 !important;
                border-top: 1px solid #e5e7eb !important;
                box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1) !important;
                margin-bottom: 0 !important;
            }
            
            /* 撮影画面のボタンを確実に表示 */
            #static-analysis button,
            #dynamic-analysis button {
                min-height: 60px !important;
                position: relative !important;
                z-index: 30 !important;
                margin-bottom: 0 !important;
            }
            
            /* 登録画面の修正 */
            #registration {
                overflow-y: auto !important;
                min-height: 100vh !important;
            }
            
            #registration .flex-1 {
                min-height: calc(100vh - max(100px, env(safe-area-inset-bottom, 100px))) !important;
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            #registration .px-6:last-child,
            #registration .text-center:last-child {
                margin-bottom: max(40px, env(safe-area-inset-bottom, 40px)) !important;
                position: relative !important;
                z-index: 25 !important;
            }
            
            /* 全画面共通のsafe-area処理 */
            .app-screen {
                padding-top: max(20px, env(safe-area-inset-top, 20px));
                padding-left: max(0px, env(safe-area-inset-left, 0px));
                padding-right: max(0px, env(safe-area-inset-right, 0px));
            }
            
            /* Dashboard画面の最適化 */
            #dashboard .flex-1 {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            /* Results画面の最適化 */
            #results .flex-1 {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            /* 骨格描画Canvas最適化 - mix-blend-modeを無効化 */
            #staticPoseCanvas, #dynamicPoseCanvas {
                /* mix-blend-mode: screen; /* 一時的に無効化 */
                pointer-events: none;
                z-index: 15;
                opacity: 1 !important;
                display: block !important;
                visibility: visible !important;
            }
            
            /* スクワットカウンターアニメーション */
            #squatCount {
                transition: transform 0.2s ease-in-out;
            }
            
            /* ポーズ検出ステータス */
            #staticPoseStatus, #dynamicPoseStatus {
                backdrop-filter: blur(5px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            /* カメラ切り替えボタン */
            #staticCameraSwitch, #dynamicCameraSwitch {
                transition: transform 0.3s ease-in-out, background-color 0.2s;
                backdrop-filter: blur(10px);
            }
            
            #staticCameraSwitch:hover, #dynamicCameraSwitch:hover {
                background-color: rgba(0, 0, 0, 0.9);
                transform: scale(1.1);
            }
            
            #staticCameraSwitch:active, #dynamicCameraSwitch:active {
                transform: scale(0.95);
            }
            
            /* カメララベル */
            #staticCameraLabel, #dynamicCameraLabel {
                backdrop-filter: blur(5px);
                transition: background-color 0.3s ease;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen m-0 p-0 overflow-hidden">
    
    <div class="phone-frame">
        <div class="phone-screen">
            <div class="home-indicator"></div>
            
            <!-- Splash Screen -->
            <div id="splash" class="app-screen active bg-white items-center justify-center">
                <div class="text-center px-8">
                    <img src="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm" 
                         alt="AthleteCore Pro Icon" class="w-24 h-24 mx-auto mb-8 rounded-2xl shadow-lg">
                    <h1 class="text-2xl font-bold brand-color mb-2">AthleteCore Pro</h1>
                    <p class="text-sm text-gray-600 mb-4">AI姿勢分析システム</p>
                    <div class="w-8 h-1 brand-bg mx-auto rounded-full mb-8"></div>
                    
                    <!-- PWA対応状況の表示 -->
                    <div class="text-xs text-gray-500 space-y-1">
                        <div id="pwaStatus" class="flex items-center justify-center space-x-2">
                            <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                            <span>Webアプリとして動作中</span>
                        </div>
                        <div class="text-xs text-gray-400">オフライン対応・インストール可能</div>
                    </div>
                </div>
            </div>
            
            <!-- Welcome Screen -->
            <div id="welcome" class="app-screen bg-white">
                <div class="flex-1 flex flex-col px-8 py-8 min-h-screen">
                    <!-- Header Section -->
                    <div class="flex-shrink-0 text-center pt-16 pb-8">
                        <h1 class="text-3xl font-bold brand-color mb-6 leading-tight">
                            AthleteCore Pro
                        </h1>
                        <div class="space-y-2">
                            <p class="text-gray-600 text-lg">
                                Advanced posture analysis for the next generation of athletes
                            </p>
                            <p class="text-gray-500 text-sm">
                                次世代アスリートのための高度姿勢分析
                            </p>
                        </div>
                    </div>
                    
                    <!-- Features Section -->
                    <div class="flex-1 flex flex-col justify-center space-y-8 py-8">
                        <div class="text-center">
                            <div class="w-1 h-12 brand-bg mx-auto mb-3 rounded-full"></div>
                            <p class="text-gray-600 text-sm">AI-powered movement analysis</p>
                        </div>
                        <div class="text-center">
                            <div class="w-1 h-12 brand-bg mx-auto mb-3 rounded-full"></div>
                            <p class="text-gray-600 text-sm">Sport-specific evaluations</p>
                        </div>
                        <div class="text-center">
                            <div class="w-1 h-12 brand-bg mx-auto mb-3 rounded-full"></div>
                            <p class="text-gray-600 text-sm">Professional grade insights</p>
                        </div>
                    </div>
                    
                    <!-- Button Section - Always visible -->
                    <div class="flex-shrink-0 pb-8">
                        <button onclick="console.log('Get Started clicked!'); showRegistration();" 
                                class="welcome-button brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                            Get Started
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Registration Screen -->
            <div id="registration" class="app-screen bg-white">
                <div class="flex-1 overflow-y-auto">
                    <div class="px-6 py-8">
                        <div class="text-center mb-8">
                            <h2 class="text-2xl font-bold brand-color mb-2">Create Your Profile</h2>
                            <p class="text-gray-600">プロフィールを作成</p>
                        </div>
                        
                        <form id="profileForm" class="space-y-6">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Name / 名前</label>
                                <input id="name" type="text" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            </div>
                            
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Age / 年齢</label>
                                    <input id="age" type="number" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Height / 身長 (cm)</label>
                                    <input id="height" type="number" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                </div>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Weight / 体重 (kg)</label>
                                <input id="weight" type="number" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Primary Sport / 主要競技</label>
                                <select id="primarySport" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Select Sport / 競技を選択</option>
                                    <option value="soccer">Soccer / サッカー</option>
                                    <option value="basketball">Basketball / バスケットボール</option>
                                    <option value="baseball">Baseball / 野球</option>
                                    <option value="tabletennis">Table Tennis / 卓球</option>
                                    <option value="volleyball">Volleyball / バレーボール</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Experience Level / 経験レベル</label>
                                <select id="experienceLevel" required class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                    <option value="">Select Level / レベルを選択</option>
                                    <option value="beginner">Beginner / 初心者</option>
                                    <option value="intermediate">Intermediate / 中級者</option>
                                    <option value="advanced">Advanced / 上級者</option>
                                    <option value="professional">Professional / プロ</option>
                                </select>
                            </div>
                            
                            <button type="button" onclick="handleRegistration()" 
                                    class="brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                                Continue / 続行
                            </button>
                        </form>
                    </div>
                </div>
            </div>
            
            <!-- Dashboard Screen -->
            <div id="dashboard" class="app-screen bg-gray-50">
                <div class="flex-1 overflow-y-auto">
                    <!-- Header -->
                    <div class="bg-white px-6 py-4 shadow-sm">
                        <div class="flex justify-between items-center">
                            <h1 class="text-xl font-bold brand-color">AthleteCore Pro</h1>
                            <div class="w-8 h-8 bg-gray-300 rounded-full"></div>
                        </div>
                    </div>
                    
                    <!-- Stats Cards -->
                    <div class="px-6 py-4">
                        <div class="grid grid-cols-3 gap-4 mb-6">
                            <div class="bg-white p-4 rounded-xl text-center">
                                <div class="text-2xl font-bold brand-color">92%</div>
                                <div class="text-xs text-gray-600">Posture Score</div>
                            </div>
                            <div class="bg-white p-4 rounded-xl text-center">
                                <div class="text-2xl font-bold text-green-600">Good</div>
                                <div class="text-xs text-gray-600">Balance</div>
                            </div>
                            <div class="bg-white p-4 rounded-xl text-center">
                                <div class="text-2xl font-bold text-orange-600">Low</div>
                                <div class="text-xs text-gray-600">Risk</div>
                            </div>
                        </div>
                        
                        <!-- Sport Selection -->
                        <div class="mb-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Sport Analysis</h3>
                            <div class="bg-white rounded-xl p-1">
                                <div class="grid grid-cols-5 gap-1">
                                    <button onclick="selectSport('soccer')" class="sport-btn text-xs py-3 px-2 rounded-lg bg-blue-50 brand-color font-medium">Soccer</button>
                                    <button onclick="selectSport('basketball')" class="sport-btn text-xs py-3 px-2 rounded-lg">Basketball</button>
                                    <button onclick="selectSport('baseball')" class="sport-btn text-xs py-3 px-2 rounded-lg">Baseball</button>
                                    <button onclick="selectSport('tabletennis')" class="sport-btn text-xs py-3 px-2 rounded-lg">Table Tennis</button>
                                    <button onclick="selectSport('volleyball')" class="sport-btn text-xs py-3 px-2 rounded-lg">Volleyball</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Analysis Options -->
                        <div class="space-y-4">
                            <button onclick="showStaticAnalysis()" class="w-full bg-white p-4 rounded-xl text-left flex justify-between items-center">
                                <div>
                                    <div class="font-semibold brand-color">Static Posture Analysis</div>
                                    <div class="text-sm text-gray-600">静的姿勢分析</div>
                                </div>
                                <div class="text-gray-400">→</div>
                            </button>
                            
                            <button onclick="showDynamicAnalysis()" class="w-full bg-white p-4 rounded-xl text-left flex justify-between items-center">
                                <div>
                                    <div class="font-semibold brand-color">Dynamic Movement Analysis</div>
                                    <div class="text-sm text-gray-600">動的動作分析</div>
                                </div>
                                <div class="text-gray-400">→</div>
                            </button>
                            
                            <button onclick="showSportSpecific()" class="w-full bg-white p-4 rounded-xl text-left flex justify-between items-center">
                                <div>
                                    <div class="font-semibold brand-color">Sport-Specific Analysis</div>
                                    <div class="text-sm text-gray-600">競技特化分析</div>
                                </div>
                                <div class="text-gray-400">→</div>
                            </button>
                        </div>
                        
                        <!-- Analysis History -->
                        <div class="mt-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Recent Analysis / 最近の分析</h3>
                            <div id="analysisHistory" class="space-y-2">
                                <p class="text-gray-500 text-sm text-center py-4">No analysis yet / まだ分析がありません</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Static Analysis Screen -->
            <div id="static-analysis" class="app-screen bg-white">
                <div class="flex-1 flex flex-col min-h-screen">
                    <!-- Header -->
                    <div id="staticHeader" class="flex-shrink-0 px-6 py-4 border-b bg-white transition-all duration-300">
                        <div class="flex items-center">
                            <button onclick="showDashboard()" class="mr-4 text-gray-600">←</button>
                            <h2 class="text-lg font-semibold brand-color">Static Posture Analysis</h2>
                        </div>
                    </div>
                    
                    <!-- Camera View - Full Screen -->
                    <div id="staticCameraContainer" class="flex-1 bg-gray-900 relative transition-all duration-300" style="height: calc(100vh - 140px); min-height: calc(100vh - 140px);">
                        <!-- Full Screen Camera Container -->
                        <div class="w-full h-full relative absolute inset-0">
                            <video id="staticCameraFeed" class="w-full h-full object-cover" autoplay muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></video>
                            <canvas id="staticPoseCanvas" class="w-full h-full absolute top-0 left-0 z-10" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                            <div id="staticCameraPlaceholder" class="w-full h-full flex items-center justify-center bg-gray-800" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                                <div class="text-center text-white">
                                    <div class="text-6xl mb-4">📷</div>
                                    <p class="text-xl mb-2">Position yourself in the frame</p>
                                    <p class="text-sm opacity-75">フレーム内に立ってください</p>
                                </div>
                            </div>
                            
                            <!-- Pose Detection Status - Top Overlay -->
                            <div id="staticPoseStatus" class="absolute top-4 left-4 bg-green-600 bg-opacity-80 text-white text-sm px-3 py-2 rounded-lg z-20">
                                <span id="staticPoseIndicator" class="w-3 h-3 bg-red-500 rounded-full inline-block mr-2 animate-pulse"></span>
                                <span id="staticPoseText">Starting Camera...</span>
                            </div>
                            
                            <!-- Camera Switch Button - Top Right -->
                            <div class="absolute top-4 right-4 z-20">
                                <button id="staticCameraSwitch" onclick="switchCamera('static')" class="bg-black bg-opacity-70 text-white p-3 rounded-full hover:bg-opacity-90 transition-all">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                    </svg>
                                </button>
                                <div class="text-center mt-1">
                                    <span id="staticCameraLabel" class="text-xs text-white bg-black bg-opacity-50 px-2 py-1 rounded">インカメラ</span>
                                </div>
                            </div>
                            
                            <!-- Instruction Overlay - Bottom -->
                            <div class="absolute bottom-24 left-0 right-0 text-center text-white z-20">
                                <div class="bg-black bg-opacity-50 mx-4 py-3 px-4 rounded-lg">
                                    <p class="text-sm mb-1">Stand naturally with arms at your sides</p>
                                    <p class="text-xs opacity-75 mb-2">腕を体の横に自然に立ってください</p>
                                    <p class="text-xs opacity-60">📷 Tap top-right to switch camera / カメラ切り替えは右上をタップ</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Controls - Sticky Bottom -->
                    <div id="staticControlsBottom" class="flex-shrink-0 px-6 py-6 bg-white border-t space-y-4 transition-all duration-300">
                        <div class="text-center">
                            <p class="text-sm text-gray-600 mb-2">Stand naturally with arms at your sides</p>
                            <p class="text-xs text-gray-500">腕を体の横に自然に立ってください</p>
                        </div>
                        <button id="staticCaptureBtn" onclick="startStaticCaptureImproved()" class="brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                            Start 10s Countdown / 10秒カウントダウン開始
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Dynamic Analysis Screen -->
            <div id="dynamic-analysis" class="app-screen bg-white">
                <div class="flex-1 flex flex-col min-h-screen">
                    <!-- Header -->
                    <div id="dynamicHeader" class="flex-shrink-0 px-6 py-4 border-b bg-white transition-all duration-300">
                        <div class="flex items-center">
                            <button onclick="showDashboard()" class="mr-4 text-gray-600">←</button>
                            <h2 class="text-lg font-semibold brand-color">Dynamic Movement Analysis</h2>
                        </div>
                    </div>
                    
                    <!-- Camera View - Full Screen -->
                    <div id="dynamicCameraContainer" class="flex-1 bg-gray-900 relative transition-all duration-300" style="height: calc(100vh - 140px); min-height: calc(100vh - 140px);">
                        <!-- Full Screen Camera Container -->
                        <div class="w-full h-full relative absolute inset-0">
                            <video id="dynamicCameraFeed" class="w-full h-full object-cover" autoplay muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></video>
                            <canvas id="dynamicPoseCanvas" class="w-full h-full absolute top-0 left-0 z-10" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                            <div id="dynamicCameraPlaceholder" class="w-full h-full flex items-center justify-center bg-gray-800" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                                <div class="text-center text-white">
                                    <div class="text-6xl mb-4">🎥</div>
                                    <p class="text-xl mb-2">Perform the movement</p>
                                    <p class="text-sm opacity-75">動作を行ってください</p>
                                </div>
                            </div>
                            
                            <!-- Pose Detection Status - Top Overlay -->
                            <div id="dynamicPoseStatus" class="absolute top-4 left-4 bg-green-600 bg-opacity-80 text-white text-sm px-3 py-2 rounded-lg z-20">
                                <span id="dynamicPoseIndicator" class="w-3 h-3 bg-red-500 rounded-full inline-block mr-2 animate-pulse"></span>
                                <span id="dynamicPoseText">Starting Camera...</span>
                            </div>
                            
                            <!-- Camera Switch Button - Top Center -->
                            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 z-20">
                                <button id="dynamicCameraSwitch" onclick="switchCamera('dynamic')" class="bg-black bg-opacity-70 text-white p-3 rounded-full hover:bg-opacity-90 transition-all">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                    </svg>
                                </button>
                                <div class="text-center mt-1">
                                    <span id="dynamicCameraLabel" class="text-xs text-white bg-black bg-opacity-50 px-2 py-1 rounded">インカメラ</span>
                                </div>
                            </div>
                            
                            <!-- Movement Counter - Top Right -->
                            <div id="movementCounter" class="absolute top-4 right-4 bg-black bg-opacity-70 text-white text-lg px-4 py-2 rounded-lg z-20">
                                <span class="font-bold">Squats: </span>
                                <span id="squatCount" class="text-2xl font-bold text-green-400">0</span>
                            </div>
                            
                            <!-- Current Exercise Info - Bottom -->
                            <div class="absolute bottom-24 left-0 right-0 text-center text-white z-20">
                                <div class="bg-blue-600 bg-opacity-80 mx-4 py-3 px-4 rounded-lg">
                                    <p class="text-sm font-medium mb-1">Current Exercise: Squat</p>
                                    <p class="text-xs opacity-90 mb-2">現在のエクササイズ：スクワット</p>
                                    <p class="text-xs opacity-70">📷 Tap center-top to switch camera / カメラ切り替えは上中央をタップ</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Controls - Sticky Bottom -->
                    <div id="dynamicControlsBottom" class="flex-shrink-0 px-6 py-6 bg-white border-t space-y-4 transition-all duration-300">
                        <div class="bg-blue-50 p-4 rounded-lg">
                            <p class="text-sm brand-color font-medium mb-1">Current Exercise: Squat</p>
                            <p class="text-xs text-gray-600">現在のエクササイズ：スクワット</p>
                        </div>
                        <button id="dynamicCaptureBtn" onclick="startDynamicCaptureImproved()" class="brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                            Start Auto Recording / 自動録画開始
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Results Screen -->
            <div id="results" class="app-screen bg-gray-50">
                <div class="flex-1 overflow-y-auto">
                    <!-- Header -->
                    <div class="bg-white px-6 py-4 shadow-sm">
                        <div class="flex items-center">
                            <button onclick="showDashboard()" class="mr-4 text-gray-600">←</button>
                            <h2 class="text-lg font-semibold brand-color">Analysis Results</h2>
                        </div>
                    </div>
                    
                    <!-- Overall Score -->
                    <div class="px-6 py-4">
                        <div class="bg-white rounded-xl p-6 mb-6 text-center">
                            <div class="text-4xl font-bold brand-color mb-2">85/100</div>
                            <div class="text-lg text-gray-600 mb-1">Overall Score</div>
                            <div class="text-sm text-gray-500">総合スコア</div>
                        </div>
                        
                        <!-- Analysis Chart -->
                        <div class="bg-white rounded-xl p-4 mb-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Performance Metrics / パフォーマンス指標</h3>
                            <div style="height: 250px;">
                                <canvas id="analysisChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- Detailed Results -->
                        <div class="space-y-4">
                            <div class="bg-white p-4 rounded-xl">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-semibold brand-color">Hip Flexibility</div>
                                        <div class="text-sm text-gray-500">股関節柔軟性</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="hip-score" class="text-green-600 font-bold">92%</div>
                                        <div class="text-xs text-gray-500">Good</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-white p-4 rounded-xl">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-semibold brand-color">Postural Stability</div>
                                        <div class="text-sm text-gray-500">姿勢安定性</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="posture-score" class="text-orange-600 font-bold">78%</div>
                                        <div class="text-xs text-gray-500">Needs Work</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-white p-4 rounded-xl">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-semibold brand-color">Dynamic Balance</div>
                                        <div class="text-sm text-gray-500">動的バランス</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="balance-score" class="text-green-600 font-bold">85%</div>
                                        <div class="text-xs text-gray-500">Good</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Recommendations -->
                        <div class="mt-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Recommendations</h3>
                            <div class="bg-white p-4 rounded-xl">
                                <div class="space-y-3">
                                    <div class="flex items-start">
                                        <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                                        <div>
                                            <p class="text-sm text-gray-700">Focus on core strengthening exercises</p>
                                            <p class="text-xs text-gray-500">体幹強化エクササイズに重点を置く</p>
                                        </div>
                                    </div>
                                    <div class="flex items-start">
                                        <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                                        <div>
                                            <p class="text-sm text-gray-700">Improve hip flexor mobility</p>
                                            <p class="text-xs text-gray-500">股関節屈筋群の可動性を向上させる</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-6 space-y-3">
                            <button onclick="shareResults()" class="w-full bg-gray-100 text-gray-700 font-medium py-3 px-6 rounded-xl">
                                Share Results / 結果を共有
                            </button>
                            <button onclick="showDashboard()" class="brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                                Back to Dashboard / ダッシュボードに戻る
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        let currentScreen = 'splash';
        let currentUser = null;
        
        // PWA Installation
        let deferredPrompt;
        let isInstalled = false;
        
        // Core navigation functions - MUST be defined first
        function showScreen(screenId) {
            console.log('Switching to screen:', screenId);
            document.querySelectorAll('.app-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            currentScreen = screenId;
            
            // Hide all floating buttons when switching screens (they're only shown in fullscreen mode)
            hideAllFloatingButtons();
        }
        
        // Fullscreen camera control functions
        function enterFullscreenMode(type) {
            console.log('Entering fullscreen mode for:', type);
            
            try {
                if (type === 'static') {
                    const header = document.getElementById('staticHeader');
                    const controls = document.getElementById('staticControlsBottom');
                    const container = document.getElementById('staticCameraContainer');
                    
                    if (header && controls && container) {
                        // Hide header and controls completely
                        header.style.display = 'none';
                        controls.style.display = 'none';
                        
                        // Make camera container fullscreen
                        container.classList.add('fullscreen');
                        container.style.height = '100vh';
                        container.style.minHeight = '100vh';
                        
                        // Hide floating button during fullscreen operations
                        hideFloatingButton('static');
                        console.log('✅ Static fullscreen mode activated');
                    } else {
                        console.error('❌ Static elements not found:', {header, controls, container});
                    }
                } else if (type === 'dynamic') {
                    const header = document.getElementById('dynamicHeader');
                    const controls = document.getElementById('dynamicControlsBottom');
                    const container = document.getElementById('dynamicCameraContainer');
                    
                    if (header && controls && container) {
                        // Hide header and controls completely
                        header.style.display = 'none';
                        controls.style.display = 'none';
                        
                        // Make camera container fullscreen
                        container.classList.add('fullscreen');
                        container.style.height = '100vh';
                        container.style.minHeight = '100vh';
                        
                        // Hide floating button during fullscreen operations
                        hideFloatingButton('dynamic');
                        console.log('✅ Dynamic fullscreen mode activated');
                    } else {
                        console.error('❌ Dynamic elements not found:', {header, controls, container});
                    }
                }
            } catch (error) {
                console.error('❌ Error entering fullscreen mode:', error);
            }
        }
        
        function exitFullscreenMode(type) {
            console.log('Exiting fullscreen mode for:', type);
            
            try {
                if (type === 'static') {
                    const header = document.getElementById('staticHeader');
                    const controls = document.getElementById('staticControlsBottom');
                    const container = document.getElementById('staticCameraContainer');
                    
                    if (header && controls && container) {
                        // Show header and controls again
                        header.style.display = 'flex';
                        controls.style.display = 'block';
                        
                        // Remove fullscreen from camera container
                        container.classList.remove('fullscreen');
                        container.style.height = 'calc(100vh - 140px)';
                        container.style.minHeight = 'calc(100vh - 140px)';
                        
                        // Hide floating button and return to normal UI
                        hideFloatingButton('static');
                        console.log('✅ Static fullscreen mode deactivated');
                    }
                } else if (type === 'dynamic') {
                    const header = document.getElementById('dynamicHeader');
                    const controls = document.getElementById('dynamicControlsBottom');
                    const container = document.getElementById('dynamicCameraContainer');
                    
                    if (header && controls && container) {
                        // Show header and controls again
                        header.style.display = 'flex';
                        controls.style.display = 'block';
                        
                        // Remove fullscreen from camera container
                        container.classList.remove('fullscreen');
                        container.style.height = 'calc(100vh - 140px)';
                        container.style.minHeight = 'calc(100vh - 140px)';
                        
                        // Hide floating button and return to normal UI
                        hideFloatingButton('dynamic');
                        console.log('✅ Dynamic fullscreen mode deactivated');
                    }
                }
            } catch (error) {
                console.error('❌ Error exiting fullscreen mode:', error);
            }
        }
        
        // Floating button control functions
        function showFloatingButton(type) {
            hideAllFloatingButtons();
            if (type === 'static') {
                document.getElementById('floatingStaticBtn').classList.add('visible');
            } else if (type === 'dynamic') {
                document.getElementById('floatingDynamicBtn').classList.add('visible');
            }
        }
        
        function hideFloatingButton(type) {
            if (type === 'static') {
                document.getElementById('floatingStaticBtn').classList.remove('visible');
            } else if (type === 'dynamic') {
                document.getElementById('floatingDynamicBtn').classList.remove('visible');
            }
        }
        
        function hideAllFloatingButtons() {
            document.getElementById('floatingStaticBtn').classList.remove('visible');
            document.getElementById('floatingDynamicBtn').classList.remove('visible');
        }
        
        // Debug function to test fullscreen mode
        function testFullscreenMode() {
            console.log('Testing fullscreen mode for static analysis');
            enterFullscreenMode('static');
            setTimeout(() => {
                console.log('Exiting fullscreen mode after 3 seconds');
                exitFullscreenMode('static');
            }, 3000);
        }
        
        // Debug function to test voice
        function testVoice() {
            console.log('Testing voice synthesis...');
            enableSpeech();
            setTimeout(() => {
                speakCountdown('Voice test successful', true);
            }, 500);
        }
        
        // Make test functions available globally for debugging
        window.testVoice = testVoice;
        window.testFullscreenMode = testFullscreenMode;
        
        function showWelcome() {
            console.log('Showing welcome screen');
            showScreen('welcome');
            document.getElementById('welcome').classList.add('fade-in');
        }
        
        function showRegistration() {
            console.log('Showing registration screen');
            showScreen('registration');
            document.getElementById('registration').classList.add('slide-up');
        }
        
        function showDashboard() {
            console.log('Showing dashboard screen');
            
            // Exit any fullscreen mode first
            exitFullscreenMode('static');
            exitFullscreenMode('dynamic');
            
            // Stop camera and pose detection if running
            if (typeof stopCamera === 'function') stopCamera();
            if (typeof stopPoseDetection === 'function') stopPoseDetection();
            if (typeof isAnalyzing !== 'undefined') isAnalyzing = false;
            
            showScreen('dashboard');
            document.getElementById('dashboard').classList.add('fade-in');
            if (typeof updateDashboardContent === 'function') updateDashboardContent();
        }

        // サービスワーカーの登録
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Initialize audio systems
                initializeVoices();
                initializeAudioContext();
                
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('AthleteCore Pro: サービスワーカーが登録されました', registration.scope);
                        
                        // 更新チェック
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // 新しいバージョンが利用可能
                                    showUpdateAvailable();
                                }
                            });
                        });
                    })
                    .catch(error => {
                        console.log('サービスワーカーの登録に失敗しました:', error);
                    });
            });
        }

        // PWAインストールプロンプト
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallPrompt();
        });

        // インストール完了の検出
        window.addEventListener('appinstalled', () => {
            console.log('AthleteCore Pro: アプリがインストールされました');
            isInstalled = true;
            hideInstallPrompt();
        });

        // スタンドアローンモードの検出
        if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
            isInstalled = true;
            document.body.classList.add('installed');
        }

        // Test function availability - should all be 'function'
        console.log('✅ Function availability check:', {
            showScreen: typeof showScreen,
            showWelcome: typeof showWelcome, 
            showRegistration: typeof showRegistration,
            showDashboard: typeof showDashboard
        });
        
        // Test button click handler
        setTimeout(() => {
            const button = document.querySelector('button[onclick*="showRegistration"]');
            console.log('✅ Get Started button found:', !!button);
            if (button) {
                console.log('✅ Button onclick attribute:', button.getAttribute('onclick'));
            }
        }, 1000);
        
        // Initialize app
        setTimeout(async () => {
            loadLocalUser();
            showWelcome();
            
            // Add click event listeners to enable speech on user interaction
            document.addEventListener('click', enableSpeech, { once: false });
            document.addEventListener('touchstart', enableSpeech, { once: false });
            
            // Initialize MediaPipe Pose detection (in background)
            initMediaPipe().then(initialized => {
                if (initialized) {
                    console.log('✅ MediaPipe Pose initialized successfully in main app');
                } else {
                    console.error('❌ Failed to initialize MediaPipe Pose in main app');
                }
            }).catch(error => {
                console.error('Failed to initialize MediaPipe Pose:', error);
            });
        }, 2000);
        
        // Camera functions
        let cameraStream = null;
        let currentFacingMode = 'user'; // 'user' = front/インカメラ, 'environment' = back/アウトカメラ
        let currentVideoElementId = null;
        
        async function initCamera(videoElementId, placeholderId, facingMode = 'user') {
            try {
                console.log('🎥 Initializing camera:', videoElementId, facingMode);
                
                // Stop existing stream if any
                if (cameraStream) {
                    console.log('🔄 Stopping existing camera stream');
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // More explicit constraints for better camera switching
                const constraints = {
                    video: {
                        facingMode: { exact: facingMode },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
                
                console.log('📋 Camera constraints:', constraints);
                
                let stream;
                try {
                    // Try with exact constraint first
                    console.log('🔍 Trying exact facingMode constraint...');
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('✅ Camera access granted with exact constraint');
                } catch (exactError) {
                    console.log('⚠️ Exact facingMode failed, trying ideal:', exactError);
                    // Fallback to ideal constraint
                    constraints.video.facingMode = { ideal: facingMode };
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('✅ Camera access granted with ideal constraint');
                }
                
                const videoElement = document.getElementById(videoElementId);
                const placeholder = document.getElementById(placeholderId);
                
                if (!videoElement || !placeholder) {
                    console.error('❌ Video elements not found:', videoElementId, placeholderId);
                    return false;
                }
                
                console.log('📱 Video element found:', videoElement);
                console.log('🖼️ Placeholder element found:', placeholder);
                
                // Check actual camera facing mode from stream
                const videoTrack = stream.getVideoTracks()[0];
                const actualSettings = videoTrack.getSettings();
                const actualFacingMode = actualSettings.facingMode || facingMode;
                
                console.log('📊 Camera settings:', actualSettings);
                console.log('🎯 Requested facingMode:', facingMode, 'Actual facingMode:', actualFacingMode);
                
                // CRITICAL: Set video source
                videoElement.srcObject = stream;
                console.log('🔗 Video srcObject set');
                
                // Force show video with explicit styling and ensure visibility
                videoElement.style.display = 'block';
                videoElement.style.visibility = 'visible';
                videoElement.style.opacity = '1';
                videoElement.style.position = 'absolute';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.objectFit = 'cover';
                videoElement.style.zIndex = '5'; // Higher z-index to ensure video is above placeholder
                videoElement.style.transform = actualFacingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                videoElement.classList.remove('hidden');
                
                console.log('👁️ Video visibility forced - display:', videoElement.style.display, 'visibility:', videoElement.style.visibility);
                
                // Force hide placeholder completely
                placeholder.style.display = 'none';
                placeholder.style.visibility = 'hidden';
                placeholder.style.opacity = '0';
                placeholder.style.zIndex = '0';
                placeholder.classList.add('hidden');
                
                console.log('🚫 Placeholder hidden');
                
                cameraStream = stream;
                currentFacingMode = actualFacingMode; // Use actual facing mode
                currentVideoElementId = videoElementId;
                
                // Update camera label with actual facing mode
                updateCameraLabel(videoElementId, actualFacingMode);
                
                // Start pose detection when camera is ready - with multiple triggers
                videoElement.onloadedmetadata = () => {
                    console.log('📹 Video metadata loaded - dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                    const canvasElementId = videoElementId.replace('CameraFeed', 'PoseCanvas');
                    const statusElementId = videoElementId.includes('static') ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Start pose detection with a small delay to ensure video is fully ready
                    setTimeout(() => {
                        startPoseDetection(videoElementId, canvasElementId, statusElementId);
                    }, 500);
                };
                
                // Additional trigger when video can play
                videoElement.oncanplay = () => {
                    console.log('▶️ Video can play - ensuring pose detection is running');
                    const canvasElementId = videoElementId.replace('CameraFeed', 'PoseCanvas');
                    const statusElementId = videoElementId.includes('static') ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Only start if not already running
                    if (!poseDetectionInterval) {
                        setTimeout(() => {
                            startPoseDetection(videoElementId, canvasElementId, statusElementId);
                        }, 200);
                    }
                };
                
                // Add additional debug event listeners
                videoElement.oncanplay = () => {
                    console.log('▶️ Video can play');
                };
                
                videoElement.onplaying = () => {
                    console.log('🎬 Video playing');
                };
                
                videoElement.onerror = (error) => {
                    console.error('❌ Video error:', error);
                };
                
                console.log('✅ Camera initialized successfully with actual facingMode:', actualFacingMode);
                return true;
            } catch (error) {
                console.error('❌ Camera access denied or unavailable:', error);
                
                // Show error in placeholder
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div class="text-center text-white">
                            <div class="text-6xl mb-4">⚠️</div>
                            <p class="text-xl mb-2">Camera access denied</p>
                            <p class="text-sm opacity-75">カメラアクセスが拒否されました</p>
                            <p class="text-xs opacity-50 mt-2">${error.message}</p>
                        </div>
                    `;
                }
                return false;
            }
        }
        
        // Switch between front and back camera
        async function switchCamera(screenType) {
            if (!cameraStream) return;
            
            const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Determine video element IDs based on screen type
            const videoElementId = screenType === 'static' ? 'staticCameraFeed' : 'dynamicCameraFeed';
            const placeholderId = screenType === 'static' ? 'staticCameraPlaceholder' : 'dynamicCameraPlaceholder';
            
            // Add switching animation
            const switchButton = document.getElementById(`${screenType}CameraSwitch`);
            switchButton.style.transform = 'rotate(180deg)';
            
            try {
                // Initialize camera with new facing mode
                const success = await initCamera(videoElementId, placeholderId, newFacingMode);
                
                if (success) {
                    // Restart pose detection with new camera
                    const canvasElementId = screenType === 'static' ? 'staticPoseCanvas' : 'dynamicPoseCanvas';
                    const statusElementId = screenType === 'static' ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Small delay to ensure video is ready
                    setTimeout(() => {
                        startPoseDetection(videoElementId, canvasElementId, statusElementId);
                    }, 500);
                    
                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }
            } catch (error) {
                console.error('Failed to switch camera:', error);
                // Revert button animation on error
                switchButton.style.transform = 'rotate(0deg)';
            }
            
            // Reset button animation
            setTimeout(() => {
                switchButton.style.transform = 'rotate(0deg)';
            }, 300);
        }
        
        // Update camera label text
        function updateCameraLabel(videoElementId, facingMode) {
            const screenType = videoElementId.includes('static') ? 'static' : 'dynamic';
            const labelElement = document.getElementById(`${screenType}CameraLabel`);
            
            console.log('🏷️ Updating camera label for:', screenType, 'facingMode:', facingMode);
            
            if (labelElement) {
                if (facingMode === 'user') {
                    labelElement.textContent = 'インカメラ';
                    labelElement.classList.remove('bg-orange-500');
                    labelElement.classList.add('bg-black');
                } else {
                    labelElement.textContent = 'アウトカメラ';
                    labelElement.classList.remove('bg-black');
                    labelElement.classList.add('bg-orange-500');
                }
                console.log('🏷️ Label updated:', labelElement.textContent);
            }
            
            // Update video mirror effect - ENSURE video is visible first
            const videoElement = document.getElementById(videoElementId);
            if (videoElement) {
                // Force video to be visible before applying transform
                videoElement.style.display = 'block';
                videoElement.style.visibility = 'visible';
                videoElement.style.opacity = '1';
                
                if (facingMode === 'user') {
                    videoElement.style.transform = 'scaleX(-1)'; // Mirror for front camera
                    console.log('🪞 Applied mirror effect for front camera');
                } else {
                    videoElement.style.transform = 'scaleX(1)'; // Normal for back camera
                    console.log('📹 Applied normal orientation for back camera');
                }
                
                console.log('📺 Video element styles:', {
                    display: videoElement.style.display,
                    visibility: videoElement.style.visibility,
                    opacity: videoElement.style.opacity,
                    transform: videoElement.style.transform
                });
            } else {
                console.error('❌ Video element not found:', videoElementId);
            }
        }
        
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
        }
        
        // MediaPipe Pose Detection
        let pose = null;
        let currentPoseResults = null;
        let isAnalyzing = false;
        
        // Initialize MediaPipe Pose
        async function initMediaPipe() {
            console.log('Initializing MediaPipe Pose...');
            
            if (typeof Pose === 'undefined') {
                console.error('MediaPipe Pose not loaded - retrying in 1 second');
                setTimeout(initMediaPipe, 1000);
                return false;
            }
            
            try {
                pose = new Pose({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                    }
                });
                
                // Optimize settings for mobile devices
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log('Device type:', isMobile ? 'Mobile' : 'Desktop');
                
                pose.setOptions({
                    modelComplexity: 1, // Use model complexity 1 for better accuracy
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    smoothSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                pose.onResults(onPoseResults);
                
                // Wait for initialization to complete
                await new Promise(resolve => setTimeout(resolve, 100));
                
                console.log('✅ MediaPipe Pose initialized successfully');
                return true;
            } catch (error) {
                console.error('Failed to initialize MediaPipe Pose:', error);
                return false;
            }
        }
        
        // Handle pose detection results
        function onPoseResults(results) {
            currentPoseResults = results;
            
            console.log('Pose results received:', results.poseLandmarks ? results.poseLandmarks.length : 'no landmarks');
            
            // Update pose status indicators
            updatePoseStatus(results.poseLandmarks);
            
            // Draw pose landmarks on canvas - ALWAYS SHOW
            if (results.poseLandmarks) {
                console.log('🎯 Calling drawPoseLandmarks with', results.poseLandmarks.length, 'landmarks');
                drawPoseLandmarks(results);
                
                // Real-time squat detection for dynamic analysis
                const activeScreen = document.querySelector('.app-screen:not(.hidden)');
                if (activeScreen && activeScreen.id === 'dynamic-analysis') {
                    const squatDetection = detectSquat(results.poseLandmarks);
                    updateSquatCounter(squatDetection);
                }
                
                // Perform pose analysis if analyzing
                if (isAnalyzing) {
                    performPoseAnalysis(results.poseLandmarks);
                }
            } else {
                console.log('No pose landmarks detected');
            }
        }
        
        // Global movement tracking variables
        let currentSquatCount = 0;
        let lastSquatPhase = 'standing';
        let movementAnalysisData = [];
        let isWaitingForMovement = false;
        let movementStartTime = null;
        let lastMovementIntensity = 0;
        
        // Update squat counter display
        function updateSquatCounter(squatDetection) {
            if (!squatDetection) return;
            
            // Count completed squats
            if (squatDetection.phase === 'standing' && lastSquatPhase === 'up') {
                currentSquatCount++;
                
                // Update counter display
                const countElement = document.getElementById('squatCount');
                if (countElement) {
                    countElement.textContent = currentSquatCount;
                    
                    // Add animation effect
                    countElement.style.transform = 'scale(1.5)';
                    setTimeout(() => {
                        countElement.style.transform = 'scale(1)';
                    }, 200);
                }
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }
            
            lastSquatPhase = squatDetection.phase;
        }
        
        // Update pose detection status
        function updatePoseStatus(landmarks) {
            const staticIndicator = document.getElementById('staticPoseIndicator');
            const staticText = document.getElementById('staticPoseText');
            const dynamicIndicator = document.getElementById('dynamicPoseIndicator');
            const dynamicText = document.getElementById('dynamicPoseText');
            
            const isDetected = landmarks && landmarks.length > 0;
            const confidence = isDetected ? calculatePoseConfidence(landmarks) : 0;
            
            // Update static analysis status
            if (staticIndicator && staticText) {
                if (isDetected) {
                    staticIndicator.className = 'w-2 h-2 bg-green-500 rounded-full inline-block mr-1';
                    staticText.textContent = `Pose Detected (${Math.round(confidence * 100)}%)`;
                } else {
                    staticIndicator.className = 'w-2 h-2 bg-red-500 rounded-full inline-block mr-1';
                    staticText.textContent = 'No Pose Detected';
                }
            }
            
            // Update dynamic analysis status
            if (dynamicIndicator && dynamicText) {
                if (isDetected) {
                    dynamicIndicator.className = 'w-2 h-2 bg-green-500 rounded-full inline-block mr-1';
                    dynamicText.textContent = `Tracking (${Math.round(confidence * 100)}%)`;
                } else {
                    dynamicIndicator.className = 'w-2 h-2 bg-red-500 rounded-full inline-block mr-1';
                    dynamicText.textContent = 'No Movement Detected';
                }
            }
        }
        
        // Calculate pose detection confidence
        function calculatePoseConfidence(landmarks) {
            if (!landmarks || landmarks.length === 0) return 0;
            
            const visibleLandmarks = landmarks.filter(landmark => 
                landmark.visibility && landmark.visibility > 0.5
            );
            
            return visibleLandmarks.length / landmarks.length;
        }
        
        // Draw pose landmarks on canvas with enhanced visibility
        function drawPoseLandmarks(results) {
            console.log('🎨 Starting pose landmark drawing...', !!results.poseLandmarks);
            
            // Find active screen - check both active class and visibility
            const activeScreens = document.querySelectorAll('.app-screen.active');
            let activeScreen = null;
            
            // Prioritize the current screen that's actually visible
            if (currentScreen === 'static-analysis') {
                activeScreen = document.getElementById('static-analysis');
            } else if (currentScreen === 'dynamic-analysis') {
                activeScreen = document.getElementById('dynamic-analysis');
            } else {
                activeScreen = activeScreens[0];
            }
            
            let canvas, ctx, video;
            
            if (activeScreen && activeScreen.id === 'static-analysis') {
                canvas = document.getElementById('staticPoseCanvas');
                video = document.getElementById('staticCameraFeed');
                console.log('📍 Using static analysis canvas');
            } else if (activeScreen && activeScreen.id === 'dynamic-analysis') {
                canvas = document.getElementById('dynamicPoseCanvas');
                video = document.getElementById('dynamicCameraFeed');
                console.log('📍 Using dynamic analysis canvas');
            } else {
                console.log('❌ No active analysis screen found:', activeScreen?.id, 'currentScreen:', currentScreen);
                return;
            }
            
            if (!canvas) {
                console.log('❌ Canvas not found for screen:', activeScreen?.id);
                return;
            }
            
            if (!video) {
                console.log('❌ Video not found for screen:', activeScreen?.id);
                return;
            }
            
            if (!results.poseLandmarks || results.poseLandmarks.length === 0) {
                console.log('❌ No pose landmarks available');
                return;
            }
            
            // Ensure video is actually playing and has content
            if (video.videoWidth === 0 || video.videoHeight === 0) {
                console.log('❌ Video not ready - dimensions:', video.videoWidth, 'x', video.videoHeight);
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            // Force canvas to be absolutely visible and above video
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '15'; // Higher than video (zIndex: 5)
            
            // Get video container dimensions (not video element itself)
            const videoContainer = video.parentElement;
            const containerRect = videoContainer.getBoundingClientRect();
            
            console.log('📐 Container dimensions:', containerRect.width, 'x', containerRect.height);
            console.log('📐 Video actual dimensions:', video.videoWidth, 'x', video.videoHeight);
            
            // Set canvas size to match video container exactly
            canvas.width = containerRect.width;
            canvas.height = containerRect.height;
            canvas.style.width = containerRect.width + 'px';
            canvas.style.height = containerRect.height + 'px';
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Add a subtle debug indicator to ensure canvas is working
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Very faint green background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            console.log('🎨 Canvas setup - Size:', canvas.width, 'x', canvas.height, 'Landmarks:', results.poseLandmarks.length);
            
            // Draw pose connections and landmarks with maximum visibility
            if (results.poseLandmarks && results.poseLandmarks.length > 0) {
                
                let connectionsDrawn = 0;
                let landmarksDrawn = 0;
                
                // Check if this is a front camera (mirrored) based on the current video element transform
                const videoElement = document.getElementById('analysisCamera');
                const isFrontCamera = videoElement && videoElement.style.transform.includes('scaleX(-1)');
                console.log(`📹 Drawing skeleton for ${isFrontCamera ? 'front (mirrored)' : 'back'} camera`);
                
                // Draw skeleton connections
                ctx.strokeStyle = '#F5F5DC'; // Beige color
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                POSE_CONNECTIONS.forEach((connection, idx) => {
                    const start = results.poseLandmarks[connection[0]];
                    const end = results.poseLandmarks[connection[1]];
                    
                    if (start && end) {
                        // Lower visibility threshold for more connections
                        const startVisible = !start.visibility || start.visibility > 0.3;
                        const endVisible = !end.visibility || end.visibility > 0.3;
                        
                        if (startVisible && endVisible) {
                            ctx.beginPath();
                            // Mirror x coordinates for front camera to match video display
                            const startX = isFrontCamera ? (1 - start.x) * canvas.width : start.x * canvas.width;
                            const startY = start.y * canvas.height;
                            const endX = isFrontCamera ? (1 - end.x) * canvas.width : end.x * canvas.width;
                            const endY = end.y * canvas.height;
                            
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                            connectionsDrawn++;
                            
                            // Debug: log first few connections
                            if (idx < 3) {
                                console.log(`🔗 Connection ${idx}: (${startX.toFixed(1)}, ${startY.toFixed(1)}) -> (${endX.toFixed(1)}, ${endY.toFixed(1)})`);
                            }
                        }
                    }
                });
                
                // Draw landmark points on top
                ctx.fillStyle = '#9ACD32'; // Khaki/YellowGreen color
                results.poseLandmarks.forEach((landmark, index) => {
                    const visible = !landmark.visibility || landmark.visibility > 0.3;
                    
                    if (visible) {
                        // Mirror x coordinates for front camera to match video display
                        const x = isFrontCamera ? (1 - landmark.x) * canvas.width : landmark.x * canvas.width;
                        const y = landmark.y * canvas.height;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI); // 8px diameter (4px radius)
                        ctx.fill();
                        landmarksDrawn++;
                        
                        // Draw landmark index for key points (nose, shoulders, hips)
                        if ([0, 11, 12, 23, 24].includes(index)) {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 12px Arial';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.strokeText(index.toString(), x + 10, y + 5);
                            ctx.fillText(index.toString(), x + 10, y + 5);
                            ctx.fillStyle = '#9ACD32'; // Reset to khaki after text drawing
                        }
                        
                        // Debug: log first few landmarks
                        if (index < 5) {
                            console.log(`🎯 Landmark ${index}: (${x.toFixed(1)}, ${y.toFixed(1)}) visibility: ${landmark.visibility?.toFixed(2) || 'N/A'}`);
                        }
                    }
                });
                
                console.log(`✅ Drawing complete! Connections: ${connectionsDrawn}/${POSE_CONNECTIONS.length}, Landmarks: ${landmarksDrawn}/${results.poseLandmarks.length}`);
                
                // Draw a visible test indicator in corner to confirm canvas is working
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(5, 5, 15, 15);
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('OK', 25, 15);
                console.log('🟨 Debug indicator drawn');
                
            } else {
                console.log('❌ No pose landmarks to draw');
            }
        }
        
        // Helper function to draw connections
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(connection => {
                const start = landmarks[connection[0]];
                const end = landmarks[connection[1]];
                
                if (start && end && start.visibility > 0.5 && end.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(start.x * ctx.canvas.width, start.y * ctx.canvas.height);
                    ctx.lineTo(end.x * ctx.canvas.width, end.y * ctx.canvas.height);
                    ctx.stroke();
                }
            });
        }
        
        // Helper function to draw landmarks
        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                if (landmark.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(
                        landmark.x * ctx.canvas.width,
                        landmark.y * ctx.canvas.height,
                        style.radius,
                        0,
                        2 * Math.PI
                    );
                    ctx.fill();
                }
            });
        }
        
        // MediaPipe pose connections
        const POSE_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [17, 19], [19, 15],
            [15, 21], [12, 14], [14, 16], [16, 18], [18, 20], [20, 16], [16, 22],
            [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28],
            [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]
        ];
        
        // Pose Analysis Algorithms
        function performPoseAnalysis(landmarks) {
            const analysis = {
                posture: analyzePosture(landmarks),
                balance: analyzeBalance(landmarks),
                angles: calculateKeyAngles(landmarks),
                timestamp: Date.now()
            };
            
            // Store analysis results
            currentPoseAnalysis = analysis;
            
            return analysis;
        }
        
        // Analyze posture alignment
        function analyzePosture(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            // Key landmarks for posture analysis
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            
            // Calculate head forward posture
            const headForward = calculateHeadForwardPosture(nose, leftShoulder, rightShoulder);
            
            // Calculate shoulder elevation
            const shoulderElevation = Math.abs(leftShoulder.y - rightShoulder.y);
            
            // Calculate hip alignment
            const hipAlignment = Math.abs(leftHip.y - rightHip.y);
            
            // Calculate overall posture score (0-100)
            const postureScore = calculatePostureScore(headForward, shoulderElevation, hipAlignment);
            
            return {
                headForward: headForward,
                shoulderElevation: shoulderElevation,
                hipAlignment: hipAlignment,
                score: postureScore,
                grade: getPostureGrade(postureScore)
            };
        }
        
        // Analyze balance and stability
        function analyzeBalance(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            // Calculate center of gravity
            const centerOfGravity = {
                x: (leftAnkle.x + rightAnkle.x) / 2,
                y: (leftAnkle.y + rightAnkle.y) / 2
            };
            
            // Calculate balance deviation
            const balanceDeviation = Math.sqrt(
                Math.pow(nose.x - centerOfGravity.x, 2) + 
                Math.pow(nose.y - centerOfGravity.y, 2)
            );
            
            // Calculate balance score
            const balanceScore = Math.max(0, 100 - (balanceDeviation * 1000));
            
            return {
                centerOfGravity: centerOfGravity,
                deviation: balanceDeviation,
                score: balanceScore,
                stability: balanceScore > 80 ? 'Excellent' : 
                          balanceScore > 60 ? 'Good' : 
                          balanceScore > 40 ? 'Fair' : 'Poor'
            };
        }
        
        // Calculate key body angles
        function calculateKeyAngles(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            // Neck angle
            const neckAngle = calculateAngle(
                landmarks[0],  // nose
                landmarks[11], // left shoulder
                landmarks[12]  // right shoulder
            );
            
            // Spine angle (simplified)
            const spineAngle = calculateAngle(
                landmarks[11], // left shoulder
                landmarks[23], // left hip
                landmarks[27]  // left ankle
            );
            
            // Knee angles
            const leftKneeAngle = calculateAngle(
                landmarks[23], // left hip
                landmarks[25], // left knee
                landmarks[27]  // left ankle
            );
            
            const rightKneeAngle = calculateAngle(
                landmarks[24], // right hip
                landmarks[26], // right knee
                landmarks[28]  // right ankle
            );
            
            return {
                neck: neckAngle,
                spine: spineAngle,
                leftKnee: leftKneeAngle,
                rightKnee: rightKneeAngle,
                symmetry: Math.abs(leftKneeAngle - rightKneeAngle)
            };
        }
        
        // Calculate angle between three points
        function calculateAngle(pointA, pointB, pointC) {
            const vectorBA = {
                x: pointA.x - pointB.x,
                y: pointA.y - pointB.y
            };
            
            const vectorBC = {
                x: pointC.x - pointB.x,
                y: pointC.y - pointB.y
            };
            
            const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;
            const magnitudeBA = Math.sqrt(vectorBA.x * vectorBA.x + vectorBA.y * vectorBA.y);
            const magnitudeBC = Math.sqrt(vectorBC.x * vectorBC.x + vectorBC.y * vectorBC.y);
            
            const cosineAngle = dotProduct / (magnitudeBA * magnitudeBC);
            const angleRadians = Math.acos(Math.max(-1, Math.min(1, cosineAngle)));
            
            return angleRadians * (180 / Math.PI);
        }
        
        // Helper functions for posture analysis
        function calculateHeadForwardPosture(nose, leftShoulder, rightShoulder) {
            const shoulderCenter = {
                x: (leftShoulder.x + rightShoulder.x) / 2,
                y: (leftShoulder.y + rightShoulder.y) / 2
            };
            
            return Math.abs(nose.x - shoulderCenter.x);
        }
        
        function calculatePostureScore(headForward, shoulderElevation, hipAlignment) {
            let score = 100;
            
            // Deduct points for poor posture
            score -= (headForward * 200); // Head forward penalty
            score -= (shoulderElevation * 300); // Shoulder elevation penalty
            score -= (hipAlignment * 400); // Hip misalignment penalty
            
            return Math.max(0, Math.min(100, score));
        }
        
        function getPostureGrade(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B';
            if (score >= 60) return 'C';
            if (score >= 50) return 'D';
            return 'F';
        }
        
        // Start pose detection for video element (Direct approach without Camera class)
        let poseDetectionInterval = null;
        
        function startPoseDetection(videoElementId, canvasElementId, statusElementId) {
            console.log('🎬 Starting pose detection...', { videoElementId, canvasElementId, statusElementId });
            
            const video = document.getElementById(videoElementId);
            const canvas = document.getElementById(canvasElementId);
            const status = document.getElementById(statusElementId);
            
            if (!video || !canvas || !pose) {
                console.error('❌ Missing elements:', { video: !!video, canvas: !!canvas, pose: !!pose });
                return;
            }
            
            console.log('✅ All elements found for pose detection');
            
            // Force canvas to be visible and properly positioned ABOVE video
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '15'; // Higher than video (zIndex: 5)
            canvas.style.pointerEvents = 'none';
            
            // Remove hidden class
            canvas.classList.remove('hidden');
            status.classList.remove('hidden');
            
            console.log('🎨 Canvas setup complete - zIndex:', canvas.style.zIndex);
            
            // Stop any existing detection
            if (poseDetectionInterval) {
                console.log('🔄 Stopping existing pose detection');
                clearInterval(poseDetectionInterval);
                poseDetectionInterval = null;
            }
            
            // Wait for video to be ready with enhanced checking
            const waitForVideo = () => {
                const videoReady = video.videoWidth > 0 && video.videoHeight > 0 && video.readyState >= video.HAVE_CURRENT_DATA;
                
                console.log('📹 Video status check:', {
                    videoWidth: video.videoWidth,
                    videoHeight: video.videoHeight,
                    readyState: video.readyState,
                    srcObject: !!video.srcObject,
                    ready: videoReady
                });
                
                if (videoReady) {
                    console.log('✅ Video ready for pose detection:', video.videoWidth, 'x', video.videoHeight);
                    
                    // Set canvas size to match video container exactly
                    const container = canvas.parentElement;
                    const rect = container.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    
                    console.log('📐 Canvas resized to container:', rect.width, 'x', rect.height);
                    
                    // Test draw something immediately to verify canvas works
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(0, 0, 30, 30);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('POSE', 5, 20);
                    console.log('🟢 Test draw on canvas completed');
                    
                    // Start pose detection with lower frame rate for stability
                    poseDetectionInterval = setInterval(async () => {
                        if (pose && video.videoWidth > 0 && video.readyState >= video.HAVE_CURRENT_DATA) {
                            try {
                                await pose.send({ image: video });
                            } catch (error) {
                                console.error('❌ Pose detection error:', error);
                            }
                        }
                    }, 50); // ~20 FPS for better stability
                    
                    console.log('🚀 Pose detection interval started successfully');
                    
                    // Show additional UI elements for dynamic analysis
                    if (videoElementId === 'dynamicCameraFeed') {
                        const counter = document.getElementById('movementCounter');
                        if (counter) {
                            counter.classList.remove('hidden');
                            console.log('📊 Movement counter made visible');
                        }
                    }
                    
                } else {
                    console.log('⏳ Waiting for video to be ready... (attempt)', Date.now());
                    setTimeout(waitForVideo, 200); // Slightly longer wait
                }
            };
            
            // Start checking for video readiness with a small delay
            setTimeout(waitForVideo, 300);
        }
        
        // Stop pose detection
        function stopPoseDetection() {
            // Stop interval-based detection
            if (poseDetectionInterval) {
                clearInterval(poseDetectionInterval);
                poseDetectionInterval = null;
            }
            
            // Hide canvas and status elements
            document.getElementById('staticPoseCanvas')?.classList.add('hidden');
            document.getElementById('staticPoseStatus')?.classList.add('hidden');
            document.getElementById('dynamicPoseCanvas')?.classList.add('hidden');
            document.getElementById('dynamicPoseStatus')?.classList.add('hidden');
        }
        
        // Process static analysis results
        function processStaticAnalysisResults(results) {
            if (!results || results.length === 0) return null;
            
            // Calculate averages from multiple samples
            const avgPosture = {
                score: results.reduce((sum, r) => sum + (r.posture?.score || 0), 0) / results.length,
                headForward: results.reduce((sum, r) => sum + (r.posture?.headForward || 0), 0) / results.length,
                shoulderElevation: results.reduce((sum, r) => sum + (r.posture?.shoulderElevation || 0), 0) / results.length,
                hipAlignment: results.reduce((sum, r) => sum + (r.posture?.hipAlignment || 0), 0) / results.length
            };
            
            const avgBalance = {
                score: results.reduce((sum, r) => sum + (r.balance?.score || 0), 0) / results.length,
                deviation: results.reduce((sum, r) => sum + (r.balance?.deviation || 0), 0) / results.length
            };
            
            const avgAngles = {
                neck: results.reduce((sum, r) => sum + (r.angles?.neck || 0), 0) / results.length,
                spine: results.reduce((sum, r) => sum + (r.angles?.spine || 0), 0) / results.length,
                symmetry: results.reduce((sum, r) => sum + (r.angles?.symmetry || 0), 0) / results.length
            };
            
            // Calculate overall score
            const overallScore = Math.round((avgPosture.score * 0.4 + avgBalance.score * 0.3 + (100 - avgAngles.symmetry) * 0.3));
            
            return {
                type: 'static',
                overall_score: overallScore,
                posture_score: Math.round(avgPosture.score),
                balance_score: Math.round(avgBalance.score),
                flexibility_score: Math.round(100 - avgAngles.symmetry),
                recommendations: generatePostureRecommendations(avgPosture, avgBalance, avgAngles),
                detailed_analysis: {
                    posture: avgPosture,
                    balance: avgBalance,
                    angles: avgAngles
                },
                timestamp: new Date().toISOString()
            };
        }
        
        // Generate posture-based recommendations
        function generatePostureRecommendations(posture, balance, angles) {
            const recommendations = [];
            
            if (posture.headForward > 0.05) {
                recommendations.push("頭部前方突出を改善するため、首のストレッチと背筋強化を行ってください");
                recommendations.push("Improve forward head posture with neck stretches and back strengthening");
            }
            
            if (posture.shoulderElevation > 0.03) {
                recommendations.push("肩の高さの違いを修正するため、片側の筋肉のストレッチを行ってください");
                recommendations.push("Address shoulder height imbalance with unilateral stretches");
            }
            
            if (balance.score < 70) {
                recommendations.push("バランス改善のため、片足立ちやバランスボード練習を取り入れてください");
                recommendations.push("Improve balance with single-leg stands and balance board exercises");
            }
            
            if (angles.symmetry > 10) {
                recommendations.push("左右の対称性を改善するため、弱い側の筋力強化を重点的に行ってください");
                recommendations.push("Focus on strengthening the weaker side to improve symmetry");
            }
            
            return recommendations;
        }
        
        // Movement Detection Algorithms
        function detectMovement(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            const movement = {
                type: 'unknown',
                velocity: calculateMovementVelocity(landmarks),
                range: calculateRangeOfMotion(landmarks),
                stability: calculateMovementStability(landmarks)
            };
            
            return movement;
        }
        
        // Squat Detection Algorithm
        function detectSquat(landmarks) {
            if (!landmarks || landmarks.length < 33) return { isSquat: false, phase: 'unknown' };
            
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            
            // Calculate hip height (average of both hips)
            const hipHeight = (leftHip.y + rightHip.y) / 2;
            
            // Calculate knee angles
            const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
            const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
            const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;
            
            // Determine squat phase based on knee angle and hip height
            let phase = 'standing';
            let isSquat = false;
            
            if (avgKneeAngle < 120 && hipHeight > 0.6) {
                phase = 'down';
                isSquat = true;
            } else if (avgKneeAngle < 90 && hipHeight > 0.7) {
                phase = 'bottom';
                isSquat = true;
            } else if (avgKneeAngle > 120 && avgKneeAngle < 160) {
                phase = 'up';
                isSquat = true;
            } else if (avgKneeAngle > 160) {
                phase = 'standing';
                isSquat = false;
            }
            
            return {
                isSquat: isSquat,
                phase: phase,
                kneeAngle: avgKneeAngle,
                hipHeight: hipHeight,
                form: evaluateSquatForm(landmarks)
            };
        }
        
        // Evaluate squat form quality
        function evaluateSquatForm(landmarks) {
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            let formScore = 100;
            const issues = [];
            
            // Check knee alignment (knees should not cave inward)
            const kneeWidth = Math.abs(leftKnee.x - rightKnee.x);
            const ankleWidth = Math.abs(leftAnkle.x - rightAnkle.x);
            
            if (kneeWidth < ankleWidth * 0.8) {
                formScore -= 20;
                issues.push("膝が内側に入っています / Knees caving inward");
            }
            
            // Check forward lean (torso should be relatively upright)
            const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
            const forwardLean = Math.abs(nose.x - hipCenter.x);
            
            if (forwardLean > 0.1) {
                formScore -= 15;
                issues.push("前傾しすぎています / Excessive forward lean");
            }
            
            // Check depth (hips should go below knee level)
            const hipHeight = (leftHip.y + rightHip.y) / 2;
            const kneeHeight = (leftKnee.y + rightKnee.y) / 2;
            
            if (hipHeight < kneeHeight) {
                formScore -= 10;
                issues.push("深度が不足しています / Insufficient depth");
            }
            
            return {
                score: Math.max(0, formScore),
                issues: issues,
                grade: formScore >= 90 ? 'Excellent' : 
                       formScore >= 80 ? 'Good' : 
                       formScore >= 70 ? 'Fair' : 'Poor'
            };
        }
        
        // Calculate movement velocity
        function calculateMovementVelocity(landmarks) {
            // This would typically compare with previous frame data
            // For now, return a placeholder
            return Math.random() * 10;
        }
        
        // Calculate range of motion
        function calculateRangeOfMotion(landmarks) {
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            
            const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
            const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
            
            return {
                kneeFlexion: Math.min(leftKneeAngle, rightKneeAngle),
                symmetry: Math.abs(leftKneeAngle - rightKneeAngle)
            };
        }
        
        // Calculate movement stability
        function calculateMovementStability(landmarks) {
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            // Calculate center of gravity deviation
            const centerOfGravity = {
                x: (leftAnkle.x + rightAnkle.x) / 2,
                y: (leftAnkle.y + rightAnkle.y) / 2
            };
            
            const deviation = Math.sqrt(
                Math.pow(nose.x - centerOfGravity.x, 2) + 
                Math.pow(nose.y - centerOfGravity.y, 2)
            );
            
            return Math.max(0, 100 - (deviation * 500));
        }
        
        // Process dynamic analysis results
        function processDynamicAnalysisResults(movementData, squatCount) {
            if (!movementData || movementData.length === 0) return null;
            
            // Analyze movement quality over time
            const avgFormScore = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.stability || 0), 0) / movementData.length;
            
            const avgRangeOfMotion = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.range.kneeFlexion || 0), 0) / movementData.length;
            
            const avgSymmetry = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.range.symmetry || 0), 0) / movementData.length;
            
            // Calculate overall score
            const overallScore = Math.round((avgFormScore * 0.4 + avgRangeOfMotion * 0.3 + (100 - avgSymmetry) * 0.3));
            
            return {
                type: 'dynamic',
                overall_score: overallScore,
                posture_score: Math.round(avgFormScore),
                balance_score: Math.round(avgFormScore),
                flexibility_score: Math.round(avgRangeOfMotion),
                repetitions: squatCount,
                movement_quality: avgFormScore >= 80 ? 'Excellent' : 
                                avgFormScore >= 60 ? 'Good' : 'Needs Improvement',
                recommendations: generateMovementRecommendations(avgFormScore, avgRangeOfMotion, avgSymmetry),
                timestamp: new Date().toISOString()
            };
        }
        
        // Generate movement-based recommendations
        function generateMovementRecommendations(formScore, rangeOfMotion, symmetry) {
            const recommendations = [];
            
            if (formScore < 70) {
                recommendations.push("動作フォームの改善が必要です。ゆっくりと正確な動作を心がけてください");
                recommendations.push("Focus on movement form. Perform exercises slowly with proper technique");
            }
            
            if (rangeOfMotion < 90) {
                recommendations.push("可動域を広げるため、ストレッチと柔軟性向上の練習を行ってください");
                recommendations.push("Improve range of motion with stretching and flexibility exercises");
            }
            
            if (symmetry > 15) {
                recommendations.push("左右の動作の対称性を改善してください。片側を重点的に練習しましょう");
                recommendations.push("Work on movement symmetry. Focus on the weaker side");
            }
            
            return recommendations;
        }
        
        // API functions
        async function saveUserProfile(profileData) {
            try {
                const response = await fetch('tables/user_profiles', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...profileData,
                        created_at: new Date().toISOString()
                    })
                });
                return await response.json();
            } catch (error) {
                console.error('Error saving profile:', error);
                return null;
            }
        }
        
        async function saveAnalysisResult(resultData) {
            try {
                const response = await fetch('tables/analysis_results', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...resultData,
                        analysis_date: new Date().toISOString()
                    })
                });
                return await response.json();
            } catch (error) {
                console.error('Error saving analysis:', error);
                return null;
            }
        }
        
        async function getUserAnalysisHistory(userId) {
            try {
                const response = await fetch(`tables/analysis_results?search=${userId}&sort=analysis_date`);
                const data = await response.json();
                return data.data.filter(result => result.user_id === userId);
            } catch (error) {
                console.error('Error fetching history:', error);
                return [];
            }
        }
        
        // Navigation functions already defined above
        
        async function handleRegistration() {
            const form = document.getElementById('profileForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            const profileData = {
                id: generateUUID(),
                name: document.getElementById('name').value,
                age: parseInt(document.getElementById('age').value),
                height: parseInt(document.getElementById('height').value),
                weight: parseInt(document.getElementById('weight').value),
                primary_sport: document.getElementById('primarySport').value,
                experience_level: document.getElementById('experienceLevel').value,
                created_at: new Date().toISOString()
            };

            // オフライン対応：ローカルストレージに保存
            try {
                localStorage.setItem('athletecore_user', JSON.stringify(profileData));
                currentUser = profileData;
                console.log('Profile saved locally:', currentUser);
                showDashboard();
            } catch (error) {
                console.error('Local storage error:', error);
                // ローカルストレージが使えない場合でもメモリに保存
                currentUser = profileData;
                showDashboard();
            }
        }
        
        // UUID生成関数
        function generateUUID() {
            return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // アプリ起動時にローカルデータをロード
        function loadLocalUser() {
            try {
                const savedUser = localStorage.getItem('athletecore_user');
                if (savedUser) {
                    currentUser = JSON.parse(savedUser);
                    console.log('Loaded user from local storage:', currentUser);
                }
            } catch (error) {
                console.error('Error loading local user:', error);
            }
        }

        // showDashboard function moved to top
        
        async function updateDashboardContent() {
            if (currentUser) {
                // Update greeting with user name
                const greetingElement = document.querySelector('#dashboard h1');
                if (greetingElement) {
                    greetingElement.textContent = `Hello, ${currentUser.name}!`;
                }
                
                // Load and display analysis history
                await loadAnalysisHistory();
            }
        }
        
        // ローカル保存関数
        function saveAnalysisResultLocal(resultData) {
            try {
                let results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                results.push(resultData);
                // 最新10件のみ保持
                if (results.length > 10) {
                    results = results.slice(-10);
                }
                localStorage.setItem('athletecore_results', JSON.stringify(results));
                console.log('Analysis result saved locally:', resultData);
            } catch (error) {
                console.error('Error saving analysis result locally:', error);
            }
        }
        
        function loadAnalysisHistory() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const userResults = results.filter(result => result.user_id === currentUser.id);
                const historyContainer = document.getElementById('analysisHistory');
                
                if (userResults.length === 0) {
                    historyContainer.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No analysis yet / まだ分析がありません</p>';
                    return;
                }
                
                historyContainer.innerHTML = userResults.slice(-5).reverse().map(analysis => {
                    const date = new Date(analysis.analysis_date).toLocaleDateString('ja-JP');
                    const typeLabel = {
                        'static': 'Static / 静的',
                        'dynamic': 'Dynamic / 動的',
                        'sport_specific': 'Sport / 競技特化'
                    };
                    
                    return `
                        <div class="bg-white p-3 rounded-lg border border-gray-100">
                            <div class="flex justify-between items-center">
                                <div>
                                    <div class="text-sm font-medium brand-color">${typeLabel[analysis.analysis_type] || analysis.analysis_type}</div>
                                    <div class="text-xs text-gray-500">${date}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-bold ${analysis.overall_score >= 80 ? 'text-green-600' : 'text-orange-600'}">${analysis.overall_score}/100</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error loading history:', error);
                document.getElementById('analysisHistory').innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No analysis yet / まだ分析がありません</p>';
            }
        }
        
        async function showStaticAnalysis() {
            console.log('🎯 Starting static analysis...');
            showScreen('static-analysis');
            document.getElementById('static-analysis').classList.add('slide-up');
            
            // Initialize MediaPipe if not already done
            if (!pose) {
                console.log('🧠 Initializing MediaPipe...');
                const initialized = await initMediaPipe();
                if (!initialized) {
                    console.error('❌ Failed to initialize MediaPipe for static analysis');
                    return;
                }
            } else {
                console.log('✅ MediaPipe already initialized');
            }
            
            // Reset to front camera
            currentFacingMode = 'user';
            console.log('📱 Set to front camera mode');
            
            // Initialize camera and pose detection with debug
            setTimeout(async () => {
                console.log('🎥 Initializing camera for static analysis...');
                const cameraInitialized = await initCamera('staticCameraFeed', 'staticCameraPlaceholder', 'user');
                
                if (cameraInitialized) {
                    console.log('✅ Camera initialized, waiting for video to be ready...');
                    
                    // Check video element immediately
                    const videoElement = document.getElementById('staticCameraFeed');
                    if (videoElement) {
                        console.log('📺 Video element state:', {
                            srcObject: !!videoElement.srcObject,
                            videoWidth: videoElement.videoWidth,
                            videoHeight: videoElement.videoHeight,
                            readyState: videoElement.readyState,
                            display: videoElement.style.display,
                            visibility: videoElement.style.visibility
                        });
                    }
                    
                    // Wait a bit more for video to be ready
                    setTimeout(() => {
                        console.log('🎬 Starting pose detection...');
                        startPoseDetection('staticCameraFeed', 'staticPoseCanvas', 'staticPoseStatus');
                    }, 1000);
                } else {
                    console.error('❌ Camera initialization failed');
                }
            }, 500);
        }
        
        async function showDynamicAnalysis() {
            showScreen('dynamic-analysis');
            document.getElementById('dynamic-analysis').classList.add('slide-up');
            
            // Reset squat counter
            currentSquatCount = 0;
            lastSquatPhase = 'standing';
            const countElement = document.getElementById('squatCount');
            if (countElement) countElement.textContent = '0';
            
            // Initialize MediaPipe if not already done
            if (!pose) {
                const initialized = await initMediaPipe();
                if (!initialized) {
                    console.error('Failed to initialize MediaPipe for dynamic analysis');
                    return;
                }
            }
            
            // Reset to front camera
            currentFacingMode = 'user';
            
            // Initialize camera and pose detection
            setTimeout(async () => {
                const cameraInitialized = await initCamera('dynamicCameraFeed', 'dynamicCameraPlaceholder', 'user');
                if (cameraInitialized) {
                    // Wait a bit more for video to be ready
                    setTimeout(() => {
                        startPoseDetection('dynamicCameraFeed', 'dynamicPoseCanvas', 'dynamicPoseStatus');
                    }, 1000);
                }
            }, 500);
        }
        
        function showSportSpecific() {
            showDynamicAnalysis(); // For demo purposes
        }
        
        function showResults() {
            showScreen('results');
            document.getElementById('results').classList.add('fade-in');
        }
        
        function selectSport(sport) {
            // ハプティクスフィードバック
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('bg-blue-50', 'brand-color', 'font-medium');
                btn.classList.add('text-gray-600');
            });
            
            event.target.classList.add('bg-blue-50', 'brand-color', 'font-medium');
        }
        
        // Voice speech function for countdown
        let voicesLoaded = false;
        let preferredVoice = null;
        
        // Initialize voices when available
        let speechEnabled = false;
        
        // Web Audio API for reliable sound feedback (alternative to speech synthesis)
        let audioContext = null;
        let soundEnabled = false;
        
        function initializeAudioContext() {
            try {
                if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    soundEnabled = true;
                    console.log('✅ Audio context initialized');
                    return true;
                }
            } catch (error) {
                console.warn('⚠️ Audio context initialization failed:', error);
            }
            return false;
        }
        
        function playCountdownBeep(frequency = 800, duration = 200, isWarning = false) {
            if (!soundEnabled || !audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different frequencies and patterns for different countdown states
                if (isWarning) {
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.1);
                } else {
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                }
                
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
                
                console.log(`🔊 Played beep: ${frequency}Hz for ${duration}ms`);
            } catch (error) {
                console.warn('⚠️ Beep sound failed:', error);
            }
        }
        
        function playSuccessChime() {
            if (!soundEnabled || !audioContext) return;
            
            try {
                // Play a pleasant ascending chime
                const frequencies = [523, 659, 784]; // C, E, G notes
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        playCountdownBeep(freq, 300, false);
                    }, index * 150);
                });
                console.log('🎵 Played success chime');
            } catch (error) {
                console.warn('⚠️ Success chime failed:', error);
            }
        }
        
        function initializeVoices() {
            if ('speechSynthesis' in window) {
                const loadVoices = () => {
                    const voices = speechSynthesis.getVoices();
                    if (voices.length > 0 && !voicesLoaded) {
                        voicesLoaded = true;
                        // Try to find a good English voice
                        preferredVoice = voices.find(voice => 
                            voice.lang.startsWith('en') && 
                            (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.name.includes('Apple'))
                        ) || voices.find(voice => voice.lang.startsWith('en')) || voices[0];
                        
                        console.log('✅ Voice initialized:', preferredVoice ? preferredVoice.name : 'Default voice');
                        console.log('Available voices:', voices.length);
                        
                        // Test voice functionality
                        if (preferredVoice) {
                            console.log('Selected voice details:', {
                                name: preferredVoice.name,
                                lang: preferredVoice.lang,
                                localService: preferredVoice.localService
                            });
                        }
                    }
                };
                
                // Load voices immediately if available
                loadVoices();
                
                // Also load when voices change (for some browsers)
                speechSynthesis.onvoiceschanged = loadVoices;
                
                // Force load voices after a delay
                setTimeout(loadVoices, 1000);
                setTimeout(loadVoices, 3000); // Additional retry
            } else {
                console.warn('Speech synthesis not supported');
            }
        }
        
        // Enable speech and audio after user interaction
        function enableSpeech() {
            // Enable speech synthesis
            if (!speechEnabled && 'speechSynthesis' in window) {
                try {
                    const testUtterance = new SpeechSynthesisUtterance('');
                    testUtterance.volume = 0;
                    speechSynthesis.speak(testUtterance);
                    speechEnabled = true;
                    console.log('✅ Speech enabled after user interaction');
                } catch (error) {
                    console.error('Failed to enable speech:', error);
                }
            }
            
            // Enable Web Audio API
            if (!soundEnabled) {
                initializeAudioContext();
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('✅ Audio context resumed after user interaction');
                    });
                }
            }
        }
        
        function speakCountdown(text, shouldSpeak = true) {
            // Only speak if enabled and speech synthesis is available
            if (shouldSpeak && 'speechSynthesis' in window && speechEnabled) {
                console.log('🔊 Attempting to speak:', text);
                
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                // Small delay to ensure cancellation is processed
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.8;  // Slightly slower for clarity
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0; // Maximum volume
                    
                    // Use preferred voice if available
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                        console.log('Using voice:', preferredVoice.name);
                    }
                    
                    // Add comprehensive error handling
                    utterance.onerror = (event) => {
                        console.error('❌ Speech synthesis error:', event.error, 'for text:', text);
                    };
                    
                    utterance.onstart = () => {
                        console.log('✅ Speech started:', text);
                    };
                    
                    utterance.onend = () => {
                        console.log('✅ Speech ended:', text);
                    };
                    
                    try {
                        speechSynthesis.speak(utterance);
                        console.log('🔊 Speech queued:', text);
                    } catch (error) {
                        console.error('❌ Speech synthesis failed:', error);
                    }
                }, 50);
            } else {
                if (!speechEnabled) {
                    console.warn('⚠️ Speech not enabled - user interaction required');
                } else {
                    console.log('Speech not available or disabled');
                }
            }
        }
        
        // Improved static capture with countdown
        async function startStaticCaptureImproved() {
            // Enable speech after user interaction
            enableSpeech();
            
            // Check if we're using front camera for voice enablement
            const isFrontCamera = currentFacingMode === 'user';
            console.log('Starting static capture, front camera:', isFrontCamera, 'facing mode:', currentFacingMode);
            
            // Test voice immediately if front camera
            if (isFrontCamera) {
                console.log('🗣️ Testing voice before countdown...');
                // Wait a moment for speech to be fully enabled
                setTimeout(() => {
                    speakCountdown('Are you ready', true);
                }, 200);
            }
            
            // Enter fullscreen mode
            enterFullscreenMode('static');
            
            // Disable and hide floating button during countdown
            const bottomButton = document.getElementById('staticCaptureBtn');
            const floatingButton = document.getElementById('floatingStaticBtn');
            if (bottomButton) bottomButton.disabled = true;
            if (floatingButton) {
                floatingButton.disabled = true;
                hideFloatingButton('static');
            }
            
            // Show countdown overlay
            const screenElement = document.getElementById('static-analysis');
            
            // Create enhanced countdown overlay with dramatic animations
            const overlay = document.createElement('div');
            overlay.id = 'staticCountdownOverlay';
            overlay.className = 'fixed inset-0 bg-transparent flex items-center justify-center';
            overlay.style.zIndex = '10001';
            overlay.innerHTML = `
                <!-- Minimal Top-Right Counter -->
                <div class="absolute top-4 right-4 text-center text-white bg-black bg-opacity-75 px-3 py-2 rounded-lg shadow-lg border border-white border-opacity-20 backdrop-blur-sm" style="min-width: 80px;">
                    <div class="text-2xl font-bold mb-1 text-white transition-all duration-200 ease-out" id="staticCountdownNumber" style="text-shadow: 0 0 10px rgba(255,255,255,0.6);">10</div>
                    <div class="text-xs opacity-75 mb-1" id="countdownMessage">Are you ready?</div>
                    <div class="w-8 h-0.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mx-auto" id="countdownProgress"></div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            let currentCount = 10; // Changed from 5 to 10
            const countdownNumber = document.getElementById('staticCountdownNumber');
            
            const countdownInterval = setInterval(() => {
                currentCount--;
                
                if (currentCount > 0) {
                    // Enhanced visual countdown with dramatic effects
                    countdownNumber.textContent = currentCount;
                    
                    // Dynamic color transitions based on countdown
                    let color, shadowColor, pulseIntensity;
                    if (currentCount > 7) {
                        color = '#10B981'; // Green
                        shadowColor = 'rgba(16,185,129,0.8)';
                        pulseIntensity = '0 0 40px rgba(16,185,129,0.8)';
                    } else if (currentCount > 3) {
                        color = '#F59E0B'; // Amber
                        shadowColor = 'rgba(245,158,11,0.8)';
                        pulseIntensity = '0 0 50px rgba(245,158,11,0.8)';
                    } else {
                        color = '#EF4444'; // Red
                        shadowColor = 'rgba(239,68,68,0.8)';
                        pulseIntensity = '0 0 60px rgba(239,68,68,0.9)';
                    }
                    
                    // Apply dynamic styling - minimal for small display
                    countdownNumber.style.color = color;
                    countdownNumber.style.textShadow = `0 0 10px ${shadowColor}`;
                    countdownNumber.style.transform = 'scale(1.05)';
                    
                    // Add very subtle animation
                    setTimeout(() => {
                        countdownNumber.style.transform = 'scale(1.0)';
                    }, 100);
                    
                    // Update progress bar
                    const progressBar = document.getElementById('countdownProgress');
                    if (progressBar) {
                        const progressWidth = ((10 - currentCount) / 10) * 100;
                        progressBar.style.width = `${progressWidth}%`;
                        progressBar.style.background = color;
                    }
                    
                    // Update message
                    const messageElement = document.getElementById('countdownMessage');
                    if (messageElement && currentCount <= 5) {
                        messageElement.textContent = 'Get ready!';
                    }
                    
                    // No screen flash effect for minimal display
                    
                    // Multi-modal feedback: Voice + Audio + Haptic
                    
                    // Voice countdown only for front camera with slight delay
                    if (isFrontCamera) {
                        setTimeout(() => {
                            speakCountdown(currentCount.toString(), true);
                        }, 100);
                    }
                    
                    // Audio beep feedback (reliable alternative to speech)
                    setTimeout(() => {
                        if (currentCount <= 3) {
                            playCountdownBeep(1000, 150, true); // Higher frequency, warning beep
                        } else if (currentCount <= 5) {
                            playCountdownBeep(800, 200, false); // Medium frequency
                        } else {
                            playCountdownBeep(600, 250, false); // Lower frequency
                        }
                    }, 50);
                    
                    // Enhanced haptic feedback pattern
                    if (navigator.vibrate) {
                        if (currentCount <= 3) {
                            navigator.vibrate([100, 50, 100]); // Urgent pattern
                        } else {
                            navigator.vibrate(80); // Regular pulse
                        }
                    }
                } else {
                    // "GO!" final sequence - minimal version
                    countdownNumber.textContent = 'GO!';
                    countdownNumber.style.transform = 'scale(1.1)';
                    countdownNumber.style.color = '#10B981'; // Bright green
                    countdownNumber.style.textShadow = '0 0 10px rgba(16,185,129,1)';
                    
                    // Full progress bar
                    const progressBar = document.getElementById('countdownProgress');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                        progressBar.style.background = '#10B981';
                    }
                    
                    // Update message
                    const messageElement = document.getElementById('countdownMessage');
                    if (messageElement) {
                        messageElement.textContent = 'Capture!';
                    }
                    
                    // Final "OK!" multi-modal feedback
                    
                    // Voice "GO!" only for front camera
                    if (isFrontCamera) {
                        setTimeout(() => {
                            speakCountdown('GO!', true);
                        }, 100);
                    }
                    
                    // Success audio chime (reliable for all users)
                    setTimeout(() => {
                        playSuccessChime();
                    }, 200);
                    
                    // Strong haptic feedback for OK
                    if (navigator.vibrate) {
                        navigator.vibrate([100, 50, 100]);
                    }
                    
                    setTimeout(() => {
                        overlay.remove();
                        
                        // Add camera flash effect
                        const flash = document.createElement('div');
                        flash.className = 'fixed inset-0 bg-white';
                        flash.style.zIndex = '10001';
                        flash.style.opacity = '0';
                        document.body.appendChild(flash);
                        
                        // Flash animation
                        flash.style.transition = 'opacity 0.1s';
                        flash.style.opacity = '0.6';
                        
                        setTimeout(() => {
                            flash.style.opacity = '0';
                            setTimeout(() => {
                                flash.remove();
                                // Exit fullscreen after capture
                                exitFullscreenMode('static');
                                
                                // Re-enable buttons
                                if (bottomButton) bottomButton.disabled = false;
                                if (floatingButton) floatingButton.disabled = false;
                            }, 100);
                        }, 100);
                        
                        // Start actual analysis
                        startStaticCapture();
                    }, 1000);
                    
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        async function startStaticCapture() {
            // Start countdown process
            const button = event.target;
            button.disabled = true;
            
            // Show countdown overlay
            showCountdownOverlay('static', 5, async () => {
                // Start actual analysis after countdown
                isAnalyzing = true;
                button.textContent = 'Analyzing... / 分析中...';
                
                // Add camera flash effect for capture moment
                showCameraFlash('static');
                
                // Capture pose data for 3 seconds
                let analysisResults = [];
                const captureInterval = setInterval(() => {
                    if (currentPoseResults && currentPoseResults.poseLandmarks) {
                        const analysis = performPoseAnalysis(currentPoseResults.poseLandmarks);
                        if (analysis) {
                            analysisResults.push(analysis);
                        }
                    }
                }, 100); // Capture every 100ms
                
                setTimeout(async () => {
                    clearInterval(captureInterval);
                    isAnalyzing = false;
                    
                    // Process captured analysis data
                    let analysisData;
                    if (analysisResults.length > 0) {
                        analysisData = processStaticAnalysisResults(analysisResults);
                    } else {
                        // Fallback to generated data if no pose detected
                        analysisData = generateAnalysisData('static');
                    }
                    
                    if (currentUser) {
                        const resultData = {
                            id: generateUUID(),
                            user_id: currentUser.id,
                            analysis_type: 'static',
                            sport: currentUser.primary_sport,
                            analysis_date: new Date().toISOString(),
                            ...analysisData
                        };
                        
                        // ローカルに保存
                        saveAnalysisResultLocal(resultData);
                    }
                    
                    updateResultsDisplay(analysisData);
                    
                    // 分析完了の振動フィードバック
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 100, 200]);
                    }
                    
                    showResults();
                }, 3000);
            });
        }
        
        // Improved dynamic capture with movement detection
        async function startDynamicCaptureImproved() {
            // Enter fullscreen mode
            enterFullscreenMode('dynamic');
            
            // Disable and hide floating button during recording
            const bottomButton = document.getElementById('dynamicCaptureBtn');
            const floatingButton = document.getElementById('floatingDynamicBtn');
            if (bottomButton) {
                bottomButton.disabled = true;
                bottomButton.textContent = 'Ready to move... / 動作準備中...';
            }
            if (floatingButton) {
                floatingButton.disabled = true;
                floatingButton.textContent = 'Ready to move... / 動作準備中...';
                hideFloatingButton('dynamic');
            }
            
            // Wait for movement to start
            isWaitingForMovement = true;
            movementAnalysisData = [];
            isAnalyzing = true;
            
            // Show waiting indicator
            const screenElement = document.getElementById('dynamic-analysis');
            const waitingOverlay = document.createElement('div');
            waitingOverlay.id = 'dynamicWaitingOverlay';
            waitingOverlay.className = 'fixed top-20 left-4 right-4 text-center';
            waitingOverlay.style.zIndex = '10001';
            waitingOverlay.innerHTML = `
                <div class="bg-blue-600 bg-opacity-80 text-white px-4 py-3 rounded-lg shadow-lg border border-white border-opacity-20">
                    <div class="text-lg font-medium mb-1">🤸‍♂️ Ready to start!</div>
                    <div class="text-sm">Start moving to begin recording</div>
                    <div class="text-xs opacity-75">動き始めると録画が開始されます</div>
                </div>
            `;
            document.body.appendChild(waitingOverlay);
            
            let previousLandmarks = null;
            const checkMovementInterval = setInterval(() => {
                if (currentPoseResults && currentPoseResults.poseLandmarks) {
                    const landmarks = currentPoseResults.poseLandmarks;
                    
                    if (previousLandmarks) {
                        // Calculate movement intensity between frames
                        let totalMovement = 0;
                        const keyJoints = [11, 12, 23, 24, 25, 26]; // shoulders, hips, knees
                        
                        keyJoints.forEach(index => {
                            const current = landmarks[index];
                            const previous = previousLandmarks[index];
                            if (current && previous && current.visibility > 0.5) {
                                const movement = Math.abs(current.x - previous.x) + Math.abs(current.y - previous.y);
                                totalMovement += movement;
                            }
                        });
                        
                        const movementIntensity = totalMovement / keyJoints.length;
                        
                        // Detect significant movement (threshold can be adjusted)
                        if (movementIntensity > 0.01 && !movementStartTime) {
                            movementStartTime = Date.now();
                            isWaitingForMovement = false;
                            clearInterval(checkMovementInterval);
                            waitingOverlay.remove();
                            
                            // Voice announcement removed - only for static front camera
                            // Strong haptic feedback for movement start
                            if (navigator.vibrate) {
                                navigator.vibrate([200, 100, 200]);
                            }
                            
                            // Start 15-second recording timer
                            startRecordingTimer(screenElement, 15, () => {
                                // Recording complete
                                isAnalyzing = false;
                                
                                // Exit fullscreen mode
                                exitFullscreenMode('dynamic');
                                
                                // Re-enable buttons
                                if (bottomButton) {
                                    bottomButton.disabled = false;
                                    bottomButton.textContent = 'Start Auto Recording / 自動録画開始';
                                }
                                if (floatingButton) {
                                    floatingButton.disabled = false;
                                    floatingButton.textContent = 'Start Auto Recording / 自動録画開始';
                                }
                                
                                // Process movement analysis data
                                let analysisData;
                                if (movementAnalysisData.length > 0) {
                                    analysisData = processDynamicAnalysisResults(movementAnalysisData, currentSquatCount);
                                } else {
                                    analysisData = generateAnalysisData('dynamic');
                                }
                                
                                if (currentUser) {
                                    const resultData = {
                                        id: generateUUID(),
                                        user_id: currentUser.id,
                                        analysis_type: 'dynamic',
                                        sport: currentUser.primary_sport,
                                        analysis_date: new Date().toISOString(),
                                        ...analysisData
                                    };
                                    
                                    saveAnalysisResultLocal(resultData);
                                }
                                
                                updateResultsDisplay(analysisData);
                                
                                if (navigator.vibrate) {
                                    navigator.vibrate([200, 100, 200]);
                                }
                                
                                showResults();
                            });
                        }
                    }
                    
                    previousLandmarks = landmarks;
                }
            }, 100);
            
            // Timeout after 30 seconds if no movement detected
            setTimeout(() => {
                if (isWaitingForMovement) {
                    clearInterval(checkMovementInterval);
                    isWaitingForMovement = false;
                    movementStartTime = Date.now();
                    waitingOverlay.remove();
                    
                    // Voice announcement removed - only for static front camera
                    // Force start recording
                    startRecordingTimer(screenElement, 15, () => {
                        // Exit fullscreen mode after timeout completion
                        exitFullscreenMode('dynamic');
                        
                        // Re-enable buttons
                        if (bottomButton) {
                            bottomButton.disabled = false;
                            bottomButton.textContent = 'Start Auto Recording / 自動録画開始';
                        }
                        if (floatingButton) {
                            floatingButton.disabled = false;
                            floatingButton.textContent = 'Start Auto Recording / 自動録画開始';
                        }
                        
                        // Auto-complete logic same as above
                        startDynamicCapture();
                    });
                }
            }, 30000);
        }
        
        // Recording timer function
        function startRecordingTimer(screenElement, seconds, onComplete) {
            const timerOverlay = document.createElement('div');
            timerOverlay.id = 'dynamicTimerOverlay';
            timerOverlay.className = 'fixed top-16 left-4 right-4 text-center';
            timerOverlay.style.zIndex = '10001';
            timerOverlay.innerHTML = `
                <div class="bg-red-600 bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-lg border border-white border-opacity-20">
                    <div class="text-sm font-medium flex items-center justify-center">
                        <div class="w-2 h-2 bg-white rounded-full animate-pulse mr-2"></div>
                        REC
                    </div>
                    <div class="text-2xl font-bold" id="dynamicTimer">${seconds}</div>
                    <div class="text-xs opacity-75">Keep moving! / 動き続けてください！</div>
                </div>
            `;
            
            document.body.appendChild(timerOverlay);
            
            let currentTime = seconds;
            const timerElement = document.getElementById('dynamicTimer');
            
            // Start recording data collection
            const recordingInterval = setInterval(() => {
                if (currentPoseResults && currentPoseResults.poseLandmarks) {
                    const analysis = performPoseAnalysis(currentPoseResults.poseLandmarks);
                    const movement = detectMovement(currentPoseResults.poseLandmarks);
                    
                    if (analysis && movement) {
                        movementAnalysisData.push({
                            ...analysis,
                            movement: movement,
                            timestamp: Date.now()
                        });
                        
                        // Update squat count and phase
                        const squatDetection = detectSquat(currentPoseResults.poseLandmarks);
                        if (squatDetection.isSquat && squatDetection.phase !== lastSquatPhase) {
                            if (squatDetection.phase === 'bottom' && lastSquatPhase === 'down') {
                                // Squat completed
                            }
                            lastSquatPhase = squatDetection.phase;
                        }
                    }
                }
            }, 50);
            
            const timerInterval = setInterval(() => {
                currentTime--;
                
                if (currentTime > 0) {
                    timerElement.textContent = currentTime;
                    
                    // Change color in last 5 seconds
                    if (currentTime <= 5) {
                        timerElement.style.color = '#FCD34D'; // Yellow
                        timerElement.parentElement.classList.remove('bg-red-600');
                        timerElement.parentElement.classList.add('bg-yellow-600');
                        
                        // Voice countdown removed - only for static front camera
                        if (navigator.vibrate) {
                            navigator.vibrate(30);
                        }
                    }
                    
                    // Pulsing effect in last 3 seconds
                    if (currentTime <= 3) {
                        timerElement.style.transform = 'scale(1.2)';
                        setTimeout(() => {
                            timerElement.style.transform = 'scale(1)';
                        }, 300);
                    }
                } else {
                    // Recording complete
                    clearInterval(timerInterval);
                    clearInterval(recordingInterval);
                    timerOverlay.remove();
                    
                    // Voice completion announcement removed - only for static front camera
                    // Strong completion haptic
                    if (navigator.vibrate) {
                        navigator.vibrate([300, 100, 300]);
                    }
                    
                    onComplete();
                }
            }, 1000);
        }
        
        async function startDynamicCapture() {
            // Start movement detection and recording
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Ready to move... / 動作準備中...';
            
            // Wait for movement to start
            await waitForMovementStart(() => {
                // Movement detected - start 15 second recording
                button.textContent = 'Recording... / 録画中...';
                showRecordingTimer('dynamic', 15, async () => {
                    isAnalyzing = false;
                    
                    // Process movement analysis data
                    let analysisData;
                    if (movementAnalysisData.length > 0) {
                        analysisData = processDynamicAnalysisResults(movementAnalysisData, currentSquatCount);
                    } else {
                        // Fallback to generated data
                        analysisData = generateAnalysisData('dynamic');
                    }
                    
                    if (currentUser) {
                        const resultData = {
                            id: generateUUID(),
                            user_id: currentUser.id,
                            analysis_type: 'dynamic',
                            sport: currentUser.primary_sport,
                            analysis_date: new Date().toISOString(),
                            ...analysisData
                        };
                        
                        // ローカルに保存
                        saveAnalysisResultLocal(resultData);
                    }
                    
                    updateResultsDisplay(analysisData);
                    
                    // 分析完了の振動フィードバック
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 100, 200]);
                    }
                    
                    showResults();
                });
            });
        }
        
        function generateAnalysisData(type) {
            const sport = currentUser ? currentUser.primary_sport : 'general';
            
            // Sport-specific analysis parameters
            const sportProfiles = {
                soccer: {
                    static: {
                        base: { overall_score: 82, hip_flexibility: 90, postural_stability: 75, dynamic_balance: 85 },
                        variance: 8,
                        focus: ['hip_flexibility', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 88, hip_flexibility: 85, postural_stability: 82, dynamic_balance: 92 },
                        variance: 6,
                        focus: ['dynamic_balance']
                    }
                },
                basketball: {
                    static: {
                        base: { overall_score: 78, hip_flexibility: 80, postural_stability: 85, dynamic_balance: 85 },
                        variance: 10,
                        focus: ['postural_stability', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 85, hip_flexibility: 82, postural_stability: 88, dynamic_balance: 90 },
                        variance: 7,
                        focus: ['postural_stability']
                    }
                },
                baseball: {
                    static: {
                        base: { overall_score: 83, hip_flexibility: 78, postural_stability: 88, dynamic_balance: 80 },
                        variance: 9,
                        focus: ['postural_stability']
                    },
                    dynamic: {
                        base: { overall_score: 80, hip_flexibility: 85, postural_stability: 85, dynamic_balance: 82 },
                        variance: 8,
                        focus: ['hip_flexibility']
                    }
                },
                tabletennis: {
                    static: {
                        base: { overall_score: 85, hip_flexibility: 82, postural_stability: 90, dynamic_balance: 88 },
                        variance: 7,
                        focus: ['postural_stability']
                    },
                    dynamic: {
                        base: { overall_score: 87, hip_flexibility: 80, postural_stability: 92, dynamic_balance: 90 },
                        variance: 5,
                        focus: ['postural_stability', 'dynamic_balance']
                    }
                },
                volleyball: {
                    static: {
                        base: { overall_score: 80, hip_flexibility: 85, postural_stability: 82, dynamic_balance: 88 },
                        variance: 8,
                        focus: ['hip_flexibility', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 86, hip_flexibility: 88, postural_stability: 85, dynamic_balance: 92 },
                        variance: 6,
                        focus: ['dynamic_balance']
                    }
                }
            };
            
            // Default profile if sport not found
            const profile = sportProfiles[sport] || sportProfiles.soccer;
            const typeProfile = profile[type];
            
            // Generate scores with sport-specific variance
            const scores = {};
            Object.keys(typeProfile.base).forEach(key => {
                const baseScore = typeProfile.base[key];
                const variance = typeProfile.variance;
                scores[key] = Math.max(0, Math.min(100, baseScore + (Math.random() - 0.5) * variance * 2));
                scores[key] = Math.round(scores[key]);
            });
            
            // Generate sport-specific recommendations
            const sportRecommendations = {
                soccer: [
                    "Enhance ball control balance drills / ボールコントロールバランスドリルの強化",
                    "Focus on single-leg stability for shooting / シュート時の片足安定性に集中",
                    "Improve hip flexor mobility for agility / 敏捷性向上のための股関節屈筋群の可動性改善",
                    "Strengthen core for better shooting accuracy / より良いシュート精度のための体幹強化"
                ],
                basketball: [
                    "Practice jump landing mechanics / ジャンプ着地メカニクスの練習",
                    "Improve ankle stability for court movements / コート動作のための足首安定性向上",
                    "Enhance lateral movement balance / 横方向動作バランスの強化",
                    "Strengthen posterior chain for jumping / ジャンプのための後面筋群強化"
                ],
                baseball: [
                    "Focus on rotational power development / 回転パワー開発に集中",
                    "Improve shoulder girdle stability / 肩甲帯安定性の向上",
                    "Enhance hip-shoulder separation / 腰と肩の分離動作の強化",
                    "Strengthen obliques for batting power / バッティングパワーのための腹斜筋強化"
                ],
                tabletennis: [
                    "Practice quick lateral movements / 素早い横方向動作の練習",
                    "Improve wrist and forearm stability / 手首・前腕の安定性向上",
                    "Enhance reaction time balance drills / 反応時間バランスドリルの強化",
                    "Focus on core stability for quick returns / 素早いリターンのための体幹安定性"
                ],
                volleyball: [
                    "Practice spike approach mechanics / スパイクアプローチメカニクスの練習",
                    "Improve shoulder flexibility for serves / サーブのための肩柔軟性向上",
                    "Enhance vertical jump stability / 垂直ジャンプ安定性の強化",
                    "Strengthen legs for better blocking / より良いブロックのための脚力強化"
                ]
            };
            
            const recommendations = sportRecommendations[sport] || sportRecommendations.soccer;
            
            return {
                ...scores,
                recommendations: recommendations.slice(0, 2 + Math.floor(Math.random() * 2))
            };
        }
        
        function updateResultsDisplay(analysisData) {
            // Update the results screen with actual data
            document.querySelector('#results .text-4xl').textContent = `${analysisData.overall_score}/100`;
            
            // Update individual scores
            document.getElementById('hip-score').textContent = `${analysisData.hip_flexibility}%`;
            document.getElementById('posture-score').textContent = `${analysisData.postural_stability}%`;
            document.getElementById('balance-score').textContent = `${analysisData.dynamic_balance}%`;
            
            // Create chart
            createAnalysisChart(analysisData);
        }
        
        function createAnalysisChart(data) {
            const ctx = document.getElementById('analysisChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.analysisChart instanceof Chart) {
                window.analysisChart.destroy();
            }
            
            window.analysisChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [
                        'Hip Flexibility\n股関節柔軟性',
                        'Postural Stability\n姿勢安定性',
                        'Dynamic Balance\n動的バランス',
                        'Overall Performance\n総合パフォーマンス'
                    ],
                    datasets: [{
                        label: 'Current Score',
                        data: [
                            data.hip_flexibility,
                            data.postural_stability,
                            data.dynamic_balance,
                            data.overall_score
                        ],
                        backgroundColor: 'rgba(30, 58, 138, 0.2)',
                        borderColor: 'rgba(30, 58, 138, 0.8)',
                        borderWidth: 2,
                        pointBackgroundColor: 'rgba(30, 58, 138, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(30, 58, 138, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            pointLabels: {
                                font: {
                                    size: 10
                                },
                                color: '#374151'
                            },
                            ticks: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        function shareResults() {
            if (navigator.share) {
                navigator.share({
                    title: 'AthleteCore Pro - 分析結果',
                    text: `私の姿勢分析スコア: ${document.querySelector('#results .text-4xl').textContent}`,
                    url: window.location.href
                }).catch(console.error);
            } else {
                alert('Results shared! / 結果を共有しました！');
            }
        }

        // PWA関連の関数
        function showInstallPrompt() {
            if (!isInstalled && deferredPrompt) {
                // インストールボタンを表示
                const installButton = document.createElement('button');
                installButton.textContent = 'アプリをインストール';
                installButton.className = 'fixed bottom-4 right-4 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg z-50';
                installButton.id = 'installButton';
                installButton.onclick = installApp;
                document.body.appendChild(installButton);
            }
        }

        function hideInstallPrompt() {
            const installButton = document.getElementById('installButton');
            if (installButton) {
                installButton.remove();
            }
        }

        async function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`PWAインストール結果: ${outcome}`);
                deferredPrompt = null;
                hideInstallPrompt();
            }
        }

        function showUpdateAvailable() {
            const updateNotification = document.createElement('div');
            updateNotification.innerHTML = `
                <div class="fixed top-4 left-4 right-4 bg-blue-600 text-white p-4 rounded-lg shadow-lg z-50">
                    <p class="text-sm mb-2">新しいバージョンが利用可能です</p>
                    <button onclick="updateApp()" class="bg-white text-blue-600 px-3 py-1 rounded text-sm">
                        更新
                    </button>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-white">
                        ×
                    </button>
                </div>
            `;
            document.body.appendChild(updateNotification);
        }

        function updateApp() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(registration => {
                    registration.update();
                    window.location.reload();
                });
            }
        }

        // オフライン/オンライン状態の監視
        function updateOnlineStatus() {
            const isOnline = navigator.onLine;
            const statusIndicator = document.getElementById('connectionStatus');
            
            if (!statusIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'connectionStatus';
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs';
                document.body.appendChild(indicator);
            }
            
            const indicator = document.getElementById('connectionStatus');
            
            if (isOnline) {
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs bg-green-500 text-white';
                indicator.textContent = 'オンライン';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            } else {
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs bg-red-500 text-white';
                indicator.textContent = 'オフライン - 一部機能が制限されます';
                indicator.style.display = 'block';
            }
        }

        // ページ読み込み時とオンライン状態変更時に実行
        window.addEventListener('load', updateOnlineStatus);
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // バッテリー状態の監視（対応ブラウザのみ）
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                function updateBatteryInfo() {
                    if (battery.level < 0.2 && !battery.charging) {
                        console.log('バッテリー残量が少なくなっています。省電力モードを検討してください。');
                    }
                }
                
                battery.addEventListener('levelchange', updateBatteryInfo);
                battery.addEventListener('chargingchange', updateBatteryInfo);
                updateBatteryInfo();
            });
        }
    </script>
    
    <!-- Floating Capture Buttons -->
    <button id="floatingStaticBtn" class="floating-capture-btn" onclick="startStaticCaptureImproved()">
        Start 10s Countdown / 10秒カウントダウン開始
    </button>
    <button id="floatingDynamicBtn" class="floating-capture-btn" onclick="startDynamicCaptureImproved()">
        Start Auto Recording / 自動録画開始
    </button>
</body>
</html>
