<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="AthleteCore Pro">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1E3A8A">
    <title>AthleteCore Pro - AIÂßøÂã¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOSÁî®„Ç¢„Ç§„Ç≥„É≥ -->
    <link rel="apple-touch-icon" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link rel="apple-touch-icon" sizes="152x152" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link rel="apple-touch-icon" sizes="180x180" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    
    <!-- „Çπ„Éó„É©„ÉÉ„Ç∑„É•„Çπ„ÇØ„É™„Éº„É≥Áî® -->
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="apple-touch-startup-image" href="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- MediaPipe Pose Detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Dior Sport Elegant Animations */
        @keyframes dior-fade-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes dior-slide-up {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes dior-geometric-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
            50% { transform: translateY(-10px) rotate(1deg); opacity: 0.5; }
        }
        
        @keyframes dior-line-draw {
            from { width: 0; opacity: 0; }
            to { width: 100%; opacity: 1; }
        }
        
        .dior-fade-in { animation: dior-fade-in 0.8s ease-out forwards; }
        .dior-slide-up { animation: dior-slide-up 0.6s ease-out forwards; }
        .dior-geometric-float { animation: dior-geometric-float 4s ease-in-out infinite; }
        .dior-line-draw { animation: dior-line-draw 1.2s ease-out forwards; }
        
        .phone-frame {
            width: 100vw;
            height: 100vh;
            background: #000;
            border-radius: 0;
            padding: 0;
            margin: 0;
            position: relative;
            box-shadow: none;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóË°®Á§∫ÊôÇ„ÅÆ„Åø„Éï„É¨„Éº„É†ÂäπÊûú */
        @media (min-width: 768px) {
            .phone-frame {
                width: 375px;
                height: 812px;
                border-radius: 40px;
                padding: 8px;
                margin: 0 auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            }
        }
        
        .phone-screen {
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 0;
            overflow: hidden;
            position: relative;
        }
        
        /* „Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóË°®Á§∫ÊôÇ„ÅÆ„Åø„Éï„É¨„Éº„É†ÂäπÊûú */
        @media (min-width: 768px) {
            .phone-screen {
                border-radius: 32px;
            }
        }
        
        .home-indicator {
            position: absolute;
            bottom: max(8px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 134px;
            height: 5px;
            background: #000;
            border-radius: 3px;
            opacity: 0.4;
        }
        
        /* „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥„Åß„ÅØÈùûË°®Á§∫ */
        @media (max-width: 767px) {
            .home-indicator {
                display: none;
            }
        }
        
        .app-screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            overflow-y: auto;
        }
        
        .app-screen.active {
            display: flex;
            flex-direction: column;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-up {
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        
        .brand-color {
            color: #1E3A8A;
        }
        
        .brand-bg {
            background-color: #1E3A8A;
        }
        
        .accent-color {
            color: #F59E0B;
        }
        
        .accent-bg {
            background-color: #F59E0B;
        }
        
        /* Fullscreen Camera Mode */
        .fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
        }
        
        .hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        
        /* Floating Capture Button */
        .floating-capture-btn {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 80px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            padding: 16px 32px;
            background: #1E3A8A;
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 8px 25px rgba(30, 58, 138, 0.4);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        
        .floating-capture-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .floating-capture-btn:hover {
            background: #1D4ED8;
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 12px 30px rgba(30, 58, 138, 0.5);
        }
        
        .floating-capture-btn:active {
            transform: translateX(-50%) translateY(0px);
        }
        
        /* Mobile Adjustments for Floating Button */
        @media (max-width: 767px) {
            .floating-capture-btn {
                bottom: calc(env(safe-area-inset-bottom) + 100px);
                padding: 18px 36px;
                font-size: 18px;
            }
        }
        
        /* PWA & Mobile Optimizations */
        .installed {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* „Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅÆÊîπÂñÑ */
        button, .sport-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        button:active, .sport-btn:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }
        
        /* „Çπ„ÇØ„É≠„Éº„É´ÊîπÂñÑ */
        .app-screen {
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        /* „Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„ÅÆÊîπÂñÑ */
        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(30, 58, 138, 0.3);
        }
        
        /* „Ç´„É°„É©„Éì„É•„Éº„ÅÆÊîπÂñÑ */
        video {
            object-fit: cover;
            /* „Éü„É©„ÉºÂäπÊûú„ÅØÂÄãÂà•„Å´ÈÅ©Áî®„Åô„Çã„Çà„ÅÜ„Å´Â§âÊõ¥ */
        }
        
        /* „Éó„É´„ÉÑ„Éº„É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅÆÁÑ°ÂäπÂåñ */
        body {
            overscroll-behavior-y: contain;
        }
        
        /* Enhanced Countdown Animations */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }
        
        @keyframes countdownPulse {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.1);
                filter: brightness(1.3);
            }
            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }
        
        @keyframes progressGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(16,185,129,0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(16,185,129,0.8), 0 0 30px rgba(16,185,129,0.4);
            }
        }
        
        @keyframes flashEffect {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 0;
            }
        }
        
        /* Countdown Number Special Effects - Compact Version */
        #staticCountdownNumber {
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Arial Black', Arial, sans-serif;
            letter-spacing: -0.02em;
            line-height: 1;
        }
        
        #countdownProgress {
            transition: all 0.5s ease-out;
            animation: progressGlow 2s ease-in-out infinite;
        }
        
        /* „Éê„ÉÉ„ÉÜ„É™„ÉºÂäπÁéá„ÅÆ„Åü„ÇÅ„ÅÆGPU„Ç¢„ÇØ„Çª„É©„É¨„Éº„Ç∑„Éß„É≥ */
        .phone-frame, .app-screen, .fade-in, .slide-up {
            will-change: transform;
            transform: translateZ(0);
        }
        
        /* „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÂØæÂøú */
        @media (prefers-color-scheme: dark) {
            .phone-screen {
                background: #1f2937;
                color: #f9fafb;
            }
            
            .bg-white {
                background-color: #374151 !important;
                color: #f9fafb;
            }
            
            .bg-gray-50 {
                background-color: #111827 !important;
            }
            
            .text-gray-600 {
                color: #d1d5db !important;
            }
            
            .text-gray-500 {
                color: #9ca3af !important;
            }
        }
        
        /* „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥ÂÖ®Ëà¨„ÅÆÊúÄÈÅ©Âåñ */
        @media (max-width: 767px) {
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100vh;
            }
            
            .phone-frame {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                padding: 0;
                margin: 0;
                box-shadow: none;
                position: fixed;
                top: 0;
                left: 0;
            }
            
            .phone-screen {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }
            
            .app-screen {
                height: 100vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px));
                box-sizing: border-box;
            }
            
            /* „Çª„Éº„Éï„Ç®„É™„Ç¢ÂØæÂøú„ÅÆÂº∑Âåñ */
            .app-screen > div:first-child {
                padding-top: max(20px, env(safe-area-inset-top, 20px));
            }
            
            /* „Éú„Çø„É≥„Ç®„É™„Ç¢„ÅÆ„Éë„Éá„Ç£„É≥„Ç∞Á¢∫‰øù */
            .app-screen .px-6:last-child,
            .app-screen .px-8:last-child {
                padding-bottom: max(40px, env(safe-area-inset-bottom, 40px));
            }
        }
        
        /* Ê®™ÁîªÈù¢„Åß„ÅÆË™øÊï¥ */
        @media screen and (orientation: landscape) and (max-height: 500px) {
            .phone-frame {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                padding: 0;
                margin: 0;
            }
            
            .phone-screen {
                border-radius: 0;
            }
            
            .home-indicator {
                display: none;
            }
        }
        
        /* „Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅÆÊîπÂñÑ */
        @media (max-width: 767px) {
            button {
                min-height: 50px;
                padding: 16px 20px;
                font-size: 18px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            }
            
            input, select {
                min-height: 50px;
                font-size: 16px;
                padding: 12px 16px;
            }
            
            /* Get Started„Éú„Çø„É≥„ÅÆÁâπÂà•ÂØæÂøú */
            .welcome-button {
                min-height: 60px;
                padding: 20px 24px;
                font-size: 20px;
                margin: 20px 0;
                position: relative;
                z-index: 10;
                box-shadow: 0 4px 12px rgba(30, 58, 138, 0.3);
            }
            
            /* WelcomeÁîªÈù¢Â∞ÇÁî®„ÅÆ„É¨„Ç§„Ç¢„Ç¶„ÉàË™øÊï¥ */
            #welcome {
                display: flex !important;
                flex-direction: column !important;
                height: 100vh !important;
                overflow: hidden !important;
            }
            
            #welcome .flex-1 {
                display: flex !important;
                flex-direction: column !important;
                min-height: calc(100vh - max(100px, env(safe-area-inset-bottom, 100px))) !important;
                justify-content: space-between !important;
                padding-bottom: max(60px, env(safe-area-inset-bottom, 60px)) !important;
                overflow-y: auto !important;
            }
            
            /* Get Started„Éú„Çø„É≥„ÅÆ„Ç≥„É≥„ÉÜ„Éä‰øÆÊ≠£ */
            #welcome .text-center:last-child {
                margin-top: auto !important;
                padding-top: 20px !important;
                position: relative !important;
                z-index: 25 !important;
            }
            
            /* ÊíÆÂΩ±ÁîªÈù¢„ÅÆ‰øÆÊ≠£ */
            #static-analysis .flex-shrink-0:last-child,
            #dynamic-analysis .flex-shrink-0:last-child {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
                background: white !important;
                position: sticky !important;
                bottom: 0 !important;
                z-index: 20 !important;
                border-top: 1px solid #e5e7eb !important;
                box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1) !important;
                margin-bottom: 0 !important;
            }
            
            /* ÊíÆÂΩ±ÁîªÈù¢„ÅÆ„Éú„Çø„É≥„ÇíÁ¢∫ÂÆü„Å´Ë°®Á§∫ */
            #static-analysis button,
            #dynamic-analysis button {
                min-height: 60px !important;
                position: relative !important;
                z-index: 30 !important;
                margin-bottom: 0 !important;
            }
            
            /* ÁôªÈå≤ÁîªÈù¢„ÅÆ‰øÆÊ≠£ */
            #registration {
                overflow-y: auto !important;
                min-height: 100vh !important;
            }
            
            #registration .flex-1 {
                min-height: calc(100vh - max(100px, env(safe-area-inset-bottom, 100px))) !important;
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            #registration .px-6:last-child,
            #registration .text-center:last-child {
                margin-bottom: max(40px, env(safe-area-inset-bottom, 40px)) !important;
                position: relative !important;
                z-index: 25 !important;
            }
            
            /* ÂÖ®ÁîªÈù¢ÂÖ±ÈÄö„ÅÆsafe-areaÂá¶ÁêÜ */
            .app-screen {
                padding-top: max(20px, env(safe-area-inset-top, 20px));
                padding-left: max(0px, env(safe-area-inset-left, 0px));
                padding-right: max(0px, env(safe-area-inset-right, 0px));
            }
            
            /* DashboardÁîªÈù¢„ÅÆÊúÄÈÅ©Âåñ */
            #dashboard .flex-1 {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            /* ResultsÁîªÈù¢„ÅÆÊúÄÈÅ©Âåñ */
            #results .flex-1 {
                padding-bottom: max(80px, env(safe-area-inset-bottom, 80px)) !important;
            }
            
            /* È™®Ê†ºÊèèÁîªCanvasÊúÄÈÅ©Âåñ - mix-blend-mode„ÇíÁÑ°ÂäπÂåñ */
            #staticPoseCanvas, #dynamicPoseCanvas {
                /* mix-blend-mode: screen; /* ‰∏ÄÊôÇÁöÑ„Å´ÁÑ°ÂäπÂåñ */
                pointer-events: none;
                z-index: 15;
                opacity: 1 !important;
                display: block !important;
                visibility: visible !important;
            }
            
            /* „Çπ„ÇØ„ÉØ„ÉÉ„Éà„Ç´„Ç¶„É≥„Çø„Éº„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ */
            #squatCount {
                transition: transform 0.2s ease-in-out;
            }
            
            /* „Éù„Éº„Ç∫Ê§úÂá∫„Çπ„ÉÜ„Éº„Çø„Çπ */
            #staticPoseStatus, #dynamicPoseStatus {
                backdrop-filter: blur(5px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            /* „Ç´„É°„É©Âàá„ÇäÊõø„Åà„Éú„Çø„É≥ */
            #staticCameraSwitch, #dynamicCameraSwitch {
                transition: transform 0.3s ease-in-out, background-color 0.2s;
                backdrop-filter: blur(10px);
            }
            
            #staticCameraSwitch:hover, #dynamicCameraSwitch:hover {
                background-color: rgba(0, 0, 0, 0.9);
                transform: scale(1.1);
            }
            
            #staticCameraSwitch:active, #dynamicCameraSwitch:active {
                transform: scale(0.95);
            }
            
            /* „Ç´„É°„É©„É©„Éô„É´ */
            #staticCameraLabel, #dynamicCameraLabel {
                backdrop-filter: blur(5px);
                transition: background-color 0.3s ease;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen m-0 p-0 overflow-hidden">
    
    <div class="phone-frame">
        <div class="phone-screen">
            <div class="home-indicator"></div>
            
            <!-- Splash Screen -->
            <div id="splash" class="app-screen active bg-white items-center justify-center">
                <div class="text-center px-8">
                    <img src="https://cdn1.genspark.ai/user-upload-image/gpt_image_generated/1d48ae2f-e2df-4a7c-a800-832043efb262_wm" 
                         alt="AthleteCore Pro Icon" class="w-24 h-24 mx-auto mb-8 rounded-2xl shadow-lg">
                    <h1 class="text-2xl font-bold brand-color mb-2">AthleteCore Pro</h1>
                    <p class="text-sm text-gray-600 mb-4">AIÂßøÂã¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†</p>
                    <div class="w-8 h-1 brand-bg mx-auto rounded-full mb-8"></div>
                    
                    <!-- PWAÂØæÂøúÁä∂Ê≥Å„ÅÆË°®Á§∫ -->
                    <div class="text-xs text-gray-500 space-y-1">
                        <div id="pwaStatus" class="flex items-center justify-center space-x-2">
                            <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                            <span>Web„Ç¢„Éó„É™„Å®„Åó„Å¶Âãï‰Ωú‰∏≠</span>
                        </div>
                        <div class="text-xs text-gray-400">„Ç™„Éï„É©„Ç§„É≥ÂØæÂøú„Éª„Ç§„É≥„Çπ„Éà„Éº„É´ÂèØËÉΩ</div>
                    </div>
                </div>
            </div>
            
            <!-- Athlete Welcome Screen - Dior Sport Style -->
            <div id="athlete-welcome" class="app-screen bg-gradient-to-b from-black via-gray-900 to-black">
                <div class="h-screen flex flex-col relative overflow-hidden">
                    <!-- Elegant Geometric Background Elements -->
                    <div class="absolute inset-0">
                        <!-- Luxury geometric patterns with elegant animation -->
                        <div class="absolute top-16 left-8 w-32 h-32 border border-gray-300 border-opacity-10 rotate-45 opacity-30 dior-geometric-float" style="animation-delay: 0s;"></div>
                        <div class="absolute top-32 right-12 w-24 h-24 border border-white border-opacity-15 rotate-12 opacity-40 dior-geometric-float" style="animation-delay: 1.5s;"></div>
                        <div class="absolute bottom-40 left-16 w-40 h-40 border border-gray-400 border-opacity-8 -rotate-12 opacity-25 dior-geometric-float" style="animation-delay: 3s;"></div>
                        
                        <!-- Subtle silver accents with draw animation -->
                        <div class="absolute top-1/3 right-6 h-32 bg-gradient-to-b from-transparent via-gray-300 to-transparent opacity-20 dior-line-draw" style="animation-delay: 0.5s;"></div>
                        <div class="absolute bottom-1/3 left-6 h-24 bg-gradient-to-b from-transparent via-white to-transparent opacity-15 dior-line-draw" style="animation-delay: 2s;"></div>
                    </div>
                    
                    <!-- Dior Sport Brand Bar -->
                    <div class="flex-none pt-12 pb-4 px-8 dior-fade-in" style="animation-delay: 0.2s;">
                        <div class="text-center">
                            <div class="h-0.5 bg-gradient-to-r from-transparent via-gray-300 to-transparent mx-auto mb-3 dior-line-draw" style="animation-delay: 0.8s;"></div>
                            <p class="text-gray-400 text-xs font-light tracking-widest uppercase">AthleteCore Pro</p>
                        </div>
                    </div>
                    
                    <!-- Main Content Container -->
                    <div class="flex-1 flex flex-col justify-center items-center px-8 text-center relative z-10">
                        <!-- Luxury Main Message -->
                        <div class="mb-12 dior-slide-up" style="animation-delay: 0.4s;">
                            <h1 class="text-4xl md:text-5xl font-thin mb-6 leading-tight text-white tracking-wide">
                                √âLITE
                                <span class="block font-light text-gray-300 text-3xl md:text-4xl mt-2 dior-fade-in" style="animation-delay: 0.8s;">PERFORMANCE</span>
                            </h1>
                            <div class="h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mx-auto mb-6 dior-line-draw" style="animation-delay: 1.2s;"></div>
                            <p class="text-lg font-light text-gray-300 mb-2 tracking-wide dior-fade-in" style="animation-delay: 1.4s;">
                                Precision in Motion
                            </p>
                            <p class="text-sm text-gray-400 font-light dior-fade-in" style="animation-delay: 1.6s;">
                                Á©∂Ê•µ„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
                            </p>
                        </div>
                        
                        <!-- Minimalist Stats -->
                        <div class="bg-black bg-opacity-40 backdrop-filter backdrop-blur-sm border border-gray-400 border-opacity-20 rounded-sm p-8 mb-12 shadow-2xl dior-slide-up" style="animation-delay: 1.8s;">
                            <div class="grid grid-cols-3 gap-8 w-full max-w-sm">
                                <div class="text-center border-r border-gray-400 border-opacity-20 pr-4 dior-fade-in" style="animation-delay: 2s;">
                                    <div class="text-2xl font-thin text-white mb-1">98</div>
                                    <div class="text-xs text-gray-400 font-light tracking-wide uppercase">Precision</div>
                                </div>
                                <div class="text-center border-r border-gray-400 border-opacity-20 pr-4 dior-fade-in" style="animation-delay: 2.2s;">
                                    <div class="text-2xl font-thin text-white mb-1">‚àû</div>
                                    <div class="text-xs text-gray-400 font-light tracking-wide uppercase">Real-time</div>
                                </div>
                                <div class="text-center dior-fade-in" style="animation-delay: 2.4s;">
                                    <div class="text-2xl font-thin text-white mb-1">AI</div>
                                    <div class="text-xs text-gray-400 font-light tracking-wide uppercase">Powered</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Elegant Call to Action -->
                        <div class="space-y-6 w-full max-w-xs dior-slide-up" style="animation-delay: 2.6s;">
                            <button onclick="showWelcome();" 
                                    class="w-full bg-white text-black font-light py-4 px-8 rounded-none text-sm tracking-widest uppercase transition-all duration-500 hover:bg-gray-100 border-2 border-white shadow-lg transform hover:scale-105 hover:shadow-2xl">
                                Begin Analysis
                            </button>
                            <div class="text-center dior-fade-in" style="animation-delay: 2.8s;">
                                <p class="text-xs text-gray-500 font-light">
                                    Touch to commence / ÈñãÂßã
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Luxury Bottom Accent -->
                    <div class="flex-none px-8 pb-8 dior-fade-in" style="animation-delay: 3s;">
                        <div class="w-full h-px bg-gradient-to-r from-transparent via-gray-400 to-transparent opacity-30 dior-line-draw" style="animation-delay: 3.2s;"></div>
                        <div class="text-center mt-4 dior-fade-in" style="animation-delay: 3.4s;">
                            <p class="text-xs text-gray-500 font-light tracking-widest">EXCELLENCE ¬∑ INNOVATION ¬∑ PRECISION</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Welcome Screen - Dior Sport Luxury -->
            <div id="welcome" class="app-screen bg-gradient-to-b from-gray-50 to-white">
                <div class="h-screen flex flex-col px-8 py-4">
                    <!-- Elegant Header -->
                    <div class="flex-none text-center pt-12 pb-8">
                        <div class="mb-6 dior-fade-in" style="animation-delay: 0.2s;">
                            <div class="h-px bg-gray-300 mx-auto mb-4 dior-line-draw" style="animation-delay: 0.5s;"></div>
                            <h1 class="text-3xl font-thin text-black mb-2 tracking-wide dior-slide-up" style="animation-delay: 0.7s;">
                                ATHLETECORE PRO
                            </h1>
                            <div class="h-px bg-gray-400 mx-auto dior-line-draw" style="animation-delay: 0.9s;"></div>
                        </div>
                        <div class="space-y-3 dior-fade-in" style="animation-delay: 1.1s;">
                            <p class="text-gray-600 text-base font-light tracking-wide">
                                Advanced Performance Analysis
                            </p>
                            <p class="text-gray-500 text-sm font-light">
                                Ê¨°‰∏ñ‰ª£„Ç¢„Çπ„É™„Éº„Éà„ÅÆ„Åü„ÇÅ„ÅÆAIÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†
                            </p>
                        </div>
                    </div>
                    
                    <!-- Minimalist Features -->
                    <div class="flex-1 flex flex-col justify-center space-y-12 py-8">
                        <div class="text-center dior-fade-in" style="animation-delay: 1.3s;">
                            <div class="w-px h-16 bg-gradient-to-b from-transparent via-gray-300 to-transparent mx-auto mb-4 dior-line-draw" style="animation-delay: 1.5s;"></div>
                            <p class="text-gray-700 text-sm font-light tracking-wide uppercase">Precision Movement Analysis</p>
                        </div>
                        <div class="text-center dior-fade-in" style="animation-delay: 1.6s;">
                            <div class="w-px h-16 bg-gradient-to-b from-transparent via-gray-300 to-transparent mx-auto mb-4 dior-line-draw" style="animation-delay: 1.8s;"></div>
                            <p class="text-gray-700 text-sm font-light tracking-wide uppercase">Real-time AI Detection</p>
                        </div>
                        <div class="text-center dior-fade-in" style="animation-delay: 1.9s;">
                            <div class="w-px h-16 bg-gradient-to-b from-transparent via-gray-300 to-transparent mx-auto mb-4 dior-line-draw" style="animation-delay: 2.1s;"></div>
                            <p class="text-gray-700 text-sm font-light tracking-wide uppercase">Professional Insights</p>
                        </div>
                    </div>
                    
                    <!-- Luxury CTA -->
                    <div class="flex-none pb-12 dior-slide-up" style="animation-delay: 2.3s;">
                        <div class="space-y-4">
                            <button onclick="console.log('Get Started clicked!'); showRegistration();" 
                                    class="w-full bg-black text-white font-light py-4 px-8 rounded-none text-sm tracking-widest uppercase transition-all duration-300 hover:bg-gray-800 border border-black transform hover:scale-105">
                                Continue
                            </button>
                            <div class="text-center dior-fade-in" style="animation-delay: 2.5s;">
                                <p class="text-xs text-gray-400 font-light tracking-wide">Begin your elite journey</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Registration Screen - Dior Sport Luxury -->
            <div id="registration" class="app-screen bg-gradient-to-b from-gray-50 to-white">
                <div class="flex-1 overflow-y-auto">
                    <div class="px-8 py-12">
                        <div class="text-center mb-12">
                            <div class="w-12 h-px bg-gray-300 mx-auto mb-4"></div>
                            <h2 class="text-2xl font-thin text-black mb-3 tracking-wide uppercase">Elite Profile</h2>
                            <div class="w-6 h-px bg-gray-400 mx-auto mb-3"></div>
                            <p class="text-gray-500 text-sm font-light">„Éó„É≠„Éï„Ç£„Éº„É´Ë®≠ÂÆö</p>
                        </div>
                        
                        <form id="profileForm" class="space-y-8">
                            <div>
                                <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Name / ÂêçÂâç</label>
                                <input id="name" type="text" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                            </div>
                            
                            <div class="grid grid-cols-2 gap-8">
                                <div>
                                    <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Age / Âπ¥ÈΩ¢</label>
                                    <input id="age" type="number" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                                </div>
                                <div>
                                    <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Height (cm)</label>
                                    <input id="height" type="number" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                                </div>
                            </div>
                            
                            <div>
                                <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Weight (kg)</label>
                                <input id="weight" type="number" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                            </div>
                            
                            <div>
                                <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Primary Sport / Á´∂ÊäÄ</label>
                                <select id="primarySport" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                                    <option value="">Select Sport</option>
                                    <option value="soccer">Soccer / „Çµ„ÉÉ„Ç´„Éº</option>
                                    <option value="basketball">Basketball / „Éê„Çπ„Ç±„ÉÉ„Éà„Éú„Éº„É´</option>
                                    <option value="baseball">Baseball / ÈáéÁêÉ</option>
                                    <option value="tabletennis">Table Tennis / ÂçìÁêÉ</option>
                                    <option value="volleyball">Volleyball / „Éê„É¨„Éº„Éú„Éº„É´</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-xs font-light text-gray-500 mb-3 tracking-wide uppercase">Experience Level</label>
                                <select id="experienceLevel" required class="w-full px-0 py-3 border-0 border-b border-gray-300 bg-transparent focus:ring-0 focus:border-black text-base font-light">
                                    <option value="">Select Level</option>
                                    <option value="beginner">Beginner / ÂàùÂøÉËÄÖ</option>
                                    <option value="intermediate">Intermediate / ‰∏≠Á¥öËÄÖ</option>
                                    <option value="advanced">Advanced / ‰∏äÁ¥öËÄÖ</option>
                                    <option value="professional">Professional / „Éó„É≠</option>
                                </select>
                            </div>
                            
                            <div class="pt-8">
                                <button type="button" onclick="handleRegistration()" 
                                        class="w-full bg-black text-white font-light py-4 px-8 rounded-none text-sm tracking-widest uppercase transition-all duration-300 hover:bg-gray-800">
                                    Complete Profile
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
            
            <!-- Dashboard Screen - Dior Sport Luxury -->
            <div id="dashboard" class="app-screen bg-gradient-to-b from-gray-50 to-white">
                <div class="flex-1 overflow-y-auto">
                    <!-- Elegant Header -->
                    <div class="bg-black bg-opacity-90 backdrop-filter backdrop-blur-md px-8 py-6">
                        <div class="flex justify-between items-center dior-fade-in">
                            <div>
                                <div class="w-12 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mb-2"></div>
                                <h1 class="text-lg font-thin text-white tracking-widest uppercase">Performance Center</h1>
                                <div class="w-6 h-px bg-gray-400 mt-1"></div>
                            </div>
                            <div class="w-10 h-10 border border-gray-400 border-opacity-30 rounded-none bg-black bg-opacity-20"></div>
                        </div>
                    </div>
                    
                    <!-- Minimalist Stats -->
                    <div class="px-8 py-8">
                        <div class="grid grid-cols-3 gap-6 mb-12 dior-slide-up" style="animation-delay: 0.2s;">
                            <div class="text-center border-r border-gray-300 border-opacity-30 pr-4">
                                <div class="text-3xl font-thin text-black mb-1">92</div>
                                <div class="text-xs text-gray-500 font-light tracking-wide uppercase">Posture</div>
                            </div>
                            <div class="text-center border-r border-gray-300 border-opacity-30 pr-4">
                                <div class="text-3xl font-thin text-black mb-1">A+</div>
                                <div class="text-xs text-gray-500 font-light tracking-wide uppercase">Balance</div>
                            </div>
                            <div class="text-center">
                                <div class="text-3xl font-thin text-black mb-1">Low</div>
                                <div class="text-xs text-gray-500 font-light tracking-wide uppercase">Risk</div>
                            </div>
                        </div>
                        
                        <!-- Sport Selection -->
                        <div class="mb-12 dior-fade-in" style="animation-delay: 0.4s;">
                            <div class="text-center mb-6">
                                <h3 class="text-base font-light text-black tracking-wide uppercase mb-2">Sport Analysis</h3>
                                <div class="w-16 h-px bg-gray-300 mx-auto"></div>
                            </div>
                            <div class="bg-black bg-opacity-5 border border-gray-200 border-opacity-50 rounded-none p-2">
                                <div class="grid grid-cols-5 gap-1">
                                    <button onclick="selectSport('soccer')" class="sport-btn text-xs py-3 px-2 rounded-none bg-black text-white font-light uppercase tracking-wide">Soccer</button>
                                    <button onclick="selectSport('basketball')" class="sport-btn text-xs py-3 px-2 rounded-none text-gray-600 font-light uppercase tracking-wide hover:bg-gray-100">Basketball</button>
                                    <button onclick="selectSport('baseball')" class="sport-btn text-xs py-3 px-2 rounded-none text-gray-600 font-light uppercase tracking-wide hover:bg-gray-100">Baseball</button>
                                    <button onclick="selectSport('tabletennis')" class="sport-btn text-xs py-3 px-2 rounded-none text-gray-600 font-light uppercase tracking-wide hover:bg-gray-100">Tennis</button>
                                    <button onclick="selectSport('volleyball')" class="sport-btn text-xs py-3 px-2 rounded-none text-gray-600 font-light uppercase tracking-wide hover:bg-gray-100">Volleyball</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Analysis Options -->
                        <div class="space-y-6 dior-slide-up" style="animation-delay: 0.6s;">
                            <button onclick="showStaticAnalysis()" class="w-full border border-gray-300 border-opacity-50 rounded-none p-6 text-left flex justify-between items-center bg-white bg-opacity-60 backdrop-filter backdrop-blur-sm hover:bg-opacity-80 transition-all duration-300">
                                <div>
                                    <div class="text-sm font-light text-black tracking-wide uppercase">Static Analysis</div>
                                    <div class="text-xs text-gray-500 font-light mt-1">ÈùôÁöÑÂßøÂã¢ÂàÜÊûê</div>
                                </div>
                                <div class="text-gray-400 font-thin">‚Üí</div>
                            </button>
                            
                            <button onclick="showDynamicAnalysis()" class="w-full border border-gray-300 border-opacity-50 rounded-none p-6 text-left flex justify-between items-center bg-white bg-opacity-60 backdrop-filter backdrop-blur-sm hover:bg-opacity-80 transition-all duration-300">
                                <div>
                                    <div class="text-sm font-light text-black tracking-wide uppercase">Dynamic Analysis</div>
                                    <div class="text-xs text-gray-500 font-light mt-1">ÂãïÁöÑÂãï‰ΩúÂàÜÊûê</div>
                                </div>
                                <div class="text-gray-400 font-thin">‚Üí</div>
                            </button>
                            
                            <button onclick="showSportSpecific()" class="w-full border border-gray-300 border-opacity-50 rounded-none p-6 text-left flex justify-between items-center bg-white bg-opacity-60 backdrop-filter backdrop-blur-sm hover:bg-opacity-80 transition-all duration-300">
                                <div>
                                    <div class="text-sm font-light text-black tracking-wide uppercase">Sport-Specific</div>
                                    <div class="text-xs text-gray-500 font-light mt-1">Á´∂ÊäÄÁâπÂåñÂàÜÊûê</div>
                                </div>
                                <div class="text-gray-400 font-thin">‚Üí</div>
                            </button>
                        </div>
                        
                        <!-- Analysis History -->
                        <div class="mt-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Recent Analysis / ÊúÄËøë„ÅÆÂàÜÊûê</h3>
                            <div id="analysisHistory" class="space-y-2">
                                <p class="text-gray-500 text-sm text-center py-4">No analysis yet / „Åæ„Å†ÂàÜÊûê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Static Analysis Screen - Dior Sport -->
            <div id="static-analysis" class="app-screen bg-black">
                <div class="flex-1 flex flex-col min-h-screen">
                    <!-- Elegant Header -->
                    <div id="staticHeader" class="flex-shrink-0 px-8 py-6 bg-black bg-opacity-90 backdrop-filter backdrop-blur-md transition-all duration-300">
                        <div class="flex items-center dior-fade-in">
                            <button onclick="showDashboard()" class="mr-6 text-white hover:text-gray-300 transition-colors duration-300 font-thin text-lg">‚Üê</button>
                            <div>
                                <div class="w-8 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mb-1"></div>
                                <h2 class="text-sm font-thin text-white tracking-widest uppercase">Static Analysis</h2>
                                <div class="w-4 h-px bg-gray-400 mt-1"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Camera View - Full Screen -->
                    <div id="staticCameraContainer" class="flex-1 bg-gray-900 relative transition-all duration-300" style="height: calc(100vh - 140px); min-height: calc(100vh - 140px);">
                        <!-- Full Screen Camera Container -->
                        <div class="w-full h-full relative absolute inset-0">
                            <video id="staticCameraFeed" class="w-full h-full object-cover" autoplay muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></video>
                            <canvas id="staticPoseCanvas" class="w-full h-full absolute top-0 left-0 z-30" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                            <div id="staticCameraPlaceholder" class="w-full h-full flex items-center justify-center bg-gray-800" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                                <div class="text-center text-white">
                                    <div class="text-6xl mb-4">üì∑</div>
                                    <p class="text-xl mb-2">Position yourself in the frame</p>
                                    <p class="text-sm opacity-75">„Éï„É¨„Éº„É†ÂÜÖ„Å´Á´ã„Å£„Å¶„Åè„Å†„Åï„ÅÑ</p>
                                </div>
                            </div>
                            
                            <!-- Elegant Pose Status - Top Overlay -->
                            <div id="staticPoseStatus" class="absolute top-6 left-6 bg-black bg-opacity-60 backdrop-filter backdrop-blur-md text-white text-xs px-4 py-2 rounded-none border border-gray-400 border-opacity-30 z-40">
                                <span id="staticPoseIndicator" class="w-2 h-2 bg-red-400 rounded-full inline-block mr-3"></span>
                                <span id="staticPoseText" class="font-light tracking-wide uppercase">Initializing</span>
                            </div>
                            
                            <!-- Elegant Controls - Top Right -->
                            <div class="absolute top-6 right-6 z-35 flex flex-col items-center space-y-3">
                                <!-- Reload Button -->
                                <button id="staticReloadBtn" onclick="smartReload()" class="bg-black bg-opacity-60 backdrop-filter backdrop-blur-md text-white p-2 rounded-none border border-gray-400 border-opacity-30 hover:bg-opacity-80 transition-all" title="Reload system">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                    </svg>
                                </button>
                                
                                <!-- Camera Switch Button -->
                                <button id="staticCameraSwitch" onclick="switchCamera('static')" class="bg-black bg-opacity-60 backdrop-filter backdrop-blur-md text-white p-2 rounded-none border border-gray-400 border-opacity-30 hover:bg-opacity-80 transition-all">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                    </svg>
                                </button>
                                
                                <!-- Camera Label -->
                                <div class="text-center">
                                    <span id="staticCameraLabel" class="text-xs text-white bg-black bg-opacity-40 backdrop-filter backdrop-blur-md px-2 py-1 rounded-none font-light tracking-wide">FRONT</span>
                                </div>
                            </div>
                            
                            <!-- Elegant Instructions - Bottom -->
                            <div class="absolute bottom-28 left-0 right-0 text-center text-white z-35">
                                <div class="bg-black bg-opacity-40 backdrop-filter backdrop-blur-md mx-6 py-4 px-6 rounded-none border border-gray-400 border-opacity-20">
                                    <p class="text-sm mb-2 font-light tracking-wide">Stand naturally with arms at your sides</p>
                                    <p class="text-xs opacity-75 mb-3 font-light">ËÖï„Çí‰Ωì„ÅÆÊ®™„Å´Ëá™ÁÑ∂„Å´Á´ã„Å£„Å¶„Åè„Å†„Åï„ÅÑ</p>
                                    <div class="w-8 h-px bg-gray-400 mx-auto opacity-50"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Elegant Controls - Sticky Bottom -->
                    <div id="staticControlsBottom" class="flex-shrink-0 px-8 py-6 bg-black bg-opacity-80 backdrop-filter backdrop-blur-md border-t border-gray-400 border-opacity-20 space-y-6 transition-all duration-300">
                        <div class="text-center">
                            <div class="w-12 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mx-auto mb-3"></div>
                            <p class="text-sm text-white mb-1 font-light tracking-wide">Ready for Analysis</p>
                            <p class="text-xs text-gray-300 font-light">ÂàÜÊûê„ÅÆÊ∫ñÂÇô„ÅåÂÆå‰∫Ü</p>
                        </div>
                        <button id="staticCaptureBtn" onclick="startStaticCaptureImproved()" class="bg-white text-black font-light py-4 px-8 rounded-none text-sm w-full tracking-widest uppercase transition-all duration-300 hover:bg-gray-100 border border-white shadow-lg">
                            <span id="staticCaptureText">Begin Capture</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Dynamic Analysis Screen - Dior Sport -->
            <div id="dynamic-analysis" class="app-screen bg-black">
                <div class="flex-1 flex flex-col min-h-screen">
                    <!-- Elegant Header -->
                    <div id="dynamicHeader" class="flex-shrink-0 px-8 py-6 bg-black bg-opacity-90 backdrop-filter backdrop-blur-md transition-all duration-300">
                        <div class="flex items-center dior-fade-in">
                            <button onclick="showDashboard()" class="mr-6 text-white hover:text-gray-300 transition-colors duration-300 font-thin text-lg">‚Üê</button>
                            <div>
                                <div class="w-8 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mb-1"></div>
                                <h2 class="text-sm font-thin text-white tracking-widest uppercase">Dynamic Analysis</h2>
                                <div class="w-4 h-px bg-gray-400 mt-1"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Camera View - Full Screen -->
                    <div id="dynamicCameraContainer" class="flex-1 bg-gray-900 relative transition-all duration-300" style="height: calc(100vh - 140px); min-height: calc(100vh - 140px);">
                        <!-- Full Screen Camera Container -->
                        <div class="w-full h-full relative absolute inset-0">
                            <video id="dynamicCameraFeed" class="w-full h-full object-cover" autoplay muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></video>
                            <canvas id="dynamicPoseCanvas" class="w-full h-full absolute top-0 left-0 z-30" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                            <div id="dynamicCameraPlaceholder" class="w-full h-full flex items-center justify-center bg-gray-800" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                                <div class="text-center text-white">
                                    <div class="text-6xl mb-4">üé•</div>
                                    <p class="text-xl mb-2">Perform the movement</p>
                                    <p class="text-sm opacity-75">Âãï‰Ωú„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ</p>
                                </div>
                            </div>
                            
                            <!-- Pose Detection Status - Top Overlay -->
                            <div id="dynamicPoseStatus" class="absolute top-4 left-4 bg-green-600 bg-opacity-80 text-white text-sm px-3 py-2 rounded-lg z-40">
                                <span id="dynamicPoseIndicator" class="w-3 h-3 bg-red-500 rounded-full inline-block mr-2 animate-pulse"></span>
                                <span id="dynamicPoseText">Starting Camera...</span>
                            </div>
                            
                            <!-- Camera Switch Button - Top Center -->
                            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 z-35">
                                <button id="dynamicCameraSwitch" onclick="switchCamera('dynamic')" class="bg-black bg-opacity-70 text-white p-3 rounded-full hover:bg-opacity-90 transition-all">
                                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                                    </svg>
                                </button>
                                <div class="text-center mt-1">
                                    <span id="dynamicCameraLabel" class="text-xs text-white bg-black bg-opacity-50 px-2 py-1 rounded">„Ç§„É≥„Ç´„É°„É©</span>
                                </div>
                            </div>
                            
                            <!-- Top Right Controls Area -->
                            <div class="absolute top-4 right-4 z-35 flex flex-col items-end space-y-2">
                                <!-- Reload Button for MediaPipe Fix -->
                                <button id="dynamicReloadBtn" onclick="smartReload()" class="bg-red-600 bg-opacity-80 text-white p-2 rounded-full hover:bg-opacity-100 transition-all" title="Reload app if pose detection stops / È™®Ê†ºË™çË≠ò„ÅåÂÅúÊ≠¢„Åó„Åü„Çâ„É™„É≠„Éº„Éâ">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                    </svg>
                                </button>
                                
                                <!-- Movement Counter -->
                                <div id="movementCounter" class="bg-black bg-opacity-70 text-white text-lg px-4 py-2 rounded-lg">
                                    <span class="font-bold">Squats: </span>
                                    <span id="squatCount" class="text-2xl font-bold text-green-400">0</span>
                                </div>
                            </div>
                            
                            <!-- Current Exercise Info - Bottom -->
                            <div class="absolute bottom-24 left-0 right-0 text-center text-white z-35">
                                <div class="bg-blue-600 bg-opacity-80 mx-4 py-3 px-4 rounded-lg">
                                    <p class="text-sm font-medium mb-1">Current Exercise: Squat</p>
                                    <p class="text-xs opacity-90 mb-2">ÁèæÂú®„ÅÆ„Ç®„ÇØ„Çµ„Çµ„Ç§„Ç∫Ôºö„Çπ„ÇØ„ÉØ„ÉÉ„Éà</p>
                                    <p class="text-xs opacity-70">üì∑ Tap center-top to switch camera / „Ç´„É°„É©Âàá„ÇäÊõø„Åà„ÅØ‰∏ä‰∏≠Â§Æ„Çí„Çø„ÉÉ„Éó</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Controls - Sticky Bottom -->
                    <div id="dynamicControlsBottom" class="flex-shrink-0 px-6 py-6 bg-black bg-opacity-20 backdrop-filter backdrop-blur-md border-t border-white border-opacity-20 space-y-4 transition-all duration-300">
                        <div class="bg-white bg-opacity-20 backdrop-filter backdrop-blur-sm p-4 rounded-lg border border-white border-opacity-30">
                            <p class="text-sm text-white font-medium mb-1 drop-shadow-lg">Current Exercise: Squat</p>
                            <p class="text-xs text-gray-200 drop-shadow-lg">ÁèæÂú®„ÅÆ„Ç®„ÇØ„Çµ„Çµ„Ç§„Ç∫Ôºö„Çπ„ÇØ„ÉØ„ÉÉ„Éà</p>
                        </div>
                        <button id="dynamicCaptureBtn" onclick="startDynamicCaptureImproved()" class="bg-white bg-opacity-90 hover:bg-opacity-100 text-gray-900 font-medium py-4 px-8 rounded-xl text-lg w-full backdrop-filter backdrop-blur-sm transition-all duration-200 shadow-lg">
                            Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Analysis History Screen -->
            <div id="analysis-history" class="app-screen bg-gray-50">
                <div class="flex-1 overflow-y-auto">
                    <!-- Header -->
                    <div class="bg-white px-6 py-4 shadow-sm sticky top-0 z-10">
                        <div class="flex items-center">
                            <button onclick="showDashboard()" class="mr-4 text-gray-600">‚Üê</button>
                            <h2 class="text-lg font-semibold brand-color">Analysis History / ÂàÜÊûêÂ±•Ê≠¥</h2>
                        </div>
                    </div>
                    
                    <!-- Filter Tabs -->
                    <div class="bg-white px-6 py-3 border-b">
                        <div class="flex justify-between items-center">
                            <div class="flex space-x-4">
                                <button id="filterAll" onclick="filterAnalysisHistory('all')" class="px-4 py-2 text-sm rounded-lg bg-blue-50 brand-color font-medium">
                                    All / ÂÖ®„Å¶
                                </button>
                                <button id="filterStatic" onclick="filterAnalysisHistory('static')" class="px-4 py-2 text-sm rounded-lg text-gray-600">
                                    Static / ÈùôÁöÑ
                                </button>
                                <button id="filterDynamic" onclick="filterAnalysisHistory('dynamic')" class="px-4 py-2 text-sm rounded-lg text-gray-600">
                                    Dynamic / ÂãïÁöÑ
                                </button>
                            </div>
                            <button onclick="showPhotoComparison()" class="px-3 py-2 text-sm bg-green-50 text-green-700 rounded-lg hover:bg-green-100 flex items-center">
                                üìä Compare / ÊØîËºÉ
                            </button>
                        </div>
                    </div>
                    
                    <!-- History Timeline -->
                    <div class="px-6 py-4">
                        <div id="historyTimeline" class="space-y-4">
                            <!-- Timeline items will be populated here -->
                        </div>
                        
                        <!-- Empty State -->
                        <div id="historyEmptyState" class="text-center py-12 hidden">
                            <div class="text-6xl mb-4">üìä</div>
                            <h3 class="text-lg font-semibold text-gray-700 mb-2">No Analysis Yet</h3>
                            <p class="text-gray-500 mb-6">„Åæ„Å†ÂàÜÊûê„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>
                            <button onclick="showDashboard()" class="brand-bg text-white px-6 py-3 rounded-lg">
                                Start Analysis / ÂàÜÊûê„ÇíÈñãÂßã
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Analysis Detail Screen -->
            <div id="analysis-detail" class="app-screen bg-gray-50">
                <div class="flex-1 overflow-y-auto">
                    <!-- Header -->
                    <div class="bg-white px-6 py-4 shadow-sm sticky top-0 z-10">
                        <div class="flex items-center">
                            <button onclick="showAnalysisHistory()" class="mr-4 text-gray-600">‚Üê</button>
                            <h2 class="text-lg font-semibold brand-color">Analysis Detail / ÂàÜÊûêË©≥Á¥∞</h2>
                        </div>
                    </div>
                    
                    <!-- Detail Content -->
                    <div class="px-6 py-4" id="analysisDetailContent">
                        <!-- Content will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Results Screen - Dior Sport Luxury -->
            <div id="results" class="app-screen bg-gradient-to-b from-gray-50 to-white">
                <div class="flex-1 overflow-y-auto">
                    <!-- Elegant Header -->
                    <div class="bg-black bg-opacity-90 backdrop-filter backdrop-blur-md px-8 py-6">
                        <div class="flex items-center dior-fade-in">
                            <button onclick="showDashboard()" class="mr-6 text-white hover:text-gray-300 transition-colors duration-300 font-thin text-lg">‚Üê</button>
                            <div>
                                <div class="w-8 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mb-1"></div>
                                <h2 class="text-sm font-thin text-white tracking-widest uppercase">Performance Results</h2>
                                <div class="w-4 h-px bg-gray-400 mt-1"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Luxury Score Display -->
                    <div class="px-8 py-8">
                        <div class="text-center mb-12 dior-slide-up" style="animation-delay: 0.2s;">
                            <div class="w-24 h-px bg-gradient-to-r from-transparent via-gray-300 to-transparent mx-auto mb-6"></div>
                            <div class="text-6xl font-thin text-black mb-3">85</div>
                            <div class="text-xs text-gray-500 font-light tracking-widest uppercase mb-1">Overall Performance</div>
                            <div class="text-xs text-gray-400 font-light">Á∑èÂêà„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ</div>
                            <div class="w-12 h-px bg-gray-300 mx-auto mt-4"></div>
                        </div>
                        
                        <!-- Elegant Chart -->
                        <div class="bg-white bg-opacity-60 backdrop-filter backdrop-blur-sm border border-gray-300 border-opacity-50 rounded-none p-8 mb-12 dior-fade-in" style="animation-delay: 0.4s;">
                            <div class="text-center mb-6">
                                <h3 class="text-sm font-light text-black tracking-wide uppercase mb-2">Performance Metrics</h3>
                                <div class="w-12 h-px bg-gray-300 mx-auto mb-1"></div>
                                <div class="text-xs text-gray-500 font-light">„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊåáÊ®ô</div>
                            </div>
                            <div style="height: 280px;">
                                <canvas id="analysisChart"></canvas>
                            </div>
                        </div>
                        
                        <!-- Minimalist Results -->
                        <div class="space-y-6 dior-slide-up" style="animation-delay: 0.6s;">
                            <div class="border border-gray-300 border-opacity-30 rounded-none p-6 bg-white bg-opacity-40 backdrop-filter backdrop-blur-sm">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="text-sm font-light text-black tracking-wide uppercase">Hip Flexibility</div>
                                        <div class="text-xs text-gray-500 font-light">ËÇ°Èñ¢ÁØÄÊüîËªüÊÄß</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="hip-score" class="text-green-600 font-bold">92%</div>
                                        <div class="text-xs text-gray-500">Good</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-white p-4 rounded-xl">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-semibold brand-color">Postural Stability</div>
                                        <div class="text-sm text-gray-500">ÂßøÂã¢ÂÆâÂÆöÊÄß</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="posture-score" class="text-orange-600 font-bold">78%</div>
                                        <div class="text-xs text-gray-500">Needs Work</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-white p-4 rounded-xl">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-semibold brand-color">Dynamic Balance</div>
                                        <div class="text-sm text-gray-500">ÂãïÁöÑ„Éê„É©„É≥„Çπ</div>
                                    </div>
                                    <div class="text-right">
                                        <div id="balance-score" class="text-green-600 font-bold">85%</div>
                                        <div class="text-xs text-gray-500">Good</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Recommendations -->
                        <div class="mt-6">
                            <h3 class="text-lg font-semibold brand-color mb-4">Recommendations</h3>
                            <div class="bg-white p-4 rounded-xl">
                                <div class="space-y-3">
                                    <div class="flex items-start">
                                        <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                                        <div>
                                            <p class="text-sm text-gray-700">Focus on core strengthening exercises</p>
                                            <p class="text-xs text-gray-500">‰ΩìÂππÂº∑Âåñ„Ç®„ÇØ„Çµ„Çµ„Ç§„Ç∫„Å´ÈáçÁÇπ„ÇíÁΩÆ„Åè</p>
                                        </div>
                                    </div>
                                    <div class="flex items-start">
                                        <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                                        <div>
                                            <p class="text-sm text-gray-700">Improve hip flexor mobility</p>
                                            <p class="text-xs text-gray-500">ËÇ°Èñ¢ÁØÄÂ±àÁ≠ãÁæ§„ÅÆÂèØÂãïÊÄß„ÇíÂêë‰∏ä„Åï„Åõ„Çã</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-6 space-y-3">
                            <button onclick="shareResults()" class="w-full bg-gray-100 text-gray-700 font-medium py-3 px-6 rounded-xl">
                                Share Results / ÁµêÊûú„ÇíÂÖ±Êúâ
                            </button>
                            <button onclick="showDashboard()" class="brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg w-full">
                                Back to Dashboard / „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Å´Êàª„Çã
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Photo Comparison Screen -->
            <div id="photo-comparison" class="app-screen bg-gray-50">
                <div class="flex-1 overflow-y-auto">
                    <!-- Header -->
                    <div class="bg-white px-6 py-4 shadow-sm sticky top-0 z-10">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <button onclick="showAnalysisHistory()" class="mr-4 text-gray-600">‚Üê</button>
                                <h2 class="text-lg font-semibold brand-color">Photo Comparison / ÂÜôÁúüÊØîËºÉ</h2>
                            </div>
                            <button onclick="resetComparison()" class="text-sm text-gray-500 hover:text-gray-700">
                                Reset / „É™„Çª„ÉÉ„Éà
                            </button>
                        </div>
                    </div>
                    
                    <!-- Photo Selection -->
                    <div class="px-6 py-4">
                        <div class="mb-6">
                            <h3 class="text-md font-semibold text-gray-800 mb-4">Select Photos to Compare / ÊØîËºÉ„Åô„ÇãÂÜôÁúü„ÇíÈÅ∏Êäû</h3>
                            <div class="grid grid-cols-2 gap-4" id="photoSelectionGrid">
                                <!-- Photos will be populated here -->
                            </div>
                        </div>
                        
                        <!-- Comparison Display -->
                        <div id="comparisonDisplay" class="hidden">
                            <h3 class="text-md font-semibold text-gray-800 mb-4">Before vs After Comparison</h3>
                            
                            <!-- Side by side photos -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div class="bg-white rounded-xl p-4 shadow-sm">
                                    <div class="text-center mb-3">
                                        <div class="text-sm font-medium text-blue-600" id="beforeLabel">Before</div>
                                        <div class="text-xs text-gray-500" id="beforeDate"></div>
                                    </div>
                                    <div class="relative">
                                        <img id="beforePhoto" class="w-full h-auto rounded-lg shadow-md" style="max-height: 300px; object-fit: contain;">
                                        <div class="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded" id="beforeScore">
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="bg-white rounded-xl p-4 shadow-sm">
                                    <div class="text-center mb-3">
                                        <div class="text-sm font-medium text-green-600" id="afterLabel">After</div>
                                        <div class="text-xs text-gray-500" id="afterDate"></div>
                                    </div>
                                    <div class="relative">
                                        <img id="afterPhoto" class="w-full h-auto rounded-lg shadow-md" style="max-height: 300px; object-fit: contain;">
                                        <div class="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded" id="afterScore">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Score Comparison -->
                            <div class="bg-white rounded-xl p-6 shadow-sm">
                                <h4 class="text-lg font-semibold brand-color mb-4">Score Improvement / „Çπ„Ç≥„Ç¢ÊîπÂñÑ</h4>
                                <div id="scoreComparison" class="space-y-4">
                                    <!-- Score comparison will be populated here -->
                                </div>
                                
                                <!-- Progress Analysis -->
                                <div class="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <div class="text-sm font-medium text-blue-800 mb-2">Progress Analysis / ÈÄ≤Ê≠©ÂàÜÊûê</div>
                                    <div id="progressAnalysis" class="text-sm text-blue-700">
                                        <!-- Progress analysis will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Empty State -->
                        <div id="comparisonEmptyState" class="text-center py-12">
                            <div class="text-6xl mb-4">üìä</div>
                            <h3 class="text-lg font-semibold text-gray-700 mb-2">Select Two Photos to Compare</h3>
                            <p class="text-gray-500">2„Å§„ÅÆÂÜôÁúü„ÇíÈÅ∏Êäû„Åó„Å¶ÊØîËºÉ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        let currentScreen = 'splash';
        let currentUser = null;
        
        // PWA Installation
        let deferredPrompt;
        let isInstalled = false;
        
        // Core navigation functions - MUST be defined first
        function showScreen(screenId) {
            console.log('Switching to screen:', screenId);
            
            try {
                // Hide all screens first
                const allScreens = document.querySelectorAll('.app-screen');
                console.log(`üîç Found ${allScreens.length} app screens`);
                
                allScreens.forEach(screen => {
                    screen.classList.remove('active');
                });
                
                // Show target screen
                const targetScreen = document.getElementById(screenId);
                if (targetScreen) {
                    targetScreen.classList.add('active');
                    console.log(`‚úÖ Screen '${screenId}' activated successfully`);
                    currentScreen = screenId;
                } else {
                    console.error(`‚ùå Screen '${screenId}' not found`);
                    return false;
                }
                
                // Hide all floating buttons when switching screens
                if (typeof hideAllFloatingButtons === 'function') {
                    hideAllFloatingButtons();
                }
                
                return true;
            } catch (error) {
                console.error('‚ùå Error in showScreen:', error);
                return false;
            }
        }
        
        // Fullscreen camera control functions
        function enterFullscreenMode(type) {
            console.log('Entering fullscreen mode for:', type);
            
            try {
                if (type === 'static') {
                    const header = document.getElementById('staticHeader');
                    const controls = document.getElementById('staticControlsBottom');
                    const container = document.getElementById('staticCameraContainer');
                    
                    if (header && controls && container) {
                        // Hide header and controls completely
                        header.style.display = 'none';
                        controls.style.display = 'none';
                        
                        // Make camera container fullscreen
                        container.classList.add('fullscreen');
                        container.style.height = '100vh';
                        container.style.minHeight = '100vh';
                        
                        // Hide floating button during fullscreen operations
                        hideFloatingButton('static');
                        console.log('‚úÖ Static fullscreen mode activated');
                    } else {
                        console.error('‚ùå Static elements not found:', {header, controls, container});
                    }
                } else if (type === 'dynamic') {
                    const header = document.getElementById('dynamicHeader');
                    const controls = document.getElementById('dynamicControlsBottom');
                    const container = document.getElementById('dynamicCameraContainer');
                    
                    if (header && controls && container) {
                        // Hide header and controls completely
                        header.style.display = 'none';
                        controls.style.display = 'none';
                        
                        // Make camera container fullscreen
                        container.classList.add('fullscreen');
                        container.style.height = '100vh';
                        container.style.minHeight = '100vh';
                        
                        // Hide floating button during fullscreen operations
                        hideFloatingButton('dynamic');
                        console.log('‚úÖ Dynamic fullscreen mode activated');
                    } else {
                        console.error('‚ùå Dynamic elements not found:', {header, controls, container});
                    }
                }
            } catch (error) {
                console.error('‚ùå Error entering fullscreen mode:', error);
            }
        }
        
        function exitFullscreenMode(type) {
            console.log('Exiting fullscreen mode for:', type);
            
            try {
                if (type === 'static') {
                    const header = document.getElementById('staticHeader');
                    const controls = document.getElementById('staticControlsBottom');
                    const container = document.getElementById('staticCameraContainer');
                    
                    if (header && controls && container) {
                        // Show header and controls again
                        header.style.display = 'flex';
                        controls.style.display = 'block';
                        
                        // Remove fullscreen from camera container
                        container.classList.remove('fullscreen');
                        container.style.height = 'calc(100vh - 140px)';
                        container.style.minHeight = 'calc(100vh - 140px)';
                        
                        // Hide floating button and return to normal UI
                        hideFloatingButton('static');
                        console.log('‚úÖ Static fullscreen mode deactivated');
                    }
                } else if (type === 'dynamic') {
                    const header = document.getElementById('dynamicHeader');
                    const controls = document.getElementById('dynamicControlsBottom');
                    const container = document.getElementById('dynamicCameraContainer');
                    
                    if (header && controls && container) {
                        // Show header and controls again
                        header.style.display = 'flex';
                        controls.style.display = 'block';
                        
                        // Remove fullscreen from camera container
                        container.classList.remove('fullscreen');
                        container.style.height = 'calc(100vh - 140px)';
                        container.style.minHeight = 'calc(100vh - 140px)';
                        
                        // Hide floating button and return to normal UI
                        hideFloatingButton('dynamic');
                        console.log('‚úÖ Dynamic fullscreen mode deactivated');
                    }
                }
            } catch (error) {
                console.error('‚ùå Error exiting fullscreen mode:', error);
            }
        }
        
        // Floating button control functions
        function showFloatingButton(type) {
            hideAllFloatingButtons();
            if (type === 'static') {
                document.getElementById('floatingStaticBtn').classList.add('visible');
            } else if (type === 'dynamic') {
                document.getElementById('floatingDynamicBtn').classList.add('visible');
            }
        }
        
        function hideFloatingButton(type) {
            if (type === 'static') {
                document.getElementById('floatingStaticBtn').classList.remove('visible');
            } else if (type === 'dynamic') {
                document.getElementById('floatingDynamicBtn').classList.remove('visible');
            }
        }
        
        function hideAllFloatingButtons() {
            document.getElementById('floatingStaticBtn').classList.remove('visible');
            document.getElementById('floatingDynamicBtn').classList.remove('visible');
        }
        
        // Create full-screen transparent camera overlay
        function createFullScreenCameraOverlay(type) {
            console.log('üé¨ Creating full-screen camera overlay for:', type);
            
            // Get video and canvas elements
            const videoElementId = type === 'static' ? 'staticCameraFeed' : 'dynamicCameraFeed';
            const canvasElementId = type === 'static' ? 'staticPoseCanvas' : 'dynamicPoseCanvas';
            const video = document.getElementById(videoElementId);
            const canvas = document.getElementById(canvasElementId);
            
            if (!video || !canvas) {
                console.error('‚ùå Video or canvas not found for overlay');
                return;
            }
            
            // Create fullscreen overlay container
            const overlay = document.createElement('div');
            overlay.id = `${type}FullscreenOverlay`;
            overlay.className = 'fixed inset-0 bg-black';
            overlay.style.zIndex = '9999';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.top = '0';
            overlay.style.left = '0';
            
            // Create video container within overlay
            const videoContainer = document.createElement('div');
            videoContainer.className = 'relative w-full h-full flex items-center justify-center';
            
            // Clone and setup video element for fullscreen
            const fullscreenVideo = video.cloneNode(true);
            fullscreenVideo.id = `${type}FullscreenVideo`;
            fullscreenVideo.className = 'w-full h-full object-cover';
            fullscreenVideo.style.maxWidth = '100vw';
            fullscreenVideo.style.maxHeight = '100vh';
            fullscreenVideo.autoplay = true;
            fullscreenVideo.muted = true;
            fullscreenVideo.playsInline = true;
            
            // Transfer the video stream to fullscreen video
            if (video.srcObject) {
                fullscreenVideo.srcObject = video.srcObject;
            }
            
            // Apply camera mirroring if front camera
            if (currentFacingMode === 'user') {
                fullscreenVideo.style.transform = 'scaleX(-1)';
            }
            
            // Create pose canvas for fullscreen
            const fullscreenCanvas = document.createElement('canvas');
            fullscreenCanvas.id = `${type}FullscreenCanvas`;
            fullscreenCanvas.className = 'absolute inset-0 w-full h-full pointer-events-none';
            fullscreenCanvas.style.zIndex = '10';
            
            // Create control overlay (transparent layer for buttons)
            const controlOverlay = document.createElement('div');
            controlOverlay.className = 'absolute inset-0 w-full h-full';
            controlOverlay.style.zIndex = '20';
            controlOverlay.style.background = 'transparent';
            
            // Add exit button (small X in top-right corner)
            const exitButton = document.createElement('button');
            exitButton.innerHTML = '√ó';
            exitButton.className = 'absolute top-4 right-4 w-10 h-10 bg-black bg-opacity-50 text-white text-2xl rounded-full hover:bg-opacity-70 transition-all';
            exitButton.onclick = () => removeFullScreenCameraOverlay(type);
            
            // Add camera controls overlay
            const cameraControls = createFullscreenCameraControls(type);
            
            // Assemble the overlay
            videoContainer.appendChild(fullscreenVideo);
            videoContainer.appendChild(fullscreenCanvas);
            controlOverlay.appendChild(exitButton);
            controlOverlay.appendChild(cameraControls);
            overlay.appendChild(videoContainer);
            overlay.appendChild(controlOverlay);
            
            // Add to document
            document.body.appendChild(overlay);
            
            // Setup fullscreen pose detection
            setupFullscreenPoseDetection(type, fullscreenVideo, fullscreenCanvas);
            
            console.log('‚úÖ Fullscreen camera overlay created');
        }
        
        // Create camera controls for fullscreen mode
        function createFullscreenCameraControls(type) {
            const controls = document.createElement('div');
            controls.className = 'absolute inset-0 flex flex-col justify-between p-4';
            
            // Top controls (pose status, camera switch)
            const topControls = document.createElement('div');
            topControls.className = 'flex justify-between items-start';
            
            // Pose detection status
            const poseStatus = document.createElement('div');
            poseStatus.id = `${type}FullscreenPoseStatus`;
            poseStatus.className = 'bg-green-600 bg-opacity-80 text-white text-sm px-3 py-2 rounded-lg';
            poseStatus.innerHTML = `
                <span id="${type}FullscreenPoseIndicator" class="w-3 h-3 bg-red-500 rounded-full inline-block mr-2 animate-pulse"></span>
                <span id="${type}FullscreenPoseText">Starting Camera...</span>
            `;
            
            // Camera switch button
            const cameraSwitch = document.createElement('button');
            cameraSwitch.className = 'bg-black bg-opacity-70 text-white p-3 rounded-full hover:bg-opacity-90 transition-all';
            cameraSwitch.innerHTML = `
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                </svg>
            `;
            cameraSwitch.onclick = () => switchFullscreenCamera(type);
            
            topControls.appendChild(poseStatus);
            topControls.appendChild(cameraSwitch);
            
            // Center area (transparent - user can see full camera view)
            const centerArea = document.createElement('div');
            centerArea.className = 'flex-1 flex items-center justify-center';
            
            // Instruction text (minimal, semi-transparent)
            const instruction = document.createElement('div');
            instruction.className = 'text-center text-white bg-black bg-opacity-40 px-4 py-2 rounded-lg';
            if (type === 'static') {
                instruction.innerHTML = `
                    <p class="text-sm mb-1">Stand naturally / Ëá™ÁÑ∂„Å´Á´ã„Å£„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    <p class="text-xs opacity-75">Tap anywhere to start countdown / „Å©„Åì„Åß„ÇÇ„Çø„ÉÉ„Éó„Åß„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã</p>
                `;
            } else {
                instruction.innerHTML = `
                    <p class="text-sm mb-1">Get ready to move / Âãï„ÅèÊ∫ñÂÇô„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    <p class="text-xs opacity-75">Tap anywhere to start recording / „Å©„Åì„Åß„ÇÇ„Çø„ÉÉ„Éó„ÅßÈå≤ÁîªÈñãÂßã</p>
                `;
            }
            
            centerArea.appendChild(instruction);
            
            // Bottom controls (camera label)
            const bottomControls = document.createElement('div');
            bottomControls.className = 'text-center';
            
            const cameraLabel = document.createElement('div');
            cameraLabel.id = `${type}FullscreenCameraLabel`;
            cameraLabel.className = 'text-xs text-white bg-black bg-opacity-50 px-2 py-1 rounded inline-block';
            cameraLabel.textContent = currentFacingMode === 'user' ? '„Ç§„É≥„Ç´„É°„É©' : '„Ç¢„Ç¶„Éà„Ç´„É°„É©';
            
            bottomControls.appendChild(cameraLabel);
            
            // Assemble controls
            controls.appendChild(topControls);
            controls.appendChild(centerArea);
            controls.appendChild(bottomControls);
            
            // Make entire overlay clickable to start capture
            controls.onclick = (e) => {
                // Prevent clicks on buttons from triggering capture
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    return;
                }
                startFullscreenCapture(type);
            };
            
            return controls;
        }
        
        // Setup pose detection for fullscreen mode
        function setupFullscreenPoseDetection(type, video, canvas) {
            // Wait for video to be ready
            const checkVideoReady = () => {
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    console.log('üìπ Fullscreen video ready, starting pose detection');
                    
                    // Set canvas size to match screen
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    // Store reference for pose drawing
                    window[`${type}FullscreenVideo`] = video;
                    window[`${type}FullscreenCanvas`] = canvas;
                    
                    console.log('‚úÖ Fullscreen pose detection setup complete');
                } else {
                    setTimeout(checkVideoReady, 100);
                }
            };
            
            setTimeout(checkVideoReady, 500);
        }
        
        // Switch camera in fullscreen mode
        async function switchFullscreenCamera(type) {
            const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            try {
                // Get new camera stream
                const constraints = {
                    video: {
                        facingMode: { ideal: newFacingMode },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Update fullscreen video
                const fullscreenVideo = document.getElementById(`${type}FullscreenVideo`);
                if (fullscreenVideo) {
                    fullscreenVideo.srcObject = stream;
                    
                    // Update mirroring
                    if (newFacingMode === 'user') {
                        fullscreenVideo.style.transform = 'scaleX(-1)';
                    } else {
                        fullscreenVideo.style.transform = 'scaleX(1)';
                    }
                }
                
                // Update original video too
                const originalVideo = document.getElementById(type === 'static' ? 'staticCameraFeed' : 'dynamicCameraFeed');
                if (originalVideo) {
                    originalVideo.srcObject = stream;
                }
                
                // Update global state
                currentFacingMode = newFacingMode;
                updateFullscreenCameraLabel(type, newFacingMode);
                
                // Stop old stream
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                cameraStream = stream;
                
                console.log('‚úÖ Fullscreen camera switched to:', newFacingMode);
                
            } catch (error) {
                console.error('‚ùå Failed to switch fullscreen camera:', error);
            }
        }
        
        // Update camera label in fullscreen mode
        function updateFullscreenCameraLabel(type, facingMode) {
            const label = document.getElementById(`${type}FullscreenCameraLabel`);
            if (label) {
                label.textContent = facingMode === 'user' ? '„Ç§„É≥„Ç´„É°„É©' : '„Ç¢„Ç¶„Éà„Ç´„É°„É©';
            }
        }
        
        // Start capture in fullscreen mode
        function startFullscreenCapture(type) {
            console.log('üé¨ Starting fullscreen capture for:', type);
            
            // Hide the instruction
            const instruction = document.querySelector(`#${type}FullscreenOverlay .text-center.text-white`);
            if (instruction) {
                instruction.style.display = 'none';
            }
            
            // Start the appropriate capture sequence
            if (type === 'static') {
                startFullscreenStaticCountdown();
            } else {
                startFullscreenDynamicRecording();
            }
        }
        
        // Remove fullscreen overlay and return to normal mode
        function removeFullScreenCameraOverlay(type) {
            console.log('üö™ Removing fullscreen overlay for:', type);
            
            const overlay = document.getElementById(`${type}FullscreenOverlay`);
            if (overlay) {
                overlay.remove();
            }
            
            // Clean up references
            delete window[`${type}FullscreenVideo`];
            delete window[`${type}FullscreenCanvas`];
            
            // Re-enable original buttons
            const bottomButton = document.getElementById(type === 'static' ? 'staticCaptureBtn' : 'dynamicCaptureBtn');
            const floatingButton = document.getElementById(type === 'static' ? 'floatingStaticBtn' : 'floatingDynamicBtn');
            
            if (bottomButton) {
                bottomButton.disabled = false;
                bottomButton.textContent = type === 'static' ? 
                    'Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã' : 
                    'Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã';
            }
            if (floatingButton) {
                floatingButton.disabled = false;
            }
            
            console.log('‚úÖ Fullscreen overlay removed');
        }
        
        // Debug function to test fullscreen mode
        function testFullscreenMode() {
            console.log('Testing fullscreen mode for static analysis');
            enterFullscreenMode('static');
            setTimeout(() => {
                console.log('Exiting fullscreen mode after 3 seconds');
                exitFullscreenMode('static');
            }, 3000);
        }
        
        // Debug function to test voice
        function testVoice() {
            console.log('Testing voice synthesis...');
            enableSpeech();
            setTimeout(() => {
                speakCountdown('Voice test successful', true);
            }, 500);
        }
        
        // Make test functions available globally for debugging
        window.testVoice = testVoice;
        window.testFullscreenMode = testFullscreenMode;
        
        // Debug functions for analysis history
        window.debugAnalysisHistory = function() {
            const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
            console.log('üìä Analysis History Debug:', {
                totalEntries: results.length,
                entriesWithPhotos: results.filter(r => r.capturedPhoto).length,
                entries: results.map(r => ({
                    id: r.id.substring(0, 8) + '...',
                    type: r.analysis_type,
                    date: new Date(r.analysis_date).toLocaleDateString('ja-JP'),
                    hasPhoto: !!r.capturedPhoto,
                    photoSize: r.capturedPhoto ? (r.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                    score: r.overall_score
                }))
            });
            console.log('üë§ Current user:', currentUser);
            if (currentUser) {
                const userResults = results.filter(r => r.user_id === currentUser.id);
                console.log('üóÇÔ∏è User results:', userResults.length);
            }
            return results;
        };
        
        window.testAnalysisDetail = function(analysisId) {
            console.log('üß™ Testing showAnalysisDetail with ID:', analysisId);
            showAnalysisDetail(analysisId);
        };
        
        // Debug function for photo capture issues
        window.debugPhotoCapture = function() {
            const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
            const photosWithData = results.filter(r => r.capturedPhoto);
            const photosWithoutData = results.filter(r => !r.capturedPhoto);
            
            console.log('üì∏ Photo Capture Debug Report:');
            console.log('üìä Total analysis results:', results.length);
            console.log('‚úÖ Results with photos:', photosWithData.length);
            console.log('‚ùå Results without photos:', photosWithoutData.length);
            
            if (photosWithData.length > 0) {
                console.log('üì∑ Sample photo data:');
                const sample = photosWithData[0];
                console.log({
                    id: sample.id,
                    type: sample.analysis_type,
                    hasPhoto: !!sample.capturedPhoto,
                    imageSize: sample.capturedPhoto ? (sample.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                    dimensions: sample.capturedPhoto ? `${sample.capturedPhoto.width}x${sample.capturedPhoto.height}` : 'N/A'
                });
            }
            
            if (photosWithoutData.length > 0) {
                console.log('‚ö†Ô∏è Results without photos (recent 3):');
                photosWithoutData.slice(-3).forEach(result => {
                    console.log({
                        id: result.id,
                        type: result.analysis_type,
                        date: new Date(result.analysis_date).toLocaleString()
                    });
                });
            }
            
            return {
                total: results.length,
                withPhotos: photosWithData.length,
                withoutPhotos: photosWithoutData.length
            };
        };
        
        // Debug function to check current camera and pose state
        window.debugCameraState = function() {
            const staticVideo = document.getElementById('staticCameraFeed');
            const dynamicVideo = document.getElementById('dynamicCameraFeed');
            const staticCanvas = document.getElementById('staticPoseCanvas');
            const dynamicCanvas = document.getElementById('dynamicPoseCanvas');
            
            console.log('üìπ Camera State Debug:');
            console.log('Static video:', {
                exists: !!staticVideo,
                width: staticVideo ? staticVideo.videoWidth : 'N/A',
                height: staticVideo ? staticVideo.videoHeight : 'N/A',
                readyState: staticVideo ? staticVideo.readyState : 'N/A'
            });
            console.log('Dynamic video:', {
                exists: !!dynamicVideo,
                width: dynamicVideo ? dynamicVideo.videoWidth : 'N/A',
                height: dynamicVideo ? dynamicVideo.videoHeight : 'N/A',
                readyState: dynamicVideo ? dynamicVideo.readyState : 'N/A'
            });
            console.log('Pose detection:', {
                hasPoseResults: !!currentPoseResults,
                hasLandmarks: currentPoseResults ? !!currentPoseResults.poseLandmarks : false,
                landmarkCount: currentPoseResults && currentPoseResults.poseLandmarks ? currentPoseResults.poseLandmarks.length : 0
            });
            
            return {
                staticVideoReady: staticVideo && staticVideo.videoWidth > 0,
                dynamicVideoReady: dynamicVideo && dynamicVideo.videoWidth > 0,
                poseDetectionActive: !!(currentPoseResults && currentPoseResults.poseLandmarks)
            };
        };
        
        // Debug function to force create sample data with photos for immediate testing
        window.debugCreatePhotoSample = function() {
            if (!currentUser) {
                console.error('‚ùå No current user found');
                return;
            }
            
            const testPhotoData = {
                imageData: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iIzQzODVmNCIvPgogIDx0ZXh0IHg9IjE1MCIgeT0iODAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0iI2ZmZmZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+8J+MhyBURVNUIFBIT1RPPC90ZXh0PgogIDx0ZXh0IHg9IjE1MCIgeT0iMTEwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTYiIGZpbGw9IiNmZmZmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkF0aGxldGVDb3JlIFBybzwvdGV4dD4KICA8dGV4dCB4PSIxNTAiIHk9IjE0MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5QaG90byBEaXNwbGF5IFRlc3Q8L3RleHQ+CiAgPGNpcmNsZSBjeD0iNzUiIGN5PSIxNjAiIHI9IjE1IiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iMjI1IiBjeT0iMTYwIiByPSIxNSIgZmlsbD0iI2ZmZmYwMCIvPgo8L3N2Zz4K",
                width: 300,
                height: 200,
                timestamp: new Date().toISOString(),
                hasPoseOverlay: true,
                cameraType: 'front'
            };
            
            const newTestResult = {
                id: generateUUID(),
                user_id: currentUser.id,
                analysis_type: 'static',
                sport: currentUser.primary_sport,
                analysis_date: new Date().toISOString(),
                overall_score: 88,
                hip_flexibility: 90,
                postural_stability: 85,
                dynamic_balance: 89,
                capturedPhoto: testPhotoData,
                recommendations: [
                    "üß™ This is a test photo sample / „Åì„Çå„ÅØ„ÉÜ„Çπ„ÉàÂÜôÁúü„Çµ„É≥„Éó„É´„Åß„Åô",
                    "Photo display debugging / ÂÜôÁúüË°®Á§∫„Éá„Éê„ÉÉ„Ç∞Áî®"
                ]
            };
            
            // Save to localStorage
            saveAnalysisResultLocal(newTestResult);
            
            console.log('üß™ Created test sample with photo:', {
                id: newTestResult.id,
                hasPhoto: !!newTestResult.capturedPhoto,
                photoSize: (newTestResult.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB'
            });
            
            // Refresh current screen to show new sample
            if (currentScreen === 'dashboard') {
                loadAnalysisHistory();
            } else if (currentScreen === 'analysis-history') {
                loadFullAnalysisHistory();
            }
            
            alert('üß™ Test photo sample created! Check the analysis history. / „ÉÜ„Çπ„ÉàÂÜôÁúü„Çµ„É≥„Éó„É´„Çí‰ΩúÊàê„Åó„Åæ„Åó„ÅüÔºÅÂàÜÊûêÂ±•Ê≠¥„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            
            return newTestResult;
        };
        
        // New debug function for MediaPipe stability monitoring
        window.debugMediaPipeStability = function() {
            console.log('üîß MediaPipe Stability Debug Report:');
            console.log('====================================');
            
            // Check MediaPipe object status
            console.log('MediaPipe Object Status:', {
                poseExists: !!pose,
                poseType: typeof pose,
                initializationFailed: !!window.mediaPipeInitializationFailed,
                detectionInterval: !!poseDetectionInterval,
                currentPoseResults: !!currentPoseResults,
                hasLandmarks: currentPoseResults ? !!currentPoseResults.poseLandmarks : false,
                landmarkCount: currentPoseResults && currentPoseResults.poseLandmarks ? currentPoseResults.poseLandmarks.length : 0
            });
            
            // Check video elements
            const staticVideo = document.getElementById('staticCameraFeed');
            const dynamicVideo = document.getElementById('dynamicCameraFeed');
            
            console.log('Video Elements Status:', {
                staticVideo: staticVideo ? {
                    exists: true,
                    srcObject: !!staticVideo.srcObject,
                    dimensions: `${staticVideo.videoWidth}x${staticVideo.videoHeight}`,
                    readyState: staticVideo.readyState,
                    paused: staticVideo.paused
                } : { exists: false },
                dynamicVideo: dynamicVideo ? {
                    exists: true,
                    srcObject: !!dynamicVideo.srcObject,
                    dimensions: `${dynamicVideo.videoWidth}x${dynamicVideo.videoHeight}`,
                    readyState: dynamicVideo.readyState,
                    paused: dynamicVideo.paused
                } : { exists: false }
            });
            
            // Check canvas elements
            const staticCanvas = document.getElementById('staticPoseCanvas');
            const dynamicCanvas = document.getElementById('dynamicPoseCanvas');
            
            console.log('Canvas Elements Status:', {
                staticCanvas: staticCanvas ? {
                    exists: true,
                    dimensions: `${staticCanvas.width}x${staticCanvas.height}`,
                    visible: staticCanvas.style.display !== 'none' && !staticCanvas.classList.contains('hidden'),
                    zIndex: staticCanvas.style.zIndex
                } : { exists: false },
                dynamicCanvas: dynamicCanvas ? {
                    exists: true,
                    dimensions: `${dynamicCanvas.width}x${dynamicCanvas.height}`,
                    visible: dynamicCanvas.style.display !== 'none' && !dynamicCanvas.classList.contains('hidden'),
                    zIndex: dynamicCanvas.style.zIndex
                } : { exists: false }
            });
            
            // Check current screen and state
            console.log('App State:', {
                currentScreen: currentScreen,
                currentUser: !!currentUser,
                currentFacingMode: currentFacingMode,
                isSmartReloadInProgress: !!sessionStorage.getItem('athletecore_reload_state')
            });
            
            // Return summary for programmatic access
            return {
                mediaPipeHealthy: !!pose && !window.mediaPipeInitializationFailed,
                videoReady: (staticVideo && staticVideo.videoWidth > 0) || (dynamicVideo && dynamicVideo.videoWidth > 0),
                poseDetectionActive: !!poseDetectionInterval,
                hasRecentResults: !!currentPoseResults,
                overallHealth: !!pose && !window.mediaPipeInitializationFailed && !!poseDetectionInterval
            };
        };
        
        // Debug function to test the accurate 10-second countdown timing
        window.debugCountdownTiming = function() {
            console.log('üïê Testing accurate 10-second countdown timing...');
            console.log('================================================');
            
            // Show detailed timing information
            console.log('üìã Accurate Timing Table:');
            console.log('Time 0s: Start countdown, display "10"');
            console.log('Time 1s: Display "9"');
            console.log('Time 2s: Display "8"');
            console.log('Time 3s: Display "7"');
            console.log('Time 4s: Display "6"');
            console.log('Time 5s: Display "5"');
            console.log('Time 6s: Display "4"');
            console.log('Time 7s: Display "3"');
            console.log('Time 8s: Display "2"');
            console.log('Time 9s: Display "1" + üì∏ PHOTO CAPTURE');
            console.log('Time 10s: Display "GO!" + Flash effects');
            console.log('');
            console.log('üéØ Photo capture occurs at exactly 9 seconds after countdown start');
            
            // Simulate the actual timing for testing
            let testCount = 10;
            let elapsedSeconds = 0;
            console.log(`\nüöÄ Starting simulation from count ${testCount}...`);
            
            const testInterval = setInterval(() => {
                elapsedSeconds++;
                testCount--;
                console.log(`Time ${elapsedSeconds}s: Count ${testCount}${testCount === 1 ? ' + üì∏ CAPTURE!' : ''}${testCount === 0 ? ' + üéâ GO!' : ''}`);
                
                if (testCount === 0) {
                    clearInterval(testInterval);
                    console.log('‚úÖ 10-second countdown simulation completed!');
                    console.log(`üì∏ Photo captured at ${elapsedSeconds - 1}s (count=1)`);
                    console.log(`üéâ Effects displayed at ${elapsedSeconds}s (count=0)`);
                }
            }, 1000);
            
            return 'Accurate countdown timing test started - check console for 10-second simulation';
        };
        
        // Debug function to test welcome screen layout
        window.debugWelcomeLayout = function() {
            console.log('üì± Welcome Screen Layout Debug');
            console.log('=============================');
            
            const welcomeScreen = document.getElementById('welcome');
            if (!welcomeScreen) {
                console.error('‚ùå Welcome screen not found');
                return;
            }
            
            const rect = welcomeScreen.getBoundingClientRect();
            console.log('Welcome Screen Dimensions:', {
                width: rect.width,
                height: rect.height,
                viewportHeight: window.innerHeight,
                isFullHeight: rect.height >= window.innerHeight,
                hasOverflow: welcomeScreen.scrollHeight > welcomeScreen.clientHeight
            });
            
            // Check if scrolling is needed
            const needsScroll = welcomeScreen.scrollHeight > window.innerHeight;
            console.log('Layout Status:', {
                needsScroll: needsScroll,
                scrollHeight: welcomeScreen.scrollHeight,
                clientHeight: welcomeScreen.clientHeight,
                viewportHeight: window.innerHeight
            });
            
            if (needsScroll) {
                console.warn('‚ö†Ô∏è Welcome screen may require scrolling on this device');
                console.log('Device info:', {
                    userAgent: navigator.userAgent,
                    screenHeight: screen.height,
                    windowHeight: window.innerHeight,
                    devicePixelRatio: window.devicePixelRatio
                });
            } else {
                console.log('‚úÖ Welcome screen fits perfectly without scrolling');
            }
            
            return {
                fitsWithoutScrolling: !needsScroll,
                dimensions: rect,
                overflow: needsScroll
            };
        };
        
        // Auto-monitor function for stability (can be called periodically)
        window.autoMonitorMediaPipeHealth = function() {
            const health = debugMediaPipeStability();
            
            if (!health.overallHealth) {
                console.warn('‚ö†Ô∏è MediaPipe health issue detected:', health);
                
                // Show user notification about potential issues
                showToast('‚ö†Ô∏è AI detection may be unstable - use üîÑ reload if needed / AIÊ§úÂá∫„Åå‰∏çÂÆâÂÆö„Å™ÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶üîÑ„É™„É≠„Éº„Éâ„Çí„ÅîÂà©Áî®„Åè„Å†„Åï„ÅÑ', 'warning');
                
                return false;
            }
            
            return true;
        };
        
        // New debug function to test current video capture immediately
        window.debugCaptureNow = function() {
            console.log('üì∏ DEBUG: Attempting immediate photo capture...');
            
            // Try both static and dynamic videos
            const staticVideo = document.getElementById('staticVideo');
            const dynamicVideo = document.getElementById('dynamicVideo');
            
            let activeVideo = null;
            let canvasId = null;
            
            if (staticVideo && staticVideo.srcObject && staticVideo.videoWidth > 0) {
                activeVideo = staticVideo;
                canvasId = 'staticCanvas';
                console.log('üé• Using static video for capture');
            } else if (dynamicVideo && dynamicVideo.srcObject && dynamicVideo.videoWidth > 0) {
                activeVideo = dynamicVideo;
                canvasId = 'dynamicCanvas';
                console.log('üé• Using dynamic video for capture');
            } else {
                console.error('‚ùå No active video stream found for capture');
                return null;
            }
            
            console.log('üîç Active video details:', {
                videoId: activeVideo.id,
                srcObject: !!activeVideo.srcObject,
                videoWidth: activeVideo.videoWidth,
                videoHeight: activeVideo.videoHeight,
                readyState: activeVideo.readyState,
                currentTime: activeVideo.currentTime,
                paused: activeVideo.paused
            });
            
            // Capture the photo
            const photo = capturePhoto(activeVideo.id, canvasId, true);
            
            if (photo) {
                console.log('üéâ Photo captured successfully!', {
                    size: (photo.imageData.length / 1024).toFixed(1) + 'KB',
                    dimensions: photo.width + 'x' + photo.height,
                    cameraType: photo.cameraType,
                    detectionMethod: photo.detectionMethod
                });
                
                // Create a test analysis result with this photo
                const testResult = {
                    id: generateUUID(),
                    user_id: currentUser ? currentUser.id : 'debug-user',
                    analysis_type: activeVideo.id.includes('static') ? 'static' : 'dynamic',
                    sport: currentUser ? currentUser.primary_sport : 'debug',
                    analysis_date: new Date().toISOString(),
                    overall_score: 92,
                    hip_flexibility: 95,
                    postural_stability: 88,
                    dynamic_balance: 94,
                    capturedPhoto: photo,
                    recommendations: [
                        "üì∏ „É™„Ç¢„É´„Çø„Ç§„É†„Ç≠„É£„Éó„ÉÅ„É£„ÉÜ„Çπ„Éà - ÊàêÂäü!",
                        "üéâ Real-time capture test - Success!"
                    ]
                };
                
                if (currentUser) {
                    saveAnalysisResultLocal(testResult);
                    refreshAnalysisHistory();
                }
                
                return photo;
            } else {
                console.error('‚ùå Photo capture failed');
                return null;
            }
        };
        
        // New debug function to validate video stream
        window.debugVideoStatus = function() {
            console.log('üìπ === VIDEO STREAM STATUS DEBUG ===');
            
            const staticVideo = document.getElementById('staticVideo');
            const dynamicVideo = document.getElementById('dynamicVideo');
            
            [staticVideo, dynamicVideo].forEach(video => {
                if (video) {
                    console.log(`üìπ ${video.id} status:`, {
                        exists: true,
                        srcObject: !!video.srcObject,
                        videoWidth: video.videoWidth,
                        videoHeight: video.videoHeight,
                        readyState: video.readyState,
                        readyStateText: getReadyStateText(video.readyState),
                        currentTime: video.currentTime,
                        paused: video.paused,
                        ended: video.ended,
                        networkState: video.networkState,
                        currentFacingMode: currentFacingMode,
                        dataFacingMode: video.getAttribute('data-facing-mode'),
                        transform: video.style.transform,
                        display: video.style.display,
                        visibility: video.style.visibility,
                        opacity: video.style.opacity
                    });
                } else {
                    console.log(`üìπ ${!staticVideo && video === staticVideo ? 'staticVideo' : 'dynamicVideo'}: NOT FOUND`);
                }
            });
            
            // Test MediaPipe status
            console.log('ü¶æ MediaPipe Status:', {
                poseLoaded: !!pose,
                currentPoseResults: !!currentPoseResults,
                hasLandmarks: !!(currentPoseResults && currentPoseResults.poseLandmarks)
            });
        };
        
        // Smart reload function to fix MediaPipe issues while preserving user data
        function smartReload() {
            console.log('üîÑ Starting smart reload to fix MediaPipe issues...');
            
            // Show loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'smartReloadOverlay';
            loadingOverlay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
            loadingOverlay.innerHTML = `
                <div class="bg-white rounded-lg p-6 mx-4 text-center max-w-sm">
                    <div class="text-4xl mb-4">üîÑ</div>
                    <h3 class="text-lg font-semibold mb-2">Reloading MediaPipe</h3>
                    <p class="text-sm text-gray-600 mb-4">È™®Ê†ºË™çË≠ò„ÇíÂÜçËµ∑Âãï„Åó„Å¶„ÅÑ„Åæ„Åô</p>
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"></div>
                </div>
            `;
            document.body.appendChild(loadingOverlay);
            
            // Save current state before reload
            const currentState = {
                user: currentUser,
                screen: currentScreen,
                facingMode: currentFacingMode,
                timestamp: new Date().toISOString()
            };
            
            console.log('üîÑ Saving state for smart reload:', {
                userExists: !!currentUser,
                userName: currentUser?.name,
                screen: currentScreen,
                facingMode: currentFacingMode
            });
            
            // Store state temporarily
            try {
                sessionStorage.setItem('athletecore_reload_state', JSON.stringify(currentState));
                console.log('‚úÖ Current state saved for smart reload');
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not save state:', error);
            }
            
            // Add reload reason to localStorage for debugging
            try {
                localStorage.setItem('athletecore_reload_reason', 'MediaPipe pose detection stopped');
                localStorage.setItem('athletecore_reload_timestamp', new Date().toISOString());
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not save reload info:', error);
            }
            
            // Perform the reload after a short delay to show the UI
            setTimeout(() => {
                console.log('üîÑ Performing page reload...');
                window.location.reload();
            }, 1000);
        }
        
        // Function to restore state after smart reload
        function restoreAfterSmartReload() {
            try {
                const savedState = sessionStorage.getItem('athletecore_reload_state');
                if (savedState) {
                    console.log('üîÑ Starting smart reload state restoration...');
                    const state = JSON.parse(savedState);
                    
                    console.log('üîÑ Saved state details:', {
                        user: state.user?.name || 'No user',
                        screen: state.screen || 'No screen',
                        facingMode: state.facingMode || 'No camera mode',
                        timestamp: state.timestamp
                    });
                    
                    // Restore user if it exists
                    if (state.user) {
                        console.log('üë§ Restoring user:', state.user.name || state.user.id);
                        currentUser = state.user;
                    }
                    
                    // Restore camera facing mode if available
                    if (state.facingMode) {
                        currentFacingMode = state.facingMode;
                        console.log('üì∑ Restored camera facing mode:', currentFacingMode);
                    }
                    
                    // IMPORTANT: Set current screen immediately to prevent welcome screen override
                    if (state.screen) {
                        currentScreen = state.screen;
                        console.log('üéØ Current screen set to:', currentScreen);
                    }
                    
                    // Wait for DOM to be ready, then restore the screen
                    setTimeout(() => {
                        console.log('üîÑ Executing screen restoration for:', state.screen);
                        
                        if (state.screen === 'static-analysis') {
                            console.log('üéØ Restoring Static Analysis screen...');
                            showScreen('static-analysis');
                            // Clear the saved state after successful restoration
                            sessionStorage.removeItem('athletecore_reload_state');
                            setTimeout(() => {
                                initializeStaticAnalysis();
                                console.log('‚úÖ Static analysis initialized after smart reload');
                            }, 200);
                        } else if (state.screen === 'dynamic-analysis') {
                            console.log('üéØ Restoring Dynamic Analysis screen...');
                            showScreen('dynamic-analysis');
                            // Clear the saved state after successful restoration
                            sessionStorage.removeItem('athletecore_reload_state');
                            setTimeout(() => {
                                initializeDynamicAnalysis();
                                console.log('‚úÖ Dynamic analysis initialized after smart reload');
                            }, 200);
                        } else if (state.screen === 'dashboard') {
                            console.log('üéØ Restoring Dashboard screen...');
                            showDashboard();
                            // Clear the saved state after successful restoration
                            sessionStorage.removeItem('athletecore_reload_state');
                        } else {
                            console.log('‚ö†Ô∏è Unknown screen type, clearing saved state');
                            sessionStorage.removeItem('athletecore_reload_state');
                            return false;
                        }
                        
                        // Show success message after successful restoration
                        setTimeout(() => {
                            console.log('‚úÖ Smart reload restoration completed successfully');
                            
                            // Show a brief success toast
                            const toast = document.createElement('div');
                            toast.id = 'smartReloadSuccessToast';
                            toast.className = 'fixed top-4 left-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50 text-center';
                            toast.innerHTML = '‚úÖ È™®Ê†ºË™çË≠ò„ÅåÂæ©Êóß„Åó„Åæ„Åó„Åü';
                            document.body.appendChild(toast);
                            
                            setTimeout(() => {
                                const existingToast = document.getElementById('smartReloadSuccessToast');
                                if (existingToast && existingToast.parentNode) {
                                    existingToast.parentNode.removeChild(existingToast);
                                }
                            }, 3000);
                            
                        }, 500);
                        
                    }, 100); // Reduced delay to beat the normal initialization
                    
                    return true; // Indicate successful restoration
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not restore state after reload:', error);
                // Clear any corrupted state data
                sessionStorage.removeItem('athletecore_reload_state');
            }
            
            return false; // Indicate no restoration occurred
        }
        
        // Auto-detection of MediaPipe issues
        let lastPoseDetectionTime = Date.now();
        let poseDetectionTimeoutId = null;
        
        function monitorPoseDetection() {
            // Update last detection time when we have pose results
            if (currentPoseResults && currentPoseResults.poseLandmarks) {
                lastPoseDetectionTime = Date.now();
                
                // Clear any existing timeout
                if (poseDetectionTimeoutId) {
                    clearTimeout(poseDetectionTimeoutId);
                    poseDetectionTimeoutId = null;
                }
            } else {
                // If no pose results for a while, set up a timeout to detect issues
                if (!poseDetectionTimeoutId) {
                    poseDetectionTimeoutId = setTimeout(() => {
                        const timeSinceLastDetection = Date.now() - lastPoseDetectionTime;
                        
                        // If more than 10 seconds without detection and camera is active
                        if (timeSinceLastDetection > 10000) {
                            const activeVideo = document.getElementById('staticVideo') || document.getElementById('dynamicVideo');
                            if (activeVideo && activeVideo.srcObject && activeVideo.videoWidth > 0) {
                                console.warn('‚ö†Ô∏è MediaPipe may have stopped - no pose detection for', timeSinceLastDetection, 'ms');
                                
                                // Show subtle notification about reload option
                                showPoseDetectionWarning();
                            }
                        }
                    }, 5000); // Check after 5 seconds of no detection
                }
            }
        }
        
        function showPoseDetectionWarning() {
            // Check if warning is already shown
            if (document.getElementById('poseDetectionWarning')) return;
            
            const warning = document.createElement('div');
            warning.id = 'poseDetectionWarning';
            warning.className = 'fixed bottom-20 left-4 right-4 bg-orange-500 text-white p-3 rounded-lg shadow-lg z-40 animate-bounce';
            warning.innerHTML = `
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <span class="text-lg mr-2">‚ö†Ô∏è</span>
                        <div>
                            <p class="text-sm font-medium">Pose detection may have stopped</p>
                            <p class="text-xs opacity-90">È™®Ê†ºË™çË≠ò„ÅåÂÅúÊ≠¢„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô</p>
                        </div>
                    </div>
                    <button onclick="smartReload()" class="bg-white text-orange-500 px-3 py-1 rounded text-sm font-medium hover:bg-gray-100">
                        Reload
                    </button>
                </div>
            `;
            
            document.body.appendChild(warning);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (document.getElementById('poseDetectionWarning')) {
                    document.getElementById('poseDetectionWarning').remove();
                }
            }, 10000);
        }
        
        // MM Measurement System - Convert pixels to millimeters based on body landmarks
        const MM_MEASUREMENT = {
            // Standard human body measurements for calibration (in mm)
            REFERENCE_MEASUREMENTS: {
                shoulderWidth: 450,        // Average shoulder width: 450mm
                hipWidth: 360,            // Average hip width: 360mm  
                headHeight: 240,          // Average head height (nose to top): 240mm
                torsoHeight: 600          // Average torso height: 600mm
            },
            
            // Calculate pixel-to-mm conversion ratio
            calculatePixelToMmRatio: function(landmarks, videoWidth, videoHeight) {
                if (!landmarks || landmarks.length < 33) return null;
                
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                const nose = landmarks[0];
                
                let ratios = [];
                
                // Method 1: Shoulder width calibration
                if (leftShoulder && rightShoulder && 
                    leftShoulder.visibility > 0.7 && rightShoulder.visibility > 0.7) {
                    
                    const shoulderPixelDistance = Math.abs(
                        (leftShoulder.x - rightShoulder.x) * videoWidth
                    );
                    
                    if (shoulderPixelDistance > 20) { // Avoid division by very small numbers
                        const shoulderRatio = this.REFERENCE_MEASUREMENTS.shoulderWidth / shoulderPixelDistance;
                        ratios.push({
                            method: 'shoulder',
                            ratio: shoulderRatio,
                            confidence: Math.min(leftShoulder.visibility, rightShoulder.visibility)
                        });
                    }
                }
                
                // Method 2: Hip width calibration
                if (leftHip && rightHip && 
                    leftHip.visibility > 0.7 && rightHip.visibility > 0.7) {
                    
                    const hipPixelDistance = Math.abs(
                        (leftHip.x - rightHip.x) * videoWidth
                    );
                    
                    if (hipPixelDistance > 15) {
                        const hipRatio = this.REFERENCE_MEASUREMENTS.hipWidth / hipPixelDistance;
                        ratios.push({
                            method: 'hip',
                            ratio: hipRatio,
                            confidence: Math.min(leftHip.visibility, rightHip.visibility)
                        });
                    }
                }
                
                // Method 3: Torso height calibration (shoulder to hip)
                if (leftShoulder && rightShoulder && leftHip && rightHip &&
                    leftShoulder.visibility > 0.6 && rightShoulder.visibility > 0.6 &&
                    leftHip.visibility > 0.6 && rightHip.visibility > 0.6) {
                    
                    const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;
                    const hipCenterY = (leftHip.y + rightHip.y) / 2;
                    const torsoPixelHeight = Math.abs(shoulderCenterY - hipCenterY) * videoHeight;
                    
                    if (torsoPixelHeight > 30) {
                        const torsoRatio = this.REFERENCE_MEASUREMENTS.torsoHeight / torsoPixelHeight;
                        ratios.push({
                            method: 'torso',
                            ratio: torsoRatio,
                            confidence: Math.min(
                                leftShoulder.visibility, rightShoulder.visibility,
                                leftHip.visibility, rightHip.visibility
                            )
                        });
                    }
                }
                
                if (ratios.length === 0) return null;
                
                // Calculate weighted average based on confidence
                let totalWeight = 0;
                let weightedSum = 0;
                
                ratios.forEach(r => {
                    totalWeight += r.confidence;
                    weightedSum += r.ratio * r.confidence;
                });
                
                const averageRatio = weightedSum / totalWeight;
                
                return {
                    pixelToMmRatio: averageRatio,
                    confidence: totalWeight / ratios.length,
                    methods: ratios,
                    calibrationQuality: this.getCalibrationQuality(ratios.length, totalWeight / ratios.length)
                };
            },
            
            // Get calibration quality assessment
            getCalibrationQuality: function(methodCount, avgConfidence) {
                if (methodCount >= 3 && avgConfidence >= 0.8) return 'excellent';
                if (methodCount >= 2 && avgConfidence >= 0.7) return 'good';
                if (methodCount >= 1 && avgConfidence >= 0.6) return 'fair';
                return 'poor';
            },
            
            // Calculate horizontal deviation in mm for specific landmarks
            calculateHorizontalDeviation: function(landmarks, videoWidth, videoHeight, pixelToMmRatio) {
                if (!landmarks || !pixelToMmRatio) return null;
                
                const measurements = {};
                
                // Shoulder alignment (landmarks 11, 12)
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                
                if (leftShoulder && rightShoulder && 
                    leftShoulder.visibility > 0.5 && rightShoulder.visibility > 0.5) {
                    
                    const shoulderPixelDiff = Math.abs(
                        (leftShoulder.y - rightShoulder.y) * videoHeight
                    );
                    const shoulderMmDiff = shoulderPixelDiff * pixelToMmRatio;
                    
                    // Determine which shoulder is higher
                    const higherShoulder = leftShoulder.y < rightShoulder.y ? 'left' : 'right';
                    
                    measurements.shoulderAlignment = {
                        deviationMm: shoulderMmDiff,
                        higherShoulder: higherShoulder,
                        leftY: leftShoulder.y * videoHeight,
                        rightY: rightShoulder.y * videoHeight,
                        confidence: Math.min(leftShoulder.visibility, rightShoulder.visibility)
                    };
                }
                
                // Hip alignment (landmarks 23, 24)
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                
                if (leftHip && rightHip && 
                    leftHip.visibility > 0.5 && rightHip.visibility > 0.5) {
                    
                    const hipPixelDiff = Math.abs(
                        (leftHip.y - rightHip.y) * videoHeight
                    );
                    const hipMmDiff = hipPixelDiff * pixelToMmRatio;
                    
                    // Determine which hip is higher
                    const higherHip = leftHip.y < rightHip.y ? 'left' : 'right';
                    
                    measurements.hipAlignment = {
                        deviationMm: hipMmDiff,
                        higherHip: higherHip,
                        leftY: leftHip.y * videoHeight,
                        rightY: rightHip.y * videoHeight,
                        confidence: Math.min(leftHip.visibility, rightHip.visibility)
                    };
                }
                
                return measurements;
            },
            
            // Get assessment text for deviation
            getDeviationAssessment: function(deviationMm) {
                if (deviationMm < 5) return { level: 'excellent', text: 'ÁêÜÊÉ≥ÁöÑ', color: '#10B981' };
                if (deviationMm < 15) return { level: 'good', text: 'ËâØÂ•Ω', color: '#059669' };
                if (deviationMm < 30) return { level: 'moderate', text: 'ËªΩÂ∫¶ÂÇæÊñú', color: '#F59E0B' };
                if (deviationMm < 50) return { level: 'concerning', text: '‰∏≠Â∫¶ÂÇæÊñú', color: '#EF4444' };
                return { level: 'severe', text: 'È´òÂ∫¶ÂÇæÊñú', color: '#DC2626' };
            }
        };
        
        // Enhanced pose analysis with mm measurements
        function analyzePoseWithMmMeasurements(landmarks, videoWidth, videoHeight) {
            if (!landmarks || landmarks.length < 33) return null;
            
            // Calculate pixel-to-mm conversion ratio
            const calibration = MM_MEASUREMENT.calculatePixelToMmRatio(landmarks, videoWidth, videoHeight);
            
            if (!calibration) {
                console.warn('‚ö†Ô∏è Could not calibrate pixel-to-mm ratio');
                return null;
            }
            
            console.log('üìè Calibration result:', {
                ratio: calibration.pixelToMmRatio.toFixed(3),
                quality: calibration.calibrationQuality,
                confidence: calibration.confidence.toFixed(2),
                methods: calibration.methods.map(m => m.method)
            });
            
            // Calculate horizontal deviations in mm
            const deviations = MM_MEASUREMENT.calculateHorizontalDeviation(
                landmarks, videoWidth, videoHeight, calibration.pixelToMmRatio
            );
            
            const result = {
                calibration: calibration,
                measurements: deviations,
                timestamp: new Date().toISOString()
            };
            
            // Add assessment for each measurement
            if (deviations) {
                if (deviations.shoulderAlignment) {
                    deviations.shoulderAlignment.assessment = MM_MEASUREMENT.getDeviationAssessment(
                        deviations.shoulderAlignment.deviationMm
                    );
                }
                
                if (deviations.hipAlignment) {
                    deviations.hipAlignment.assessment = MM_MEASUREMENT.getDeviationAssessment(
                        deviations.hipAlignment.deviationMm
                    );
                }
            }
            
            console.log('üìê MM Measurements:', {
                shoulderDev: deviations?.shoulderAlignment ? 
                    deviations.shoulderAlignment.deviationMm.toFixed(1) + 'mm' : 'N/A',
                hipDev: deviations?.hipAlignment ? 
                    deviations.hipAlignment.deviationMm.toFixed(1) + 'mm' : 'N/A'
            });
            
            return result;
        }
        
        // Debug function to test MM measurement system
        window.debugMmMeasurements = function() {
            console.log('üìê === MM MEASUREMENT SYSTEM DEBUG ===');
            
            if (!currentPoseResults || !currentPoseResults.poseLandmarks) {
                console.error('‚ùå No current pose results available for MM measurement test');
                console.log('üí° Make sure you are in analysis mode with active pose detection');
                return null;
            }
            
            const landmarks = currentPoseResults.poseLandmarks;
            const activeVideo = document.getElementById('staticVideo') || document.getElementById('dynamicVideo');
            
            if (!activeVideo) {
                console.error('‚ùå No active video element found');
                return null;
            }
            
            const videoWidth = activeVideo.videoWidth || 640;
            const videoHeight = activeVideo.videoHeight || 480;
            
            console.log('üé• Video dimensions:', {
                width: videoWidth,
                height: videoHeight
            });
            
            // Test MM measurement calculation
            const mmResult = analyzePoseWithMmMeasurements(landmarks, videoWidth, videoHeight);
            
            if (mmResult) {
                console.log('‚úÖ MM Measurement Results:');
                console.log('üìè Calibration:', {
                    quality: mmResult.calibration.calibrationQuality,
                    confidence: (mmResult.calibration.confidence * 100).toFixed(1) + '%',
                    ratio: mmResult.calibration.pixelToMmRatio.toFixed(3) + ' mm/px',
                    methods: mmResult.calibration.methods.map(m => `${m.method} (${(m.confidence * 100).toFixed(0)}%)`)
                });
                
                if (mmResult.measurements.shoulderAlignment) {
                    const shoulder = mmResult.measurements.shoulderAlignment;
                    console.log('üë• Shoulder Alignment:', {
                        deviation: shoulder.deviationMm.toFixed(1) + 'mm',
                        higherSide: shoulder.higherShoulder,
                        assessment: shoulder.assessment.text,
                        level: shoulder.assessment.level,
                        confidence: (shoulder.confidence * 100).toFixed(1) + '%'
                    });
                }
                
                if (mmResult.measurements.hipAlignment) {
                    const hip = mmResult.measurements.hipAlignment;
                    console.log('ü¶¥ Hip Alignment:', {
                        deviation: hip.deviationMm.toFixed(1) + 'mm',
                        higherSide: hip.higherHip,
                        assessment: hip.assessment.text,
                        level: hip.assessment.level,
                        confidence: (hip.confidence * 100).toFixed(1) + '%'
                    });
                }
            } else {
                console.error('‚ùå Could not calculate MM measurements');
                console.log('üìã Landmark availability check:');
                [11, 12, 23, 24].forEach(index => {
                    const landmark = landmarks[index];
                    console.log(`  Landmark ${index}: ${landmark ? 
                        `visibility ${(landmark.visibility * 100).toFixed(0)}%` : 'missing'}`);
                });
            }
            
            return mmResult;
        };
        
        // Debug function to test photo capture with MM measurements
        window.debugPhotoWithMm = function() {
            console.log('üì∏ === PHOTO CAPTURE WITH MM MEASUREMENTS DEBUG ===');
            
            if (!currentPoseResults || !currentPoseResults.poseLandmarks) {
                console.error('‚ùå No pose results available. Please start analysis mode first.');
                return null;
            }
            
            // Test photo capture
            const photo = debugCaptureNow();
            
            if (photo && photo.mmMeasurements) {
                console.log('‚úÖ Photo captured with MM measurements:');
                console.log('üì∑ Photo info:', {
                    size: (photo.imageData.length / 1024).toFixed(1) + 'KB',
                    dimensions: `${photo.width}x${photo.height}`,
                    cameraType: photo.cameraType,
                    hasMmData: !!photo.mmMeasurements
                });
                
                const mm = photo.mmMeasurements;
                if (mm.measurements) {
                    console.log('üìê MM Measurements in photo:');
                    
                    if (mm.measurements.shoulderAlignment) {
                        console.log('üë• Shoulders:', {
                            deviation: mm.measurements.shoulderAlignment.deviationMm.toFixed(1) + 'mm',
                            assessment: mm.measurements.shoulderAlignment.assessment.text
                        });
                    }
                    
                    if (mm.measurements.hipAlignment) {
                        console.log('ü¶¥ Hips:', {
                            deviation: mm.measurements.hipAlignment.deviationMm.toFixed(1) + 'mm',
                            assessment: mm.measurements.hipAlignment.assessment.text
                        });
                    }
                }
                
                return photo;
            } else {
                console.error('‚ùå Photo capture failed or no MM measurements included');
                return null;
            }
        };
        
        // Debug function to test smart reload functionality
        window.debugSmartReload = function() {
            console.log('üîÑ === SMART RELOAD DEBUG ===');
            console.log('Current Application State:');
            console.log('- Current User:', currentUser ? currentUser.name || currentUser.id : 'None');
            console.log('- Current Screen:', currentScreen);
            console.log('- Current Facing Mode:', currentFacingMode);
            console.log('- Active Screen Elements:', document.querySelector('.app-screen.active')?.id || 'None');
            
            // Check sessionStorage
            const savedState = sessionStorage.getItem('athletecore_reload_state');
            if (savedState) {
                try {
                    const parsed = JSON.parse(savedState);
                    console.log('- Saved State in sessionStorage:', parsed);
                    console.log('  * Saved User:', parsed.user?.name || parsed.user?.id || 'None');
                    console.log('  * Saved Screen:', parsed.screen);
                    console.log('  * Saved Camera Mode:', parsed.facingMode);
                    console.log('  * Timestamp:', parsed.timestamp);
                } catch (error) {
                    console.log('- Saved State ERROR:', error.message);
                }
            } else {
                console.log('- Saved State in sessionStorage: None');
            }
            
            // Check if currently in analysis mode
            const isInAnalysis = currentScreen === 'static-analysis' || currentScreen === 'dynamic-analysis';
            console.log('- Currently in analysis mode:', isInAnalysis);
            
            console.log('üí° Commands:');
            console.log('  - debugTriggerSmartReload() : Execute smart reload');
            console.log('  - debugTestStateRestore() : Test restoration without reload');
            
            return {
                currentUser: currentUser?.name || currentUser?.id || null,
                currentScreen,
                currentFacingMode,
                activeScreenElement: document.querySelector('.app-screen.active')?.id || null,
                hasSavedState: !!savedState,
                savedStateValid: savedState ? true : false,
                isInAnalysisMode: isInAnalysis
            };
        };
        
        // Debug function to manually trigger smart reload
        // MediaPipeË®∫Êñ≠„Éá„Éê„ÉÉ„Ç∞Èñ¢Êï∞
        window.debugMediaPipe = function() {
            console.log('üîß MediaPipeË®∫Êñ≠ÈñãÂßã');
            
            console.log('üéØ Pose „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁä∂ÊÖã:', {
                poseExists: !!pose,
                poseType: typeof pose,
                poseMethods: pose ? Object.getOwnPropertyNames(pose) : null
            });
            
            // Static AnalysisË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ
            const staticVideo = document.getElementById('staticCameraFeed');
            const staticCanvas = document.getElementById('staticPoseCanvas');
            const staticStatus = document.getElementById('staticPoseStatus');
            
            console.log('üìπ Static AnalysisË¶ÅÁ¥†:', {
                video: {
                    exists: !!staticVideo,
                    videoWidth: staticVideo?.videoWidth,
                    videoHeight: staticVideo?.videoHeight,
                    readyState: staticVideo?.readyState,
                    srcObject: !!staticVideo?.srcObject
                },
                canvas: {
                    exists: !!staticCanvas,
                    width: staticCanvas?.width,
                    height: staticCanvas?.height,
                    zIndex: staticCanvas?.style.zIndex,
                    display: staticCanvas?.style.display,
                    visibility: staticCanvas?.style.visibility
                },
                status: {
                    exists: !!staticStatus,
                    hidden: staticStatus?.classList.contains('hidden')
                }
            });
            
            // Dynamic AnalysisË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ
            const dynamicVideo = document.getElementById('dynamicCameraFeed');
            const dynamicCanvas = document.getElementById('dynamicPoseCanvas');
            const dynamicStatus = document.getElementById('dynamicPoseStatus');
            
            console.log('üé¨ Dynamic AnalysisË¶ÅÁ¥†:', {
                video: {
                    exists: !!dynamicVideo,
                    videoWidth: dynamicVideo?.videoWidth,
                    videoHeight: dynamicVideo?.videoHeight,
                    readyState: dynamicVideo?.readyState,
                    srcObject: !!dynamicVideo?.srcObject
                },
                canvas: {
                    exists: !!dynamicCanvas,
                    width: dynamicCanvas?.width,
                    height: dynamicCanvas?.height,
                    zIndex: dynamicCanvas?.style.zIndex,
                    display: dynamicCanvas?.style.display,
                    visibility: dynamicCanvas?.style.visibility
                },
                status: {
                    exists: !!dynamicStatus,
                    hidden: dynamicStatus?.classList.contains('hidden')
                }
            });
            
            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
            console.log('üåê „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞Áä∂ÊÖã:', {
                currentScreen: currentScreen,
                poseDetectionInterval: !!poseDetectionInterval,
                pose: !!pose
            });
            
            console.log('üîß MediaPipeË®∫Êñ≠ÂÆå‰∫Ü - „Ç≥„É≥„ÇΩ„Éº„É´„ÅßÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        };
        
        window.debugCaptureProcess = function() {
            console.log('üé¨ ÊíÆÂΩ±„Éó„É≠„Çª„ÇπË®∫Êñ≠ÈñãÂßã');
            
            // ÁèæÂú®„ÅÆ„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§Á¢∫Ë™ç
            const staticOverlay = document.getElementById('staticCountdownOverlay');
            const dynamicOverlay = document.getElementById('dynamicCountdownOverlay');
            
            console.log('üìä „Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§Áä∂ÊÖã:', {
                staticOverlay: {
                    exists: !!staticOverlay,
                    zIndex: staticOverlay?.style.zIndex,
                    visible: staticOverlay ? !staticOverlay.classList.contains('hidden') : false
                },
                dynamicOverlay: {
                    exists: !!dynamicOverlay,
                    zIndex: dynamicOverlay?.style.zIndex,
                    visible: dynamicOverlay ? !dynamicOverlay.classList.contains('hidden') : false
                }
            });
            
            // „Éï„É´„Çπ„ÇØ„É™„Éº„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§Á¢∫Ë™ç
            const staticFullscreen = document.getElementById('staticFullscreenOverlay');
            const dynamicFullscreen = document.getElementById('dynamicFullscreenOverlay');
            
            console.log('üñ•Ô∏è „Éï„É´„Çπ„ÇØ„É™„Éº„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§Áä∂ÊÖã:', {
                staticFullscreen: {
                    exists: !!staticFullscreen,
                    zIndex: staticFullscreen?.style.zIndex
                },
                dynamicFullscreen: {
                    exists: !!dynamicFullscreen,
                    zIndex: dynamicFullscreen?.style.zIndex
                }
            });
            
            // poseDetectionIntervalÁä∂ÊÖã
            console.log('ü§ñ MediaPipeÊ§úÂá∫Áä∂ÊÖã:', {
                poseDetectionInterval: !!poseDetectionInterval,
                pose: !!pose,
                intervalActive: poseDetectionInterval ? 'ACTIVE' : 'STOPPED'
            });
            
            // CanvasË°®Á§∫Áä∂ÊÖãË©≥Á¥∞
            const staticCanvas = document.getElementById('staticPoseCanvas');
            const dynamicCanvas = document.getElementById('dynamicPoseCanvas');
            
            console.log('üé® Canvas„É™„Ç¢„É´„Çø„Ç§„É†Áä∂ÊÖã:', {
                static: {
                    exists: !!staticCanvas,
                    hidden: staticCanvas?.classList.contains('hidden'),
                    zIndex: staticCanvas?.style.zIndex,
                    display: staticCanvas?.style.display,
                    visibility: staticCanvas?.style.visibility,
                    opacity: staticCanvas?.style.opacity
                },
                dynamic: {
                    exists: !!dynamicCanvas,
                    hidden: dynamicCanvas?.classList.contains('hidden'),
                    zIndex: dynamicCanvas?.style.zIndex,
                    display: dynamicCanvas?.style.display,
                    visibility: dynamicCanvas?.style.visibility,
                    opacity: dynamicCanvas?.style.opacity
                }
            });
        };
        
        window.debugTestPoseCanvas = function() {
            console.log('üé® MediaPipe„Ç≠„É£„É≥„Éê„Çπ„ÉÜ„Çπ„ÉàÈñãÂßã');
            
            const staticCanvas = document.getElementById('staticPoseCanvas');
            const dynamicCanvas = document.getElementById('dynamicPoseCanvas');
            
            function testCanvas(canvas, name) {
                if (!canvas) {
                    console.error(`‚ùå ${name} „Ç≠„É£„É≥„Éê„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                    return;
                }
                
                console.log(`üéØ ${name} „Ç≠„É£„É≥„Éê„Çπ„ÉÜ„Çπ„Éà:`, {
                    width: canvas.width,
                    height: canvas.height,
                    zIndex: canvas.style.zIndex,
                    position: canvas.style.position,
                    visibility: canvas.style.visibility,
                    display: canvas.style.display
                });
                
                // „ÉÜ„Çπ„ÉàÊèèÁîª
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ËÉåÊôØ„ÉÜ„Çπ„Éà
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // „ÉÜ„Ç≠„Çπ„Éà„ÉÜ„Çπ„Éà
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`${name} ACTIVE`, 20, 50);
                
                // ÂÜÜ„ÉÜ„Çπ„Éà
                ctx.beginPath();
                ctx.arc(100, 100, 30, 0, 2 * Math.PI);
                ctx.fillStyle = '#FFFF00';
                ctx.fill();
                
                console.log(`‚úÖ ${name} „Ç≠„É£„É≥„Éê„Çπ„ÉÜ„Çπ„ÉàÊèèÁîªÂÆå‰∫Ü`);
            }
            
            testCanvas(staticCanvas, 'Static');
            testCanvas(dynamicCanvas, 'Dynamic');
        };
        
        window.debugTriggerSmartReload = function() {
            console.log('üîÑ Manually triggering smart reload...');
            smartReload();
        };
        
        // Debug function to test state restoration without reload
        window.debugTestStateRestore = function() {
            console.log('üîÑ Testing state restoration logic...');
            return restoreAfterSmartReload();
        };
        
        // Debug function to test navigation
        window.debugNavigation = function() {
            console.log('üß™ === NAVIGATION DEBUG ===');
            
            console.log('üîç Available screens:');
            document.querySelectorAll('.app-screen').forEach(screen => {
                console.log(`  - ${screen.id}: ${screen.classList.contains('active') ? 'ACTIVE' : 'hidden'}`);
            });
            
            console.log('üîç Testing navigation functions:');
            console.log('  - showWelcome exists:', typeof showWelcome === 'function');
            console.log('  - showRegistration exists:', typeof showRegistration === 'function');
            console.log('  - showDashboard exists:', typeof showDashboard === 'function');
            
            // Test registration screen
            console.log('üß™ Testing showRegistration...');
            try {
                showRegistration();
                console.log('‚úÖ showRegistration executed');
            } catch (error) {
                console.error('‚ùå showRegistration failed:', error);
            }
        };
        
        // Debug function to force athlete welcome display
        window.debugForceAthleteWelcome = function() {
            console.log('üèÜ === FORCE ATHLETE WELCOME ===');
            
            console.log('üîç Current screen state:');
            document.querySelectorAll('.app-screen').forEach(screen => {
                console.log(`  - ${screen.id}: ${screen.classList.contains('active') ? 'ACTIVE' : 'hidden'}`);
            });
            
            console.log('üèÜ Forcing Dior Sport Athlete Welcome...');
            showAthleteWelcome();
            
            setTimeout(() => {
                console.log('üîç After force display:');
                document.querySelectorAll('.app-screen').forEach(screen => {
                    console.log(`  - ${screen.id}: ${screen.classList.contains('active') ? 'ACTIVE' : 'hidden'}`);
                });
            }, 1000);
        };

        // Debug function to manually test continue button
        window.debugContinueButton = function() {
            console.log('üß™ === CONTINUE BUTTON TEST ===');
            
            const button = document.querySelector('#welcome button[onclick*="showRegistration"]');
            if (button) {
                console.log('‚úÖ Continue button found');
                console.log('üîç Button onclick:', button.getAttribute('onclick'));
                
                // Simulate click
                console.log('üß™ Simulating button click...');
                button.click();
            } else {
                console.error('‚ùå Continue button not found');
            }
        };

        // Debug function to test overlay alignment
        window.debugOverlayAlignment = function() {
            console.log('üéØ === OVERLAY ALIGNMENT DEBUG ===');
            
            if (!currentPoseResults || !currentPoseResults.poseLandmarks) {
                console.error('‚ùå No pose results available. Please start analysis mode first.');
                return null;
            }
            
            const activeVideo = document.getElementById('staticVideo') || document.getElementById('dynamicVideo');
            if (!activeVideo) {
                console.error('‚ùå No active video element found');
                return null;
            }
            
            const isFrontCamera = activeVideo.style.transform.includes('scaleX(-1)');
            const landmarks = currentPoseResults.poseLandmarks;
            
            console.log('üìπ Video info:', {
                id: activeVideo.id,
                videoWidth: activeVideo.videoWidth,
                videoHeight: activeVideo.videoHeight,
                isFrontCamera: isFrontCamera,
                transform: activeVideo.style.transform
            });
            
            // Test key landmark positions
            console.log('üéØ Key landmark positions (normalized):');
            [0, 11, 12, 23, 24].forEach(index => {
                const landmark = landmarks[index];
                if (landmark) {
                    const names = {0: 'nose', 11: 'leftShoulder', 12: 'rightShoulder', 23: 'leftHip', 24: 'rightHip'};
                    
                    // Calculate both display and photo coordinates
                    const displayX = isFrontCamera ? (1 - landmark.x) : landmark.x;
                    const photoX = isFrontCamera ? (1 - landmark.x) : landmark.x;
                    
                    console.log(`  ${names[index]} (${index}):`, {
                        normalized: `(${landmark.x.toFixed(3)}, ${landmark.y.toFixed(3)})`,
                        visibility: (landmark.visibility * 100).toFixed(0) + '%',
                        displayX: (displayX * activeVideo.videoWidth).toFixed(1),
                        photoX: (photoX * activeVideo.videoWidth).toFixed(1),
                        sameCoords: displayX === photoX
                    });
                }
            });
            
            // Test photo capture with overlay
            console.log('üì∏ Testing photo capture with overlay...');
            const photo = debugCaptureNow();
            
            if (photo) {
                console.log('‚úÖ Photo captured with overlay alignment test:', {
                    size: (photo.imageData.length / 1024).toFixed(1) + 'KB',
                    dimensions: `${photo.width}x${photo.height}`,
                    cameraType: photo.cameraType,
                    hasOverlay: photo.hasPoseOverlay,
                    hasMmMeasurements: !!photo.mmMeasurements
                });
                
                // Create test image element to verify
                const img = new Image();
                img.onload = function() {
                    console.log('‚úÖ Photo overlay test: Image loaded successfully');
                    console.log('üí° Check the analysis history to verify overlay alignment');
                };
                img.onerror = function() {
                    console.error('‚ùå Photo overlay test: Failed to load image');
                };
                img.src = photo.imageData;
                
                return photo;
            } else {
                console.error('‚ùå Photo capture failed during overlay alignment test');
                return null;
            }
        };
        
        function showAthleteWelcome() {
            console.log('Showing athlete welcome screen');
            showScreen('athlete-welcome');
            const athleteScreen = document.getElementById('athlete-welcome');
            if (athleteScreen) {
                athleteScreen.classList.add('fade-in');
                console.log('‚úÖ Athlete welcome screen displayed successfully');
                
                // Ëá™ÂãïÈÅ∑Áßª„ÇíÈò≤„Åê„Åü„ÇÅ„ÄÅÁèæÂú®„ÅÆÁîªÈù¢„ÇíÊòéÁ¢∫„Å´Ë®≠ÂÆö
                currentScreen = 'athlete-welcome';
                
                // Dior Sport „Ç®„É¨„Ç¨„É≥„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÜçÈÅ©Áî®
                setTimeout(() => {
                    const elements = athleteScreen.querySelectorAll('.dior-fade-in, .dior-slide-up, .dior-line-draw, .dior-geometric-float');
                    elements.forEach((el, index) => {
                        el.style.animation = 'none';
                        setTimeout(() => {
                            el.style.animation = '';
                        }, 50 + index * 100);
                    });
                }, 100);
            } else {
                console.error('‚ùå Athlete welcome screen element not found');
            }
        }
        
        function showWelcome() {
            console.log('Showing welcome screen');
            showScreen('welcome');
            const welcomeScreen = document.getElementById('welcome');
            welcomeScreen.classList.add('fade-in');
            // Dior Sport „Ç®„É¨„Ç¨„É≥„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÜçÈÅ©Áî®
            setTimeout(() => {
                const elements = welcomeScreen.querySelectorAll('.dior-fade-in, .dior-slide-up, .dior-line-draw');
                elements.forEach((el, index) => {
                    el.style.animation = 'none';
                    setTimeout(() => {
                        el.style.animation = '';
                    }, 50 + index * 100);
                });
            }, 100);
        }
        
        function showRegistration() {
            console.log('Showing registration screen');
            try {
                showScreen('registration');
                const regScreen = document.getElementById('registration');
                if (regScreen) {
                    regScreen.classList.add('slide-up');
                    console.log('‚úÖ Registration screen displayed successfully');
                    // Dior Sport „Ç®„É¨„Ç¨„É≥„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÜçÈÅ©Áî®
                    setTimeout(() => {
                        const elements = regScreen.querySelectorAll('.dior-fade-in, .dior-slide-up, .dior-line-draw');
                        elements.forEach((el, index) => {
                            el.style.animation = 'none';
                            setTimeout(() => {
                                el.style.animation = '';
                            }, 50 + index * 100);
                        });
                    }, 100);
                } else {
                    console.error('‚ùå Registration screen element not found');
                }
            } catch (error) {
                console.error('‚ùå Error showing registration screen:', error);
            }
        }
        
        function showDashboard() {
            console.log('Showing dashboard screen');
            
            try {
                // Exit any fullscreen mode first
                exitFullscreenMode('static');
                exitFullscreenMode('dynamic');
                
                // Stop camera and pose detection if running
                if (typeof stopCamera === 'function') stopCamera();
                if (typeof stopPoseDetection === 'function') stopPoseDetection();
                if (typeof isAnalyzing !== 'undefined') isAnalyzing = false;
                
                showScreen('dashboard');
                const dashScreen = document.getElementById('dashboard');
                if (dashScreen) {
                    dashScreen.classList.add('fade-in');
                    console.log('‚úÖ Dashboard screen displayed successfully');
                    // Dior Sport „Ç®„É¨„Ç¨„É≥„Éà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆÂÜçÈÅ©Áî®
                    setTimeout(() => {
                        const elements = dashScreen.querySelectorAll('.dior-fade-in, .dior-slide-up, .dior-line-draw');
                        elements.forEach((el, index) => {
                            el.style.animation = 'none';
                            setTimeout(() => {
                                el.style.animation = '';
                            }, 50 + index * 100);
                        });
                    }, 100);
                } else {
                    console.error('‚ùå Dashboard screen element not found');
                }
                
                if (typeof updateDashboardContent === 'function') {
                    updateDashboardContent();
                } else {
                    console.warn('‚ö†Ô∏è updateDashboardContent function not found');
                }
            } catch (error) {
                console.error('‚ùå Error showing dashboard screen:', error);
            }
        }

        // „Çµ„Éº„Éì„Çπ„ÉØ„Éº„Ç´„Éº„ÅÆÁôªÈå≤
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Initialize audio systems
                initializeVoices();
                initializeAudioContext();
                
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('AthleteCore Pro: „Çµ„Éº„Éì„Çπ„ÉØ„Éº„Ç´„Éº„ÅåÁôªÈå≤„Åï„Çå„Åæ„Åó„Åü', registration.scope);
                        
                        // Êõ¥Êñ∞„ÉÅ„Çß„ÉÉ„ÇØ
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅåÂà©Áî®ÂèØËÉΩ
                                    showUpdateAvailable();
                                }
                            });
                        });
                    })
                    .catch(error => {
                        console.log('„Çµ„Éº„Éì„Çπ„ÉØ„Éº„Ç´„Éº„ÅÆÁôªÈå≤„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
                    });
            });
        }

        // PWA„Ç§„É≥„Çπ„Éà„Éº„É´„Éó„É≠„É≥„Éó„Éà
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallPrompt();
        });

        // „Ç§„É≥„Çπ„Éà„Éº„É´ÂÆå‰∫Ü„ÅÆÊ§úÂá∫
        window.addEventListener('appinstalled', () => {
            console.log('AthleteCore Pro: „Ç¢„Éó„É™„Åå„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Åæ„Åó„Åü');
            isInstalled = true;
            hideInstallPrompt();
        });

        // „Çπ„Çø„É≥„Éâ„Ç¢„É≠„Éº„É≥„É¢„Éº„Éâ„ÅÆÊ§úÂá∫
        if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
            isInstalled = true;
            document.body.classList.add('installed');
        }

        // Test function availability - should all be 'function'
        console.log('‚úÖ Function availability check:', {
            showScreen: typeof showScreen,
            showWelcome: typeof showWelcome, 
            showRegistration: typeof showRegistration,
            showDashboard: typeof showDashboard
        });
        
        // Test button click handler
        setTimeout(() => {
            const button = document.querySelector('button[onclick*="showRegistration"]');
            console.log('‚úÖ Get Started button found:', !!button);
            if (button) {
                console.log('‚úÖ Button onclick attribute:', button.getAttribute('onclick'));
            }
        }, 1000);
        
        // Add global error handlers to prevent app crashes
        window.addEventListener('error', (event) => {
            console.error('üö® Uncaught error detected:', event.error);
            console.error('Error details:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
            
            // Prevent default error handling that might cause page navigation
            event.preventDefault();
            
            // Show user-friendly message
            showToast('‚ö†Ô∏è An error occurred - app stability maintained / „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„Åå„ÄÅ„Ç¢„Éó„É™„ÅØÂÆâÂÆöÂãï‰Ωú„ÇíÁ∂ôÁ∂ö„Åó„Å¶„ÅÑ„Åæ„Åô', 'warning');
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('üö® Unhandled promise rejection:', event.reason);
            
            // Prevent default rejection handling
            event.preventDefault();
            
            // Show user-friendly message for promise rejections
            showToast('‚ö†Ô∏è Operation failed - please try again / Êìç‰Ωú„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü„ÄÅÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ', 'warning');
        });
        
        // Initialize app
        setTimeout(async () => {
            try {
                // Check if smart reload restoration is in progress
                const isSmartReloadInProgress = sessionStorage.getItem('athletecore_reload_state');
            
            if (!isSmartReloadInProgress) {
                console.log('üîÑ Normal app initialization - no smart reload detected');
                loadLocalUser();
                
                // Á¢∫ÂÆü„Å´„Ç¢„Çπ„É™„Éº„Éà„Ç¶„Çß„É´„Ç´„É†ÁîªÈù¢„ÇíË°®Á§∫ÔºàÈÅÖÂª∂„ÇíÁü≠Á∏ÆÔºâ
                console.log('üèÜ Displaying Dior Sport Athlete Welcome screen...');
                showAthleteWelcome();
            } else {
                console.log('üîÑ Smart reload detected - skipping normal welcome flow');
                // Still initialize essential components
                loadLocalUser();
            }
            
            // Add click event listeners to enable speech on user interaction
            document.addEventListener('click', enableSpeech, { once: false });
            document.addEventListener('touchstart', enableSpeech, { once: false });
            
            // Initialize MediaPipe Pose detection (in background)
            initMediaPipe().then(initialized => {
                if (initialized) {
                    console.log('‚úÖ MediaPipe Pose initialized successfully in main app');
                } else {
                    console.error('‚ùå Failed to initialize MediaPipe Pose in main app');
                }
            }).catch(error => {
                console.error('Failed to initialize MediaPipe Pose:', error);
                
                // Show user-friendly error message and prevent app crash
                showToast('‚ö†Ô∏è MediaPipe initialization failed - app may have limited functionality / MediaPipeÂàùÊúüÂåñ„Å´Â§±Êïó„ÄÅÊ©üËÉΩÂà∂Èôê„ÅÆÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô', 'warning');
                
                // Set a flag to indicate MediaPipe is not available
                window.mediaPipeInitializationFailed = true;
                
                // Don't crash the app - continue with limited functionality
                console.log('üîÑ Continuing app initialization without MediaPipe...');
            });
            
            } catch (initError) {
                console.error('üö® Critical error during app initialization:', initError);
                
                // Show critical error message but try to continue
                showToast('üö® App initialization error - some features may be unavailable / „Ç¢„Éó„É™ÂàùÊúüÂåñ„Ç®„É©„Éº„ÄÅ‰∏ÄÈÉ®Ê©üËÉΩ„ÅåÂà©Áî®„Åß„Åç„Å™„ÅÑÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô', 'error');
                
                // Attempt basic fallback initialization
                try {
                    loadLocalUser();
                    showAthleteWelcome();
                    console.log('‚úÖ Fallback initialization completed');
                } catch (fallbackError) {
                    console.error('‚ùå Even fallback initialization failed:', fallbackError);
                    // Last resort - show a basic message
                    document.body.innerHTML = `
                        <div style="padding: 20px; text-align: center; font-family: Arial, sans-serif;">
                            <h1 style="color: #dc2626;">AthleteCore Pro</h1>
                            <p style="color: #374151;">Sorry, the app encountered an initialization error. Please refresh the page.</p>
                            <p style="color: #6b7280;">Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÅ„Ç¢„Éó„É™„ÅÆÂàùÊúüÂåñ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„Çí„É™„Éï„É¨„ÉÉ„Ç∑„É•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
                            <button onclick="window.location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #2563eb; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                Refresh / „É™„Éï„É¨„ÉÉ„Ç∑„É•
                            </button>
                        </div>
                    `;
                }
            }
        }, 2000);
        
        // Camera functions
        let cameraStream = null;
        let currentFacingMode = 'user'; // 'user' = front/„Ç§„É≥„Ç´„É°„É©, 'environment' = back/„Ç¢„Ç¶„Éà„Ç´„É°„É©
        let currentVideoElementId = null;
        
        async function initCamera(videoElementId, placeholderId, facingMode = 'user') {
            try {
                console.log('üé• Initializing camera:', videoElementId, facingMode);
                
                // Stop existing stream if any
                if (cameraStream) {
                    console.log('üîÑ Stopping existing camera stream');
                    cameraStream.getTracks().forEach(track => track.stop());
                }
                
                // More explicit constraints for better camera switching
                const constraints = {
                    video: {
                        facingMode: { exact: facingMode },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
                
                console.log('üìã Camera constraints:', constraints);
                
                let stream;
                try {
                    // Try with exact constraint first
                    console.log('üîç Trying exact facingMode constraint...');
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('‚úÖ Camera access granted with exact constraint');
                } catch (exactError) {
                    console.log('‚ö†Ô∏è Exact facingMode failed, trying ideal:', exactError);
                    // Fallback to ideal constraint
                    constraints.video.facingMode = { ideal: facingMode };
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('‚úÖ Camera access granted with ideal constraint');
                }
                
                const videoElement = document.getElementById(videoElementId);
                const placeholder = document.getElementById(placeholderId);
                
                if (!videoElement || !placeholder) {
                    console.error('‚ùå Video elements not found:', videoElementId, placeholderId);
                    return false;
                }
                
                console.log('üì± Video element found:', videoElement);
                console.log('üñºÔ∏è Placeholder element found:', placeholder);
                
                // Check actual camera facing mode from stream
                const videoTrack = stream.getVideoTracks()[0];
                const actualSettings = videoTrack.getSettings();
                const actualFacingMode = actualSettings.facingMode || facingMode;
                
                console.log('üìä Camera settings:', actualSettings);
                console.log('üéØ Requested facingMode:', facingMode, 'Actual facingMode:', actualFacingMode);
                
                // CRITICAL: Set video source
                videoElement.srcObject = stream;
                console.log('üîó Video srcObject set');
                
                // Force show video with explicit styling and ensure visibility
                videoElement.style.display = 'block';
                videoElement.style.visibility = 'visible';
                videoElement.style.opacity = '1';
                videoElement.style.position = 'absolute';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.objectFit = 'cover';
                videoElement.style.zIndex = '5'; // Higher z-index to ensure video is above placeholder
                videoElement.style.transform = actualFacingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';
                videoElement.classList.remove('hidden');
                
                console.log('üëÅÔ∏è Video visibility forced - display:', videoElement.style.display, 'visibility:', videoElement.style.visibility);
                
                // Force hide placeholder completely
                placeholder.style.display = 'none';
                placeholder.style.visibility = 'hidden';
                placeholder.style.opacity = '0';
                placeholder.style.zIndex = '0';
                placeholder.classList.add('hidden');
                
                console.log('üö´ Placeholder hidden');
                
                cameraStream = stream;
                currentFacingMode = actualFacingMode; // Use actual facing mode
                currentVideoElementId = videoElementId;
                
                // Update camera label with actual facing mode
                updateCameraLabel(videoElementId, actualFacingMode);
                
                // Start pose detection when camera is ready - with multiple triggers
                videoElement.onloadedmetadata = () => {
                    console.log('üìπ Video metadata loaded - dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                    const canvasElementId = videoElementId.replace('CameraFeed', 'PoseCanvas');
                    const statusElementId = videoElementId.includes('static') ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Start pose detection with a small delay to ensure video is fully ready
                    setTimeout(() => {
                        startPoseDetection(videoElementId, canvasElementId, statusElementId);
                    }, 500);
                };
                
                // Additional trigger when video can play
                videoElement.oncanplay = () => {
                    console.log('‚ñ∂Ô∏è Video can play - ensuring pose detection is running');
                    const canvasElementId = videoElementId.replace('CameraFeed', 'PoseCanvas');
                    const statusElementId = videoElementId.includes('static') ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Only start if not already running
                    if (!poseDetectionInterval) {
                        setTimeout(() => {
                            startPoseDetection(videoElementId, canvasElementId, statusElementId);
                        }, 200);
                    }
                };
                
                // Add additional debug event listeners
                videoElement.oncanplay = () => {
                    console.log('‚ñ∂Ô∏è Video can play');
                };
                
                videoElement.onplaying = () => {
                    console.log('üé¨ Video playing');
                };
                
                videoElement.onerror = (error) => {
                    console.error('‚ùå Video error:', error);
                };
                
                console.log('‚úÖ Camera initialized successfully with actual facingMode:', actualFacingMode);
                return true;
            } catch (error) {
                console.error('‚ùå Camera access denied or unavailable:', error);
                
                // Show error in placeholder
                const placeholder = document.getElementById(placeholderId);
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div class="text-center text-white">
                            <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                            <p class="text-xl mb-2">Camera access denied</p>
                            <p class="text-sm opacity-75">„Ç´„É°„É©„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åó„Åü</p>
                            <p class="text-xs opacity-50 mt-2">${error.message}</p>
                        </div>
                    `;
                }
                return false;
            }
        }
        
        // Switch between front and back camera
        async function switchCamera(screenType) {
            if (!cameraStream) return;
            
            const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            
            // Determine video element IDs based on screen type
            const videoElementId = screenType === 'static' ? 'staticCameraFeed' : 'dynamicCameraFeed';
            const placeholderId = screenType === 'static' ? 'staticCameraPlaceholder' : 'dynamicCameraPlaceholder';
            
            // Add switching animation
            const switchButton = document.getElementById(`${screenType}CameraSwitch`);
            switchButton.style.transform = 'rotate(180deg)';
            
            try {
                // Initialize camera with new facing mode
                const success = await initCamera(videoElementId, placeholderId, newFacingMode);
                
                if (success) {
                    // Restart pose detection with new camera
                    const canvasElementId = screenType === 'static' ? 'staticPoseCanvas' : 'dynamicPoseCanvas';
                    const statusElementId = screenType === 'static' ? 'staticPoseStatus' : 'dynamicPoseStatus';
                    
                    // Small delay to ensure video is ready
                    setTimeout(() => {
                        startPoseDetection(videoElementId, canvasElementId, statusElementId);
                    }, 500);
                    
                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }
            } catch (error) {
                console.error('Failed to switch camera:', error);
                // Revert button animation on error
                switchButton.style.transform = 'rotate(0deg)';
            }
            
            // Reset button animation
            setTimeout(() => {
                switchButton.style.transform = 'rotate(0deg)';
            }, 300);
        }
        
        // Update camera label text
        function updateCameraLabel(videoElementId, facingMode) {
            const screenType = videoElementId.includes('static') ? 'static' : 'dynamic';
            const labelElement = document.getElementById(`${screenType}CameraLabel`);
            
            console.log('üè∑Ô∏è Updating camera label for:', screenType, 'facingMode:', facingMode);
            
            // Update global currentFacingMode to ensure consistency
            currentFacingMode = facingMode;
            console.log('üîÑ Updated global currentFacingMode to:', currentFacingMode);
            
            if (labelElement) {
                if (facingMode === 'user') {
                    labelElement.textContent = '„Ç§„É≥„Ç´„É°„É©';
                    labelElement.classList.remove('bg-orange-500');
                    labelElement.classList.add('bg-black');
                } else {
                    labelElement.textContent = '„Ç¢„Ç¶„Éà„Ç´„É°„É©';
                    labelElement.classList.remove('bg-black');
                    labelElement.classList.add('bg-orange-500');
                }
                console.log('üè∑Ô∏è Label updated:', labelElement.textContent);
            }
            
            // Update video mirror effect - ENSURE video is visible first
            const videoElement = document.getElementById(videoElementId);
            if (videoElement) {
                // Force video to be visible before applying transform
                videoElement.style.display = 'block';
                videoElement.style.visibility = 'visible';
                videoElement.style.opacity = '1';
                
                if (facingMode === 'user') {
                    videoElement.style.transform = 'scaleX(-1)'; // Mirror for front camera
                    console.log('ü™û Applied mirror effect for front camera');
                } else {
                    videoElement.style.transform = 'scaleX(1)'; // Normal for back camera
                    console.log('üìπ Applied normal orientation for back camera');
                }
                
                // Store facing mode as data attribute for reliable detection
                videoElement.setAttribute('data-facing-mode', facingMode);
                
                console.log('üì∫ Video element updated:', {
                    display: videoElement.style.display,
                    visibility: videoElement.style.visibility,
                    opacity: videoElement.style.opacity,
                    transform: videoElement.style.transform,
                    dataFacingMode: videoElement.getAttribute('data-facing-mode')
                });
            } else {
                console.error('‚ùå Video element not found:', videoElementId);
            }
            
            // Update button text for static analysis based on camera type
            if (screenType === 'static') {
                const captureText = document.getElementById('staticCaptureText');
                const floatingText = document.getElementById('floatingStaticText');
                if (facingMode === 'user') {
                    if (captureText) captureText.textContent = 'Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã';
                    if (floatingText) floatingText.textContent = 'Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã';
                } else {
                    if (captureText) captureText.textContent = 'Capture Photo / ÂÜôÁúüÊíÆÂΩ±';
                    if (floatingText) floatingText.textContent = 'Capture Photo / ÂÜôÁúüÊíÆÂΩ±';
                }
            }
        }
        
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
        }
        
        // Photo Capture Functions
        function capturePhoto(videoElementId, canvasElementId, includeOverlay = true) {
            console.log('üì∏ Capturing photo from:', videoElementId);
            
            const video = document.getElementById(videoElementId);
            const overlayCanvas = document.getElementById(canvasElementId);
            
            // More reliable camera type detection using multiple methods
            const dataFacingMode = video ? video.getAttribute('data-facing-mode') : null;
            const transformBasedDetection = video && video.style.transform.includes('scaleX(-1)');
            const isFrontCamera = currentFacingMode === 'user' || dataFacingMode === 'user' || transformBasedDetection;
            
            console.log('üîç Photo capture elements check:', {
                videoElement: !!video,
                videoWidth: video ? video.videoWidth : 'N/A',
                videoHeight: video ? video.videoHeight : 'N/A',
                videoReadyState: video ? video.readyState : 'N/A',
                videoCurrentTime: video ? video.currentTime : 'N/A',
                videoSrcObject: video ? !!video.srcObject : false,
                overlayCanvas: !!overlayCanvas,
                includeOverlay: includeOverlay,
                currentPoseResults: !!currentPoseResults,
                poseLandmarks: currentPoseResults ? !!currentPoseResults.poseLandmarks : false,
                currentFacingMode: currentFacingMode,
                dataFacingMode: dataFacingMode,
                transformBasedDetection: transformBasedDetection,
                detectedAsFront: isFrontCamera
            });
            
            // Enhanced video readiness check with multiple conditions
            if (!video || !video.srcObject) {
                console.error('‚ùå Video or srcObject missing');
                return null;
            }
            
            // Wait for video to have actual frame data
            if (video.readyState < 3 || video.videoWidth === 0 || video.videoHeight === 0 || video.currentTime === 0) {
                console.warn('‚è≥ Video not fully ready, waiting and retrying...', {
                    readyState: video.readyState,
                    readyStateText: getReadyStateText(video.readyState),
                    videoWidth: video.videoWidth,
                    videoHeight: video.videoHeight,
                    currentTime: video.currentTime
                });
                
                // Return a promise that resolves after video is ready
                return new Promise((resolve) => {
                    let retryCount = 0;
                    const maxRetries = 10;
                    
                    const checkVideoReady = () => {
                        retryCount++;
                        console.log(`üìπ Video ready check attempt ${retryCount}/${maxRetries}:`, {
                            readyState: video.readyState,
                            videoWidth: video.videoWidth,
                            videoHeight: video.videoHeight,
                            currentTime: video.currentTime
                        });
                        
                        if (video.readyState >= 3 && video.videoWidth > 0 && video.videoHeight > 0 && video.currentTime > 0) {
                            console.log('‚úÖ Video is now ready for capture');
                            // Small additional delay to ensure frame is painted
                            setTimeout(() => {
                                resolve(capturePhoto(videoElementId, canvasElementId, includeOverlay));
                            }, 100);
                        } else if (retryCount < maxRetries) {
                            setTimeout(checkVideoReady, 200);
                        } else {
                            console.error('‚ùå Video failed to become ready after maximum retries');
                            resolve(null);
                        }
                    };
                    
                    checkVideoReady();
                });
            }
            
            // Create a new canvas for the photo
            const captureCanvas = document.createElement('canvas');
            const ctx = captureCanvas.getContext('2d');
            
            // Set canvas size to match video
            captureCanvas.width = video.videoWidth;
            captureCanvas.height = video.videoHeight;
            
            console.log('üéØ Capture canvas size:', captureCanvas.width, 'x', captureCanvas.height);
            console.log('üì∑ Camera type detection result:', {
                currentFacingMode: currentFacingMode,
                dataFacingMode: dataFacingMode,
                videoTransform: video.style.transform,
                transformBasedDetection: transformBasedDetection,
                finalDetection: isFrontCamera ? 'front' : 'back'
            });
            
            // Save context state
            ctx.save();
            
            // Enhanced drawing with proper handling
            try {
                // Create a temporary canvas to test video frame
                const testCanvas = document.createElement('canvas');
                const testCtx = testCanvas.getContext('2d');
                testCanvas.width = 100;
                testCanvas.height = 100;
                testCtx.drawImage(video, 0, 0, 100, 100);
                const testData = testCtx.getImageData(0, 0, 100, 100);
                
                // Check if video frame has actual data (not all black)
                let hasData = false;
                for (let i = 0; i < testData.data.length; i += 4) {
                    if (testData.data[i] > 10 || testData.data[i + 1] > 10 || testData.data[i + 2] > 10) {
                        hasData = true;
                        break;
                    }
                }
                
                if (!hasData) {
                    console.error('‚ùå Video frame appears to be black/empty');
                    ctx.restore();
                    return null;
                }
                
                console.log('‚úÖ Video frame has actual image data');
                
                if (isFrontCamera) {
                    // For front camera, capture without mirroring to get natural orientation
                    console.log('ü™û Capturing front camera (unmirrored)');
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                } else {
                    // For back camera, draw normally
                    console.log('üì∑ Capturing back camera (normal)');
                    ctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
                }
                
                console.log('‚úÖ Video frame drawn successfully');
                
            } catch (drawError) {
                console.error('‚ùå Error drawing video frame:', drawError);
                ctx.restore();
                return null;
            }
            
            // Restore context after drawing video
            ctx.restore();
            
            // Draw pose overlay if available and requested
            if (includeOverlay && overlayCanvas && currentPoseResults && currentPoseResults.poseLandmarks) {
                console.log('üé® Adding pose overlay to captured photo');
                try {
                    // Pass correct camera type information for proper coordinate transformation
                    drawPoseOverlayOnPhoto(ctx, currentPoseResults.poseLandmarks, captureCanvas, isFrontCamera);
                    console.log('‚úÖ Pose overlay added successfully');
                } catch (overlayError) {
                    console.error('‚ùå Error adding pose overlay:', overlayError);
                    // Continue without overlay
                }
            }
            
            // Convert to base64 with error handling
            let photoData;
            try {
                photoData = captureCanvas.toDataURL('image/jpeg', 0.85);
                console.log('‚úÖ Photo captured successfully, size:', (photoData.length / 1024).toFixed(1), 'KB');
                
                // Verify the image is not just black by checking if it's too small
                if (photoData.length < 15000) { // Increased threshold
                    console.warn('‚ö†Ô∏è Captured image seems very small, might be black/empty. Size:', photoData.length);
                    // Try to validate image content
                    const img = new Image();
                    img.onload = function() {
                        console.log('üñºÔ∏è Image validation: Image loaded successfully');
                    };
                    img.onerror = function() {
                        console.error('‚ùå Image validation: Failed to load captured image');
                    };
                    img.src = photoData;
                }
                
            } catch (encodeError) {
                console.error('‚ùå Error converting to base64:', encodeError);
                return null;
            }
            
            // Calculate mm measurements if pose data is available
            let mmMeasurements = null;
            if (currentPoseResults && currentPoseResults.poseLandmarks) {
                mmMeasurements = analyzePoseWithMmMeasurements(
                    currentPoseResults.poseLandmarks, 
                    captureCanvas.width, 
                    captureCanvas.height
                );
            }
            
            return {
                imageData: photoData,
                width: captureCanvas.width,
                height: captureCanvas.height,
                timestamp: new Date().toISOString(),
                hasPoseOverlay: includeOverlay && currentPoseResults && currentPoseResults.poseLandmarks,
                cameraType: isFrontCamera ? 'front' : 'back',
                actualFacingMode: currentFacingMode, // Include actual facing mode for debugging
                mmMeasurements: mmMeasurements, // Include mm-based posture measurements
                detectionMethod: {
                    currentFacingMode: currentFacingMode,
                    dataFacingMode: dataFacingMode,
                    transformBasedDetection: transformBasedDetection
                }
            };
        }
        
        // Helper function to get readable ready state
        function getReadyStateText(readyState) {
            const states = {
                0: 'HAVE_NOTHING',
                1: 'HAVE_METADATA', 
                2: 'HAVE_CURRENT_DATA',
                3: 'HAVE_FUTURE_DATA',
                4: 'HAVE_ENOUGH_DATA'
            };
            return states[readyState] || 'UNKNOWN';
        }
        
        // Draw pose overlay on captured photo
        function drawPoseOverlayOnPhoto(ctx, landmarks, canvas, isFrontCamera) {
            console.log('üé® Drawing pose overlay on photo', {
                isFrontCamera: isFrontCamera,
                canvasSize: `${canvas.width}x${canvas.height}`,
                landmarkCount: landmarks.length
            });
            
            // Save current context state
            ctx.save();
            
            // Draw skeleton connections - use same coordinate transformation as realtime display
            ctx.strokeStyle = '#00FF00'; // Bright green for photo
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            POSE_CONNECTIONS.forEach(connection => {
                const start = landmarks[connection[0]];
                const end = landmarks[connection[1]];
                
                if (start && end && start.visibility > 0.3 && end.visibility > 0.3) {
                    ctx.beginPath();
                    
                    // Use same coordinate transformation as realtime display
                    // For front camera photo: landmarks need to be mirrored to match the unmirrored photo
                    const startX = isFrontCamera ? (1 - start.x) * canvas.width : start.x * canvas.width;
                    const startY = start.y * canvas.height;
                    const endX = isFrontCamera ? (1 - end.x) * canvas.width : end.x * canvas.width;
                    const endY = end.y * canvas.height;
                    
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
            
            // Draw landmark points
            ctx.fillStyle = '#FFFF00'; // Bright yellow for photo points
            landmarks.forEach((landmark, index) => {
                if (landmark.visibility > 0.3) {
                    // Use same coordinate transformation as realtime display
                    const x = isFrontCamera ? (1 - landmark.x) * canvas.width : landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Add numbers for key landmarks
                    if ([0, 11, 12, 23, 24].includes(index)) {
                        ctx.fillStyle = '#000000';
                        ctx.font = 'bold 16px Arial';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 4;
                        ctx.strokeText(index.toString(), x + 12, y + 6);
                        ctx.fillText(index.toString(), x + 12, y + 6);
                        ctx.fillStyle = '#FFFF00';
                    }
                }
            });
            
            // Draw vertical reference lines from hip center
            drawVerticalReferenceLinesOnPhoto(ctx, landmarks, canvas, isFrontCamera);
            
            // Draw MM measurements overlay
            drawMmMeasurementsOnPhoto(ctx, landmarks, canvas, isFrontCamera);
            
            // Restore context state
            ctx.restore();
            
            console.log('‚úÖ Pose overlay drawn successfully on photo');
        }
        
        // Draw vertical reference lines on photo
        function drawVerticalReferenceLinesOnPhoto(ctx, landmarks, canvas, isFrontCamera) {
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const nose = landmarks[0];
            
            if (leftHip && rightHip && leftHip.visibility > 0.3 && rightHip.visibility > 0.3) {
                // Calculate hip center using same coordinate transformation as overlay
                const leftHipX = isFrontCamera ? (1 - leftHip.x) * canvas.width : leftHip.x * canvas.width;
                const rightHipX = isFrontCamera ? (1 - rightHip.x) * canvas.width : rightHip.x * canvas.width;
                const hipCenterX = (leftHipX + rightHipX) / 2;
                const hipCenterY = ((leftHip.y + rightHip.y) / 2) * canvas.height;
                
                // Vertical reference line style for photo
                ctx.strokeStyle = '#FF0080'; // Bright magenta for photo
                ctx.lineWidth = 3;
                ctx.setLineDash([12, 6]); // Larger dash pattern for photo
                
                // Draw vertical lines
                ctx.beginPath();
                ctx.moveTo(hipCenterX, 0);
                ctx.lineTo(hipCenterX, canvas.height);
                ctx.stroke();
                
                // Draw hip center point
                ctx.setLineDash([]);
                ctx.fillStyle = '#FF0080';
                ctx.beginPath();
                ctx.arc(hipCenterX, hipCenterY, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Hip center label
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px Arial';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText('HIP CENTER', hipCenterX + 15, hipCenterY + 5);
                ctx.fillText('HIP CENTER', hipCenterX + 15, hipCenterY + 5);
                
                // Draw deviation line if nose is visible
                if (nose && nose.visibility > 0.3) {
                    const noseX = isFrontCamera ? (1 - nose.x) * canvas.width : nose.x * canvas.width;
                    const noseY = nose.y * canvas.height;
                    
                    ctx.strokeStyle = '#00FFFF'; // Cyan for deviation line
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 3]);
                    
                    ctx.beginPath();
                    ctx.moveTo(noseX, noseY);
                    ctx.lineTo(hipCenterX, noseY);
                    ctx.stroke();
                    
                    // Deviation measurement
                    const deviationPx = Math.abs(noseX - hipCenterX);
                    const deviationPercent = (deviationPx / canvas.width * 100).toFixed(1);
                    
                    if (deviationPx > 15) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 16px Arial';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        
                        const textX = Math.min(noseX, hipCenterX) + Math.abs(noseX - hipCenterX) / 2;
                        const textY = noseY - 15;
                        
                        ctx.strokeText(`${deviationPercent}%`, textX, textY);
                        ctx.fillText(`${deviationPercent}%`, textX, textY);
                    }
                }
            }
            
            ctx.setLineDash([]); // Reset dash pattern
        }
        
        // Draw MM measurements on photo
        function drawMmMeasurementsOnPhoto(ctx, landmarks, canvas, isFrontCamera) {
            console.log('üìê Drawing MM measurements on photo');
            
            // Calculate mm measurements
            const mmData = analyzePoseWithMmMeasurements(landmarks, canvas.width, canvas.height);
            
            if (!mmData || !mmData.measurements) {
                console.log('‚ö†Ô∏è No MM measurement data available for photo overlay');
                return;
            }
            
            const measurements = mmData.measurements;
            
            // Save context state
            ctx.save();
            
            // Setup text style for measurements
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.lineWidth = 4;
            
            let textY = 40; // Starting Y position for text labels
            
            // Draw shoulder measurement
            if (measurements.shoulderAlignment) {
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                const shoulder = measurements.shoulderAlignment;
                
                if (leftShoulder && rightShoulder) {
                    // Calculate display positions using same coordinate transformation
                    const leftX = isFrontCamera ? (1 - leftShoulder.x) * canvas.width : leftShoulder.x * canvas.width;
                    const leftY = leftShoulder.y * canvas.height;
                    const rightX = isFrontCamera ? (1 - rightShoulder.x) * canvas.width : rightShoulder.x * canvas.width;
                    const rightY = rightShoulder.y * canvas.height;
                    const centerX = (leftX + rightX) / 2;
                    
                    // Draw horizontal alignment line between shoulders
                    ctx.strokeStyle = shoulder.assessment.color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 4]);
                    
                    ctx.beginPath();
                    ctx.moveTo(leftX, leftY);
                    ctx.lineTo(rightX, rightY);
                    ctx.stroke();
                    
                    // Draw measurement label with background
                    const text = `ËÇ©: ${shoulder.deviationMm.toFixed(1)}mm ${shoulder.assessment.text}`;
                    const textWidth = ctx.measureText(text).width;
                    
                    // Background rectangle
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(centerX - textWidth/2 - 10, Math.min(leftY, rightY) - 35, textWidth + 20, 25);
                    
                    // Text with stroke for visibility
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.strokeText(text, centerX, Math.min(leftY, rightY) - 15);
                    ctx.fillText(text, centerX, Math.min(leftY, rightY) - 15);
                    
                    // Draw arrow pointing to higher shoulder
                    const arrowX = shoulder.higherShoulder === 'left' ? leftX : rightX;
                    const arrowY = shoulder.higherShoulder === 'left' ? leftY : rightY;
                    drawArrow(ctx, arrowX, arrowY - 10, arrowX, arrowY + 5, shoulder.assessment.color);
                }
            }
            
            // Draw hip measurement
            if (measurements.hipAlignment) {
                const leftHip = landmarks[23];
                const rightHip = landmarks[24];
                const hip = measurements.hipAlignment;
                
                if (leftHip && rightHip) {
                    // Calculate display positions using same coordinate transformation
                    const leftX = isFrontCamera ? (1 - leftHip.x) * canvas.width : leftHip.x * canvas.width;
                    const leftY = leftHip.y * canvas.height;
                    const rightX = isFrontCamera ? (1 - rightHip.x) * canvas.width : rightHip.x * canvas.width;
                    const rightY = rightHip.y * canvas.height;
                    const centerX = (leftX + rightX) / 2;
                    
                    // Draw horizontal alignment line between hips
                    ctx.strokeStyle = hip.assessment.color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([8, 4]);
                    
                    ctx.beginPath();
                    ctx.moveTo(leftX, leftY);
                    ctx.lineTo(rightX, rightY);
                    ctx.stroke();
                    
                    // Draw measurement label with background
                    const text = `ËÖ∞: ${hip.deviationMm.toFixed(1)}mm ${hip.assessment.text}`;
                    const textWidth = ctx.measureText(text).width;
                    
                    // Background rectangle
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(centerX - textWidth/2 - 10, Math.min(leftY, rightY) - 35, textWidth + 20, 25);
                    
                    // Text with stroke for visibility
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.strokeText(text, centerX, Math.min(leftY, rightY) - 15);
                    ctx.fillText(text, centerX, Math.min(leftY, rightY) - 15);
                    
                    // Draw arrow pointing to higher hip
                    const arrowX = hip.higherHip === 'left' ? leftX : rightX;
                    const arrowY = hip.higherHip === 'left' ? leftY : rightY;
                    drawArrow(ctx, arrowX, arrowY - 10, arrowX, arrowY + 5, hip.assessment.color);
                }
            }
            
            // Draw calibration info
            if (mmData.calibration) {
                const cal = mmData.calibration;
                const calText = `Ê†°Ê≠£: ${cal.calibrationQuality} (${(cal.confidence * 100).toFixed(0)}%)`;
                
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.strokeStyle = 'rgba(0,0,0,0.8)';
                ctx.lineWidth = 2;
                
                const calTextWidth = ctx.measureText(calText).width;
                ctx.fillRect(canvas.width - calTextWidth - 20, 10, calTextWidth + 15, 20);
                
                ctx.fillStyle = '#000000';
                ctx.strokeText(calText, canvas.width - calTextWidth - 12, 25);
                ctx.fillText(calText, canvas.width - calTextWidth - 12, 25);
            }
            
            // Restore context state
            ctx.restore();
            
            console.log('‚úÖ MM measurements drawn on photo');
        }
        
        // Helper function to draw arrows
        function drawArrow(ctx, startX, startY, endX, endY, color) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // Draw main line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw arrowhead
            const angle = Math.atan2(endY - startY, endX - startX);
            const arrowLength = 15;
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle - Math.PI / 6),
                endY - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                endX - arrowLength * Math.cos(angle + Math.PI / 6),
                endY - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // MediaPipe Pose Detection
        let pose = null;
        let currentPoseResults = null;
        let isAnalyzing = false;
        
        // Initialize MediaPipe Pose
        async function initMediaPipe() {
            const timestamp = new Date().toISOString().slice(11, 23);
            console.log(`üöÄ [${timestamp}] Initializing MediaPipe Pose...`);
            
            if (typeof Pose === 'undefined') {
                console.error(`‚ùå [${timestamp}] MediaPipe Pose not loaded - retrying in 1 second`);
                setTimeout(initMediaPipe, 1000);
                return false;
            }
            
            try {
                console.log(`üîß [${timestamp}] Creating new Pose instance...`);
                pose = new Pose({
                    locateFile: (file) => {
                        const url = `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                        console.log(`üì¶ [${timestamp}] Loading MediaPipe file: ${url}`);
                        return url;
                    }
                });
                
                // Optimize settings for mobile devices
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log(`üì± [${timestamp}] Device type: ${isMobile ? 'Mobile' : 'Desktop'}`);
                
                console.log(`‚öôÔ∏è [${timestamp}] Setting MediaPipe options...`);
                pose.setOptions({
                    modelComplexity: 1, // Use model complexity 1 for better accuracy
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    smoothSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                console.log(`üîó [${timestamp}] Setting pose.onResults callback...`);
                pose.onResults(onPoseResults);
                
                // Wait for initialization to complete
                console.log(`‚è≥ [${timestamp}] Waiting for initialization to complete...`);
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Test the pose object
                console.log(`üß™ [${timestamp}] Testing pose object:`, {
                    poseExists: !!pose,
                    poseType: typeof pose,
                    poseMethods: pose ? Object.getOwnPropertyNames(Object.getPrototypeOf(pose)) : 'N/A'
                });
                
                console.log(`‚úÖ [${timestamp}] MediaPipe Pose initialized successfully`);
                return true;
            } catch (error) {
                console.error(`‚ùå [${timestamp}] Failed to initialize MediaPipe Pose:`, error);
                return false;
            }
        }
        
        // Handle pose detection results
        function onPoseResults(results) {
            currentPoseResults = results;
            
            // Monitor pose detection for smart reload feature
            monitorPoseDetection();
            
            // Enhanced debugging for pose results
            const landmarks = results.poseLandmarks;
            const landmarkCount = landmarks ? landmarks.length : 0;
            const timestamp = new Date().toISOString().slice(11, 23); // HH:MM:SS.mmm
            
            console.log(`üéØ [${timestamp}] Pose results received:`, {
                landmarks: landmarkCount,
                hasResults: !!results,
                resultsKeys: Object.keys(results),
                worldLandmarks: results.poseWorldLandmarks ? results.poseWorldLandmarks.length : 0
            });
            
            // Update pose status indicators with enhanced logging
            updatePoseStatus(results.poseLandmarks);
            
            // Draw pose landmarks on canvas - ALWAYS SHOW
            if (results.poseLandmarks) {
                console.log(`üéØ [${timestamp}] Calling drawPoseLandmarks with`, results.poseLandmarks.length, 'landmarks');
                try {
                    drawPoseLandmarks(results);
                    console.log(`‚úÖ [${timestamp}] drawPoseLandmarks completed successfully`);
                } catch (drawError) {
                    console.error(`‚ùå [${timestamp}] drawPoseLandmarks failed:`, drawError);
                }
                
                // Real-time squat detection for dynamic analysis
                const activeScreen = document.querySelector('.app-screen:not(.hidden)');
                if (activeScreen && activeScreen.id === 'dynamic-analysis') {
                    const squatDetection = detectSquat(results.poseLandmarks);
                    updateSquatCounter(squatDetection);
                }
                
                // Perform pose analysis if analyzing
                if (isAnalyzing) {
                    performPoseAnalysis(results.poseLandmarks);
                }
            } else {
                console.log(`‚ùå [${timestamp}] No pose landmarks detected in results:`, {
                    resultsType: typeof results,
                    resultsKeys: results ? Object.keys(results) : 'null/undefined',
                    poseLandmarksType: typeof results?.poseLandmarks
                });
            }
        }
        
        // Global movement tracking variables
        let currentSquatCount = 0;
        let lastSquatPhase = 'standing';
        let movementAnalysisData = [];
        let isWaitingForMovement = false;
        let movementStartTime = null;
        let lastMovementIntensity = 0;
        
        // Update squat counter display
        function updateSquatCounter(squatDetection) {
            if (!squatDetection) return;
            
            // Count completed squats
            if (squatDetection.phase === 'standing' && lastSquatPhase === 'up') {
                currentSquatCount++;
                
                // Update counter display
                const countElement = document.getElementById('squatCount');
                if (countElement) {
                    countElement.textContent = currentSquatCount;
                    
                    // Add animation effect
                    countElement.style.transform = 'scale(1.5)';
                    setTimeout(() => {
                        countElement.style.transform = 'scale(1)';
                    }, 200);
                }
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
            }
            
            lastSquatPhase = squatDetection.phase;
        }
        
        // Update pose detection status with enhanced debugging
        function updatePoseStatus(landmarks) {
            const staticIndicator = document.getElementById('staticPoseIndicator');
            const staticText = document.getElementById('staticPoseText');
            const dynamicIndicator = document.getElementById('dynamicPoseIndicator');
            const dynamicText = document.getElementById('dynamicPoseText');
            
            const isDetected = landmarks && landmarks.length > 0;
            const confidence = isDetected ? calculatePoseConfidence(landmarks) : 0;
            const timestamp = new Date().toISOString().slice(11, 23);
            
            // Enhanced logging for status updates
            console.log(`üìä [${timestamp}] Updating pose status:`, {
                isDetected,
                landmarkCount: landmarks ? landmarks.length : 0,
                confidence: Math.round(confidence * 100),
                staticElements: { indicator: !!staticIndicator, text: !!staticText },
                dynamicElements: { indicator: !!dynamicIndicator, text: !!dynamicText },
                currentScreen: currentScreen
            });
            
            // Update static analysis status
            if (staticIndicator && staticText) {
                if (isDetected) {
                    staticIndicator.className = 'w-2 h-2 bg-green-500 rounded-full inline-block mr-1';
                    const newText = `Pose Detected (${Math.round(confidence * 100)}%)`;
                    staticText.textContent = newText;
                    console.log(`‚úÖ Static status updated: ${newText}`);
                } else {
                    staticIndicator.className = 'w-2 h-2 bg-red-500 rounded-full inline-block mr-1';
                    staticText.textContent = 'No Pose Detected';
                    console.log(`‚ùå Static status: No Pose Detected`);
                }
            } else {
                console.warn('‚ö†Ô∏è Static status elements not found:', { indicator: !!staticIndicator, text: !!staticText });
            }
            
            // Update dynamic analysis status
            if (dynamicIndicator && dynamicText) {
                if (isDetected) {
                    dynamicIndicator.className = 'w-2 h-2 bg-green-500 rounded-full inline-block mr-1';
                    const newText = `Tracking (${Math.round(confidence * 100)}%)`;
                    dynamicText.textContent = newText;
                    console.log(`‚úÖ Dynamic status updated: ${newText}`);
                } else {
                    dynamicIndicator.className = 'w-2 h-2 bg-red-500 rounded-full inline-block mr-1';
                    dynamicText.textContent = 'No Movement Detected';
                    console.log(`‚ùå Dynamic status: No Movement Detected`);
                }
            } else {
                console.warn('‚ö†Ô∏è Dynamic status elements not found:', { indicator: !!dynamicIndicator, text: !!dynamicText });
            }
        }
        
        // Calculate pose detection confidence
        function calculatePoseConfidence(landmarks) {
            if (!landmarks || landmarks.length === 0) return 0;
            
            const visibleLandmarks = landmarks.filter(landmark => 
                landmark.visibility && landmark.visibility > 0.5
            );
            
            return visibleLandmarks.length / landmarks.length;
        }
        
        // Draw pose landmarks on canvas with enhanced visibility
        function drawPoseLandmarks(results) {
            console.log('üé® Starting pose landmark drawing...', !!results.poseLandmarks);
            
            // Find active screen - check both active class and visibility
            const activeScreens = document.querySelectorAll('.app-screen.active');
            let activeScreen = null;
            
            // Prioritize the current screen that's actually visible
            if (currentScreen === 'static-analysis') {
                activeScreen = document.getElementById('static-analysis');
            } else if (currentScreen === 'dynamic-analysis') {
                activeScreen = document.getElementById('dynamic-analysis');
            } else {
                activeScreen = activeScreens[0];
            }
            
            let canvas, ctx, video;
            
            if (activeScreen && activeScreen.id === 'static-analysis') {
                canvas = document.getElementById('staticPoseCanvas');
                video = document.getElementById('staticCameraFeed');
                console.log('üìç Using static analysis canvas');
            } else if (activeScreen && activeScreen.id === 'dynamic-analysis') {
                canvas = document.getElementById('dynamicPoseCanvas');
                video = document.getElementById('dynamicCameraFeed');
                console.log('üìç Using dynamic analysis canvas');
            } else {
                console.log('‚ùå No active analysis screen found:', activeScreen?.id, 'currentScreen:', currentScreen);
                return;
            }
            
            if (!canvas) {
                console.log('‚ùå Canvas not found for screen:', activeScreen?.id);
                return;
            }
            
            if (!video) {
                console.log('‚ùå Video not found for screen:', activeScreen?.id);
                return;
            }
            
            if (!results.poseLandmarks || results.poseLandmarks.length === 0) {
                console.log('‚ùå No pose landmarks available');
                return;
            }
            
            // Ensure video is actually playing and has content
            if (video.videoWidth === 0 || video.videoHeight === 0) {
                console.log('‚ùå Video not ready - dimensions:', video.videoWidth, 'x', video.videoHeight);
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            // Force canvas to be absolutely visible and above video
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '25'; // Higher than transparent overlay elements
            
            // Get video container dimensions (not video element itself)
            const videoContainer = video.parentElement;
            const containerRect = videoContainer.getBoundingClientRect();
            
            console.log('üìê Container dimensions:', containerRect.width, 'x', containerRect.height);
            console.log('üìê Video actual dimensions:', video.videoWidth, 'x', video.videoHeight);
            
            // Set canvas size to match video container exactly
            canvas.width = containerRect.width;
            canvas.height = containerRect.height;
            canvas.style.width = containerRect.width + 'px';
            canvas.style.height = containerRect.height + 'px';
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Add a subtle debug indicator to ensure canvas is working
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Very faint green background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            console.log('üé® Canvas setup - Size:', canvas.width, 'x', canvas.height, 'Landmarks:', results.poseLandmarks.length);
            
            // Draw pose connections and landmarks with maximum visibility
            if (results.poseLandmarks && results.poseLandmarks.length > 0) {
                
                let connectionsDrawn = 0;
                let landmarksDrawn = 0;
                
                // Check if this is a front camera (mirrored) based on the current video element transform
                const isFrontCamera = video && video.style.transform.includes('scaleX(-1)');
                console.log(`üìπ Drawing skeleton for ${isFrontCamera ? 'front (mirrored)' : 'back'} camera`);
                
                // Draw skeleton connections
                ctx.strokeStyle = '#F5F5DC'; // Beige color
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                POSE_CONNECTIONS.forEach((connection, idx) => {
                    const start = results.poseLandmarks[connection[0]];
                    const end = results.poseLandmarks[connection[1]];
                    
                    if (start && end) {
                        // Lower visibility threshold for more connections
                        const startVisible = !start.visibility || start.visibility > 0.3;
                        const endVisible = !end.visibility || end.visibility > 0.3;
                        
                        if (startVisible && endVisible) {
                            ctx.beginPath();
                            // Mirror x coordinates for front camera to match video display
                            const startX = isFrontCamera ? (1 - start.x) * canvas.width : start.x * canvas.width;
                            const startY = start.y * canvas.height;
                            const endX = isFrontCamera ? (1 - end.x) * canvas.width : end.x * canvas.width;
                            const endY = end.y * canvas.height;
                            
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                            connectionsDrawn++;
                            
                            // Debug: log first few connections
                            if (idx < 3) {
                                console.log(`üîó Connection ${idx}: (${startX.toFixed(1)}, ${startY.toFixed(1)}) -> (${endX.toFixed(1)}, ${endY.toFixed(1)})`);
                            }
                        }
                    }
                });
                
                // Draw landmark points on top
                ctx.fillStyle = '#9ACD32'; // Khaki/YellowGreen color
                results.poseLandmarks.forEach((landmark, index) => {
                    const visible = !landmark.visibility || landmark.visibility > 0.3;
                    
                    if (visible) {
                        // Mirror x coordinates for front camera to match video display
                        const x = isFrontCamera ? (1 - landmark.x) * canvas.width : landmark.x * canvas.width;
                        const y = landmark.y * canvas.height;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, 2 * Math.PI); // 8px diameter (4px radius)
                        ctx.fill();
                        landmarksDrawn++;
                        
                        // Draw landmark index for key points (nose, shoulders, hips)
                        if ([0, 11, 12, 23, 24].includes(index)) {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = 'bold 12px Arial';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 3;
                            ctx.strokeText(index.toString(), x + 10, y + 5);
                            ctx.fillText(index.toString(), x + 10, y + 5);
                            ctx.fillStyle = '#9ACD32'; // Reset to khaki after text drawing
                        }
                        
                        // Debug: log first few landmarks
                        if (index < 5) {
                            console.log(`üéØ Landmark ${index}: (${x.toFixed(1)}, ${y.toFixed(1)}) visibility: ${landmark.visibility?.toFixed(2) || 'N/A'}`);
                        }
                    }
                });
                
                console.log(`‚úÖ Drawing complete! Connections: ${connectionsDrawn}/${POSE_CONNECTIONS.length}, Landmarks: ${landmarksDrawn}/${results.poseLandmarks.length}`);
                
                // Draw vertical reference lines from hip center
                drawVerticalReferenceLines(ctx, results.poseLandmarks, isFrontCamera, canvas);
                
                // Draw a visible test indicator in corner to confirm canvas is working
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(5, 5, 15, 15);
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('OK', 25, 15);
                console.log('üü® Debug indicator drawn');
                
            } else {
                console.log('‚ùå No pose landmarks to draw');
            }
        }
        
        // Helper function to draw connections
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(connection => {
                const start = landmarks[connection[0]];
                const end = landmarks[connection[1]];
                
                if (start && end && start.visibility > 0.5 && end.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(start.x * ctx.canvas.width, start.y * ctx.canvas.height);
                    ctx.lineTo(end.x * ctx.canvas.width, end.y * ctx.canvas.height);
                    ctx.stroke();
                }
            });
        }
        
        // Helper function to draw landmarks
        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                if (landmark.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(
                        landmark.x * ctx.canvas.width,
                        landmark.y * ctx.canvas.height,
                        style.radius,
                        0,
                        2 * Math.PI
                    );
                    ctx.fill();
                }
            });
        }
        
        // MediaPipe pose connections
        const POSE_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [17, 19], [19, 15],
            [15, 21], [12, 14], [14, 16], [16, 18], [18, 20], [20, 16], [16, 22],
            [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28],
            [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]
        ];
        
        // Draw vertical reference lines from hip center
        function drawVerticalReferenceLines(ctx, landmarks, isFrontCamera, canvas) {
            const leftHip = landmarks[23];   // Â∑¶ËÖ∞
            const rightHip = landmarks[24];  // Âè≥ËÖ∞
            const nose = landmarks[0];       // ÈºªÔºàÈ†≠È†ÇÈÉ®„ÅÆ‰ª£Áî®Ôºâ
            
            // ËÖ∞„ÅÆ‰∏≠Â§ÆÁÇπ„ÇíË®àÁÆó
            if (leftHip && rightHip && leftHip.visibility > 0.3 && rightHip.visibility > 0.3) {
                const hipCenterX = isFrontCamera ? 
                    (1 - (leftHip.x + rightHip.x) / 2) * canvas.width : 
                    ((leftHip.x + rightHip.x) / 2) * canvas.width;
                const hipCenterY = ((leftHip.y + rightHip.y) / 2) * canvas.height;
                
                // ÂûÇÁõ¥Âü∫Ê∫ñÁ∑ö„ÅÆ„Çπ„Çø„Ç§„É´Ë®≠ÂÆö
                ctx.strokeStyle = '#FF6B6B'; // Ëµ§„Ç™„É¨„É≥„Ç∏Ëâ≤
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]); // Á†¥Á∑ö„Éë„Çø„Éº„É≥
                ctx.lineCap = 'round';
                
                // 1. ËÖ∞‰∏≠Â§Æ„Åã„ÇâÁîªÈù¢‰∏ãÁ´Ø„Åæ„ÅßÔºàÂú∞Èù¢„Å∏„ÅÆÂûÇÁõ¥Á∑öÔºâ
                ctx.beginPath();
                ctx.moveTo(hipCenterX, hipCenterY);
                ctx.lineTo(hipCenterX, canvas.height);
                ctx.stroke();
                
                // 2. ËÖ∞‰∏≠Â§Æ„Åã„ÇâÁîªÈù¢‰∏äÁ´Ø„Åæ„ÅßÔºàÈ†≠È†ÇÈÉ®„Å∏„ÅÆÂûÇÁõ¥Á∑öÔºâ
                ctx.beginPath();
                ctx.moveTo(hipCenterX, hipCenterY);
                ctx.lineTo(hipCenterX, 0);
                ctx.stroke();
                
                // 3. È†≠È†ÇÈÉ®ÔºàÈºªÔºâ„Åã„ÇâÂûÇÁõ¥Á∑ö„Å∏„ÅÆË∑ùÈõ¢„ÇíÂèØË¶ñÂåñ
                if (nose && nose.visibility > 0.3) {
                    const noseX = isFrontCamera ? (1 - nose.x) * canvas.width : nose.x * canvas.width;
                    const noseY = nose.y * canvas.height;
                    
                    // Èºª„Åã„ÇâÂûÇÁõ¥Á∑ö„Å∏„ÅÆÊ∞¥Âπ≥Á∑öÔºàÂßøÂã¢„ÅÆÂâçÂæåÂÇæ„ÇíÁ§∫„ÅôÔºâ
                    ctx.strokeStyle = '#4ECDC4'; // „Çø„Éº„Ç≥„Ç§„Ç∫Ëâ≤
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 2]);
                    
                    ctx.beginPath();
                    ctx.moveTo(noseX, noseY);
                    ctx.lineTo(hipCenterX, noseY);
                    ctx.stroke();
                    
                    // ÂÅèÂ∑ÆË∑ùÈõ¢„ÅÆË°®Á§∫
                    const deviationPx = Math.abs(noseX - hipCenterX);
                    const deviationPercent = (deviationPx / canvas.width * 100).toFixed(1);
                    
                    if (deviationPx > 10) { // 10px‰ª•‰∏ä„ÅÆÂÅèÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 12px Arial';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        
                        const textX = Math.min(noseX, hipCenterX) + Math.abs(noseX - hipCenterX) / 2;
                        const textY = noseY - 10;
                        
                        ctx.strokeText(`${deviationPercent}%`, textX, textY);
                        ctx.fillText(`${deviationPercent}%`, textX, textY);
                    }
                }
                
                // 4. ËÖ∞‰∏≠Â§ÆÁÇπ„ÇíÂº∑Ë™øË°®Á§∫
                ctx.setLineDash([]); // ÂÆüÁ∑ö„Å´Êàª„Åô
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(hipCenterX, hipCenterY, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // ËÖ∞‰∏≠Â§ÆÁÇπ„Å´„É©„Éô„É´Ë°®Á§∫
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 10px Arial';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeText('HIP', hipCenterX + 10, hipCenterY + 5);
                ctx.fillText('HIP', hipCenterX + 10, hipCenterY + 5);
                
                console.log(`üìè Vertical reference lines drawn from hip center (${hipCenterX.toFixed(1)}, ${hipCenterY.toFixed(1)})`);
                
                // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
                if (nose && nose.visibility > 0.3) {
                    const noseX = isFrontCamera ? (1 - nose.x) * canvas.width : nose.x * canvas.width;
                    const deviation = Math.abs(noseX - hipCenterX);
                    console.log(`üìê Posture deviation: ${deviation.toFixed(1)}px (${(deviation/canvas.width*100).toFixed(1)}%)`);
                }
            } else {
                console.log('‚ö†Ô∏è Hip landmarks not available for vertical reference lines');
            }
            
            // Á∑ö„ÅÆ„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
            ctx.setLineDash([]);
            ctx.lineWidth = 3; // È™®Ê†ºÁ∑ö„ÅÆÂÖÉ„ÅÆÂ§™„Åï„Å´Êàª„Åô
        }
        
        // Pose Analysis Algorithms
        function performPoseAnalysis(landmarks) {
            const analysis = {
                posture: analyzePosture(landmarks),
                balance: analyzeBalance(landmarks),
                angles: calculateKeyAngles(landmarks),
                timestamp: Date.now()
            };
            
            // Store analysis results
            currentPoseAnalysis = analysis;
            
            return analysis;
        }
        
        // Analyze posture alignment
        function analyzePosture(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            // Key landmarks for posture analysis
            const nose = landmarks[0];
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            
            // Calculate head forward posture
            const headForward = calculateHeadForwardPosture(nose, leftShoulder, rightShoulder);
            
            // Calculate shoulder elevation
            const shoulderElevation = Math.abs(leftShoulder.y - rightShoulder.y);
            
            // Calculate hip alignment
            const hipAlignment = Math.abs(leftHip.y - rightHip.y);
            
            // Calculate overall posture score (0-100)
            const postureScore = calculatePostureScore(headForward, shoulderElevation, hipAlignment);
            
            return {
                headForward: headForward,
                shoulderElevation: shoulderElevation,
                hipAlignment: hipAlignment,
                score: postureScore,
                grade: getPostureGrade(postureScore)
            };
        }
        
        // Analyze balance and stability
        function analyzeBalance(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            // Calculate center of gravity
            const centerOfGravity = {
                x: (leftAnkle.x + rightAnkle.x) / 2,
                y: (leftAnkle.y + rightAnkle.y) / 2
            };
            
            // Calculate balance deviation
            const balanceDeviation = Math.sqrt(
                Math.pow(nose.x - centerOfGravity.x, 2) + 
                Math.pow(nose.y - centerOfGravity.y, 2)
            );
            
            // Calculate balance score
            const balanceScore = Math.max(0, 100 - (balanceDeviation * 1000));
            
            return {
                centerOfGravity: centerOfGravity,
                deviation: balanceDeviation,
                score: balanceScore,
                stability: balanceScore > 80 ? 'Excellent' : 
                          balanceScore > 60 ? 'Good' : 
                          balanceScore > 40 ? 'Fair' : 'Poor'
            };
        }
        
        // Calculate key body angles
        function calculateKeyAngles(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            // Neck angle
            const neckAngle = calculateAngle(
                landmarks[0],  // nose
                landmarks[11], // left shoulder
                landmarks[12]  // right shoulder
            );
            
            // Spine angle (simplified)
            const spineAngle = calculateAngle(
                landmarks[11], // left shoulder
                landmarks[23], // left hip
                landmarks[27]  // left ankle
            );
            
            // Knee angles
            const leftKneeAngle = calculateAngle(
                landmarks[23], // left hip
                landmarks[25], // left knee
                landmarks[27]  // left ankle
            );
            
            const rightKneeAngle = calculateAngle(
                landmarks[24], // right hip
                landmarks[26], // right knee
                landmarks[28]  // right ankle
            );
            
            return {
                neck: neckAngle,
                spine: spineAngle,
                leftKnee: leftKneeAngle,
                rightKnee: rightKneeAngle,
                symmetry: Math.abs(leftKneeAngle - rightKneeAngle)
            };
        }
        
        // Calculate angle between three points
        function calculateAngle(pointA, pointB, pointC) {
            const vectorBA = {
                x: pointA.x - pointB.x,
                y: pointA.y - pointB.y
            };
            
            const vectorBC = {
                x: pointC.x - pointB.x,
                y: pointC.y - pointB.y
            };
            
            const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;
            const magnitudeBA = Math.sqrt(vectorBA.x * vectorBA.x + vectorBA.y * vectorBA.y);
            const magnitudeBC = Math.sqrt(vectorBC.x * vectorBC.x + vectorBC.y * vectorBC.y);
            
            const cosineAngle = dotProduct / (magnitudeBA * magnitudeBC);
            const angleRadians = Math.acos(Math.max(-1, Math.min(1, cosineAngle)));
            
            return angleRadians * (180 / Math.PI);
        }
        
        // Helper functions for posture analysis
        function calculateHeadForwardPosture(nose, leftShoulder, rightShoulder) {
            const shoulderCenter = {
                x: (leftShoulder.x + rightShoulder.x) / 2,
                y: (leftShoulder.y + rightShoulder.y) / 2
            };
            
            return Math.abs(nose.x - shoulderCenter.x);
        }
        
        function calculatePostureScore(headForward, shoulderElevation, hipAlignment) {
            let score = 100;
            
            // Deduct points for poor posture
            score -= (headForward * 200); // Head forward penalty
            score -= (shoulderElevation * 300); // Shoulder elevation penalty
            score -= (hipAlignment * 400); // Hip misalignment penalty
            
            return Math.max(0, Math.min(100, score));
        }
        
        function getPostureGrade(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B';
            if (score >= 60) return 'C';
            if (score >= 50) return 'D';
            return 'F';
        }
        
        // Start pose detection for video element (Direct approach without Camera class)
        let poseDetectionInterval = null;
        
        function startPoseDetection(videoElementId, canvasElementId, statusElementId) {
            console.log('üé¨ Starting pose detection...', { videoElementId, canvasElementId, statusElementId });
            
            const video = document.getElementById(videoElementId);
            const canvas = document.getElementById(canvasElementId);
            const status = document.getElementById(statusElementId);
            
            if (!video || !canvas) {
                console.error('‚ùå Missing video or canvas elements:', { video: !!video, canvas: !!canvas });
                return;
            }
            
            // Check if MediaPipe is available and attempt recovery if needed
            if (!pose || window.mediaPipeInitializationFailed) {
                console.warn('‚ö†Ô∏è MediaPipe not available, attempting re-initialization...');
                
                // Show user feedback
                if (status) {
                    status.textContent = 'Initializing AI detection... / AIÊ§úÂá∫„ÇíÂàùÊúüÂåñ‰∏≠...';
                    status.className = 'text-yellow-400 text-sm font-medium';
                }
                
                // Attempt to re-initialize MediaPipe
                initMediaPipe().then(initialized => {
                    if (initialized) {
                        console.log('‚úÖ MediaPipe re-initialization successful');
                        window.mediaPipeInitializationFailed = false;
                        // Restart pose detection with a delay
                        setTimeout(() => startPoseDetection(videoElementId, canvasElementId, statusElementId), 500);
                    } else {
                        console.error('‚ùå MediaPipe re-initialization failed');
                        if (status) {
                            status.textContent = 'AI detection unavailable / AIÊ§úÂá∫„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì';
                            status.className = 'text-red-400 text-sm font-medium';
                        }
                        showToast('‚ùå MediaPipe could not be initialized - some features may be limited / MediaPipe„ÇíÂàùÊúüÂåñ„Åß„Åç„Åæ„Åõ„Çì„ÄÅ‰∏ÄÈÉ®Ê©üËÉΩ„ÅåÂà∂Èôê„Åï„Çå„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô', 'error');
                    }
                }).catch(error => {
                    console.error('‚ùå MediaPipe re-initialization error:', error);
                    if (status) {
                        status.textContent = 'AI detection error / AIÊ§úÂá∫„Ç®„É©„Éº';
                        status.className = 'text-red-400 text-sm font-medium';
                    }
                });
                
                return; // Exit early if MediaPipe is not ready
            }
            
            console.log('‚úÖ All elements found for pose detection');
            
            // Force canvas to be visible and properly positioned ABOVE video
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.zIndex = '25'; // Higher than transparent overlay elements
            canvas.style.pointerEvents = 'none';
            
            // Remove hidden class
            canvas.classList.remove('hidden');
            status.classList.remove('hidden');
            
            console.log('üé® Canvas setup complete - zIndex:', canvas.style.zIndex);
            
            // Stop any existing detection
            if (poseDetectionInterval) {
                console.log('üîÑ Stopping existing pose detection');
                clearInterval(poseDetectionInterval);
                poseDetectionInterval = null;
            }
            
            // Wait for video to be ready with enhanced checking
            const waitForVideo = () => {
                const videoReady = video.videoWidth > 0 && video.videoHeight > 0 && video.readyState >= video.HAVE_CURRENT_DATA;
                
                console.log('üìπ Video status check:', {
                    videoWidth: video.videoWidth,
                    videoHeight: video.videoHeight,
                    readyState: video.readyState,
                    srcObject: !!video.srcObject,
                    ready: videoReady
                });
                
                if (videoReady) {
                    console.log('‚úÖ Video ready for pose detection:', video.videoWidth, 'x', video.videoHeight);
                    
                    // Set canvas size to match video container exactly
                    const container = canvas.parentElement;
                    const rect = container.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    
                    console.log('üìê Canvas resized to container:', rect.width, 'x', rect.height);
                    
                    // Test draw something immediately to verify canvas works
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(0, 0, 30, 30);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('POSE', 5, 20);
                    console.log('üü¢ Test draw on canvas completed');
                    
                    // Start pose detection with enhanced debugging and health monitoring
                    let frameCount = 0;
                    let healthCheckCount = 0;
                    poseDetectionInterval = setInterval(async () => {
                        frameCount++;
                        const timestamp = new Date().toISOString().slice(11, 23);
                        
                        if (pose && video.videoWidth > 0 && video.readyState >= video.HAVE_CURRENT_DATA) {
                            try {
                                // Log every 10th frame to avoid spam
                                if (frameCount % 10 === 0) {
                                    console.log(`üìπ [${timestamp}] Sending frame ${frameCount} to MediaPipe:`, {
                                        videoSize: `${video.videoWidth}x${video.videoHeight}`,
                                        readyState: video.readyState,
                                        poseReady: !!pose
                                    });
                                }
                                await pose.send({ image: video });
                            } catch (error) {
                                console.error(`‚ùå [${timestamp}] Pose detection error on frame ${frameCount}:`, error);
                                
                                // Enhanced error recovery - prevent app crash
                                if (error.name === 'InvalidStateError' || error.message.includes('InvalidState')) {
                                    console.warn('üîÑ MediaPipe InvalidState detected - attempting recovery...');
                                    
                                    // Stop current detection to prevent cascade failures
                                    if (poseDetectionInterval) {
                                        clearInterval(poseDetectionInterval);
                                        poseDetectionInterval = null;
                                    }
                                    
                                    // Trigger smart reload after a delay to allow current processes to complete
                                    setTimeout(() => {
                                        console.log('üö® Critical MediaPipe error - triggering smart reload for recovery');
                                        showToast('‚ö†Ô∏è MediaPipe error detected - reloading for stability / MediaPipe„Ç®„É©„Éº„ÇíÊ§úÂá∫„ÄÅÂÆâÂÆöÊÄß„ÅÆ„Åü„ÇÅ„É™„É≠„Éº„Éâ‰∏≠', 'warning');
                                        smartReload();
                                    }, 1000);
                                    
                                    return; // Exit the interval loop
                                }
                                
                                // For other errors, continue but log the issue
                                if (frameCount % 10 === 0) {
                                    console.warn('‚ö†Ô∏è Non-critical MediaPipe error, continuing detection...');
                                }
                            }
                            
                            // Periodic health check every 5 seconds (100 frames at 20fps)
                            healthCheckCount++;
                            if (healthCheckCount >= 100) {
                                healthCheckCount = 0;
                                
                                // Run automatic health check
                                const isHealthy = autoMonitorMediaPipeHealth();
                                if (!isHealthy) {
                                    console.warn('üö® MediaPipe health check failed during pose detection');
                                }
                            }
                        } else {
                            // Log issues with video or pose readiness
                            if (frameCount % 20 === 0) { // Less frequent logging for issues
                                console.warn(`‚ö†Ô∏è [${timestamp}] Skipping frame ${frameCount}:`, {
                                    poseReady: !!pose,
                                    videoSize: `${video.videoWidth}x${video.videoHeight}`,
                                    readyState: video.readyState,
                                    srcObject: !!video.srcObject
                                });
                            }
                        }
                    }, 50); // ~20 FPS for better stability
                    
                    console.log('üöÄ Pose detection interval started successfully');
                    
                    // Show additional UI elements for dynamic analysis
                    if (videoElementId === 'dynamicCameraFeed') {
                        const counter = document.getElementById('movementCounter');
                        if (counter) {
                            counter.classList.remove('hidden');
                            console.log('üìä Movement counter made visible');
                        }
                    }
                    
                } else {
                    console.log('‚è≥ Waiting for video to be ready... (attempt)', Date.now());
                    setTimeout(waitForVideo, 200); // Slightly longer wait
                }
            };
            
            // Start checking for video readiness with a small delay
            setTimeout(waitForVideo, 300);
        }
        
        // Stop pose detection
        function stopPoseDetection() {
            // Stop interval-based detection
            if (poseDetectionInterval) {
                clearInterval(poseDetectionInterval);
                poseDetectionInterval = null;
            }
            
            // Hide canvas and status elements
            document.getElementById('staticPoseCanvas')?.classList.add('hidden');
            document.getElementById('staticPoseStatus')?.classList.add('hidden');
            document.getElementById('dynamicPoseCanvas')?.classList.add('hidden');
            document.getElementById('dynamicPoseStatus')?.classList.add('hidden');
        }
        
        // Process static analysis results
        function processStaticAnalysisResults(results) {
            if (!results || results.length === 0) return null;
            
            // Calculate averages from multiple samples
            const avgPosture = {
                score: results.reduce((sum, r) => sum + (r.posture?.score || 0), 0) / results.length,
                headForward: results.reduce((sum, r) => sum + (r.posture?.headForward || 0), 0) / results.length,
                shoulderElevation: results.reduce((sum, r) => sum + (r.posture?.shoulderElevation || 0), 0) / results.length,
                hipAlignment: results.reduce((sum, r) => sum + (r.posture?.hipAlignment || 0), 0) / results.length
            };
            
            const avgBalance = {
                score: results.reduce((sum, r) => sum + (r.balance?.score || 0), 0) / results.length,
                deviation: results.reduce((sum, r) => sum + (r.balance?.deviation || 0), 0) / results.length
            };
            
            const avgAngles = {
                neck: results.reduce((sum, r) => sum + (r.angles?.neck || 0), 0) / results.length,
                spine: results.reduce((sum, r) => sum + (r.angles?.spine || 0), 0) / results.length,
                symmetry: results.reduce((sum, r) => sum + (r.angles?.symmetry || 0), 0) / results.length
            };
            
            // Calculate overall score
            const overallScore = Math.round((avgPosture.score * 0.4 + avgBalance.score * 0.3 + (100 - avgAngles.symmetry) * 0.3));
            
            return {
                type: 'static',
                overall_score: overallScore,
                posture_score: Math.round(avgPosture.score),
                balance_score: Math.round(avgBalance.score),
                flexibility_score: Math.round(100 - avgAngles.symmetry),
                recommendations: generatePostureRecommendations(avgPosture, avgBalance, avgAngles),
                detailed_analysis: {
                    posture: avgPosture,
                    balance: avgBalance,
                    angles: avgAngles
                },
                timestamp: new Date().toISOString()
            };
        }
        
        // Generate posture-based recommendations
        function generatePostureRecommendations(posture, balance, angles) {
            const recommendations = [];
            
            if (posture.headForward > 0.05) {
                recommendations.push("È†≠ÈÉ®ÂâçÊñπÁ™ÅÂá∫„ÇíÊîπÂñÑ„Åô„Çã„Åü„ÇÅ„ÄÅÈ¶ñ„ÅÆ„Çπ„Éà„É¨„ÉÉ„ÉÅ„Å®ËÉåÁ≠ãÂº∑Âåñ„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Improve forward head posture with neck stretches and back strengthening");
            }
            
            if (posture.shoulderElevation > 0.03) {
                recommendations.push("ËÇ©„ÅÆÈ´ò„Åï„ÅÆÈÅï„ÅÑ„Çí‰øÆÊ≠£„Åô„Çã„Åü„ÇÅ„ÄÅÁâáÂÅ¥„ÅÆÁ≠ãËÇâ„ÅÆ„Çπ„Éà„É¨„ÉÉ„ÉÅ„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Address shoulder height imbalance with unilateral stretches");
            }
            
            if (balance.score < 70) {
                recommendations.push("„Éê„É©„É≥„ÇπÊîπÂñÑ„ÅÆ„Åü„ÇÅ„ÄÅÁâáË∂≥Á´ã„Å°„ÇÑ„Éê„É©„É≥„Çπ„Éú„Éº„ÉâÁ∑¥Áøí„ÇíÂèñ„ÇäÂÖ•„Çå„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Improve balance with single-leg stands and balance board exercises");
            }
            
            if (angles.symmetry > 10) {
                recommendations.push("Â∑¶Âè≥„ÅÆÂØæÁß∞ÊÄß„ÇíÊîπÂñÑ„Åô„Çã„Åü„ÇÅ„ÄÅÂº±„ÅÑÂÅ¥„ÅÆÁ≠ãÂäõÂº∑Âåñ„ÇíÈáçÁÇπÁöÑ„Å´Ë°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Focus on strengthening the weaker side to improve symmetry");
            }
            
            return recommendations;
        }
        
        // Movement Detection Algorithms
        function detectMovement(landmarks) {
            if (!landmarks || landmarks.length < 33) return null;
            
            const movement = {
                type: 'unknown',
                velocity: calculateMovementVelocity(landmarks),
                range: calculateRangeOfMotion(landmarks),
                stability: calculateMovementStability(landmarks)
            };
            
            return movement;
        }
        
        // Squat Detection Algorithm
        function detectSquat(landmarks) {
            if (!landmarks || landmarks.length < 33) return { isSquat: false, phase: 'unknown' };
            
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            
            // Calculate hip height (average of both hips)
            const hipHeight = (leftHip.y + rightHip.y) / 2;
            
            // Calculate knee angles
            const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
            const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
            const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;
            
            // Determine squat phase based on knee angle and hip height
            let phase = 'standing';
            let isSquat = false;
            
            if (avgKneeAngle < 120 && hipHeight > 0.6) {
                phase = 'down';
                isSquat = true;
            } else if (avgKneeAngle < 90 && hipHeight > 0.7) {
                phase = 'bottom';
                isSquat = true;
            } else if (avgKneeAngle > 120 && avgKneeAngle < 160) {
                phase = 'up';
                isSquat = true;
            } else if (avgKneeAngle > 160) {
                phase = 'standing';
                isSquat = false;
            }
            
            return {
                isSquat: isSquat,
                phase: phase,
                kneeAngle: avgKneeAngle,
                hipHeight: hipHeight,
                form: evaluateSquatForm(landmarks)
            };
        }
        
        // Evaluate squat form quality
        function evaluateSquatForm(landmarks) {
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            let formScore = 100;
            const issues = [];
            
            // Check knee alignment (knees should not cave inward)
            const kneeWidth = Math.abs(leftKnee.x - rightKnee.x);
            const ankleWidth = Math.abs(leftAnkle.x - rightAnkle.x);
            
            if (kneeWidth < ankleWidth * 0.8) {
                formScore -= 20;
                issues.push("ËÜù„ÅåÂÜÖÂÅ¥„Å´ÂÖ•„Å£„Å¶„ÅÑ„Åæ„Åô / Knees caving inward");
            }
            
            // Check forward lean (torso should be relatively upright)
            const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
            const forwardLean = Math.abs(nose.x - hipCenter.x);
            
            if (forwardLean > 0.1) {
                formScore -= 15;
                issues.push("ÂâçÂÇæ„Åó„Åô„Åé„Å¶„ÅÑ„Åæ„Åô / Excessive forward lean");
            }
            
            // Check depth (hips should go below knee level)
            const hipHeight = (leftHip.y + rightHip.y) / 2;
            const kneeHeight = (leftKnee.y + rightKnee.y) / 2;
            
            if (hipHeight < kneeHeight) {
                formScore -= 10;
                issues.push("Ê∑±Â∫¶„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô / Insufficient depth");
            }
            
            return {
                score: Math.max(0, formScore),
                issues: issues,
                grade: formScore >= 90 ? 'Excellent' : 
                       formScore >= 80 ? 'Good' : 
                       formScore >= 70 ? 'Fair' : 'Poor'
            };
        }
        
        // Calculate movement velocity
        function calculateMovementVelocity(landmarks) {
            // This would typically compare with previous frame data
            // For now, return a placeholder
            return Math.random() * 10;
        }
        
        // Calculate range of motion
        function calculateRangeOfMotion(landmarks) {
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            
            const leftKneeAngle = calculateAngle(leftHip, leftKnee, leftAnkle);
            const rightKneeAngle = calculateAngle(rightHip, rightKnee, rightAnkle);
            
            return {
                kneeFlexion: Math.min(leftKneeAngle, rightKneeAngle),
                symmetry: Math.abs(leftKneeAngle - rightKneeAngle)
            };
        }
        
        // Calculate movement stability
        function calculateMovementStability(landmarks) {
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            
            // Calculate center of gravity deviation
            const centerOfGravity = {
                x: (leftAnkle.x + rightAnkle.x) / 2,
                y: (leftAnkle.y + rightAnkle.y) / 2
            };
            
            const deviation = Math.sqrt(
                Math.pow(nose.x - centerOfGravity.x, 2) + 
                Math.pow(nose.y - centerOfGravity.y, 2)
            );
            
            return Math.max(0, 100 - (deviation * 500));
        }
        
        // Process dynamic analysis results
        function processDynamicAnalysisResults(movementData, squatCount) {
            if (!movementData || movementData.length === 0) return null;
            
            // Analyze movement quality over time
            const avgFormScore = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.stability || 0), 0) / movementData.length;
            
            const avgRangeOfMotion = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.range.kneeFlexion || 0), 0) / movementData.length;
            
            const avgSymmetry = movementData
                .filter(data => data.movement && data.movement.range)
                .reduce((sum, data) => sum + (data.movement.range.symmetry || 0), 0) / movementData.length;
            
            // Calculate overall score
            const overallScore = Math.round((avgFormScore * 0.4 + avgRangeOfMotion * 0.3 + (100 - avgSymmetry) * 0.3));
            
            return {
                type: 'dynamic',
                overall_score: overallScore,
                posture_score: Math.round(avgFormScore),
                balance_score: Math.round(avgFormScore),
                flexibility_score: Math.round(avgRangeOfMotion),
                repetitions: squatCount,
                movement_quality: avgFormScore >= 80 ? 'Excellent' : 
                                avgFormScore >= 60 ? 'Good' : 'Needs Improvement',
                recommendations: generateMovementRecommendations(avgFormScore, avgRangeOfMotion, avgSymmetry),
                timestamp: new Date().toISOString()
            };
        }
        
        // Generate movement-based recommendations
        function generateMovementRecommendations(formScore, rangeOfMotion, symmetry) {
            const recommendations = [];
            
            if (formScore < 70) {
                recommendations.push("Âãï‰Ωú„Éï„Ç©„Éº„É†„ÅÆÊîπÂñÑ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ„ÇÜ„Å£„Åè„Çä„Å®Ê≠£Á¢∫„Å™Âãï‰Ωú„ÇíÂøÉ„Åå„Åë„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Focus on movement form. Perform exercises slowly with proper technique");
            }
            
            if (rangeOfMotion < 90) {
                recommendations.push("ÂèØÂãïÂüü„ÇíÂ∫É„Åí„Çã„Åü„ÇÅ„ÄÅ„Çπ„Éà„É¨„ÉÉ„ÉÅ„Å®ÊüîËªüÊÄßÂêë‰∏ä„ÅÆÁ∑¥Áøí„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ");
                recommendations.push("Improve range of motion with stretching and flexibility exercises");
            }
            
            if (symmetry > 15) {
                recommendations.push("Â∑¶Âè≥„ÅÆÂãï‰Ωú„ÅÆÂØæÁß∞ÊÄß„ÇíÊîπÂñÑ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁâáÂÅ¥„ÇíÈáçÁÇπÁöÑ„Å´Á∑¥Áøí„Åó„Åæ„Åó„Çá„ÅÜ");
                recommendations.push("Work on movement symmetry. Focus on the weaker side");
            }
            
            return recommendations;
        }
        
        // API functions
        async function saveUserProfile(profileData) {
            try {
                const response = await fetch('tables/user_profiles', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...profileData,
                        created_at: new Date().toISOString()
                    })
                });
                return await response.json();
            } catch (error) {
                console.error('Error saving profile:', error);
                return null;
            }
        }
        
        async function saveAnalysisResult(resultData) {
            try {
                const response = await fetch('tables/analysis_results', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...resultData,
                        analysis_date: new Date().toISOString()
                    })
                });
                return await response.json();
            } catch (error) {
                console.error('Error saving analysis:', error);
                return null;
            }
        }
        
        async function getUserAnalysisHistory(userId) {
            try {
                const response = await fetch(`tables/analysis_results?search=${userId}&sort=analysis_date`);
                const data = await response.json();
                return data.data.filter(result => result.user_id === userId);
            } catch (error) {
                console.error('Error fetching history:', error);
                return [];
            }
        }
        
        // Navigation functions already defined above
        
        async function handleRegistration() {
            const form = document.getElementById('profileForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            const profileData = {
                id: generateUUID(),
                name: document.getElementById('name').value,
                age: parseInt(document.getElementById('age').value),
                height: parseInt(document.getElementById('height').value),
                weight: parseInt(document.getElementById('weight').value),
                primary_sport: document.getElementById('primarySport').value,
                experience_level: document.getElementById('experienceLevel').value,
                created_at: new Date().toISOString()
            };

            // „Ç™„Éï„É©„Ç§„É≥ÂØæÂøúÔºö„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
            try {
                localStorage.setItem('athletecore_user', JSON.stringify(profileData));
                currentUser = profileData;
                console.log('‚úÖ Profile saved locally:', currentUser);
                
                // Create sample analysis data for the new user
                createSampleAnalysisData();
                
                showDashboard();
            } catch (error) {
                console.error('Local storage error:', error);
                // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åå‰Ωø„Åà„Å™„ÅÑÂ†¥Âêà„Åß„ÇÇ„É°„É¢„É™„Å´‰øùÂ≠ò
                currentUser = profileData;
                showDashboard();
            }
        }
        
        // UUIDÁîüÊàêÈñ¢Êï∞
        function generateUUID() {
            return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // „Çµ„É≥„Éó„É´ÂàÜÊûê„Éá„Éº„Çø‰ΩúÊàêÈñ¢Êï∞
        function createSampleAnalysisData() {
            if (!currentUser) return [];
            
            const now = new Date();
            const sampleData = [];
            
            // Create 3 sample analysis results with different dates
            const dates = [
                new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
                new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000), // 1 day ago
                new Date(now.getTime() - 3 * 60 * 60 * 1000)       // 3 hours ago
            ];
            
            const analysisTypes = ['static', 'dynamic', 'static'];
            const baseScores = [
                { overall_score: 85, hip_flexibility: 88, postural_stability: 82, dynamic_balance: 86 },
                { overall_score: 78, hip_flexibility: 75, postural_stability: 85, dynamic_balance: 75 },
                { overall_score: 92, hip_flexibility: 95, postural_stability: 88, dynamic_balance: 93 }
            ];
            
            // üß™ Sample Base64 image (more visible test pattern for debugging)
            const samplePhotoData = {
                imageData: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iIzQzODVmNCIvPgogIDx0ZXh0IHg9IjE1MCIgeT0iODAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0iI2ZmZmZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSI+8J+MhyBURVNUIFBIT1RPPC90ZXh0PgogIDx0ZXh0IHg9IjE1MCIgeT0iMTEwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTYiIGZpbGw9IiNmZmZmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkF0aGxldGVDb3JlIFBybzwvdGV4dD4KICA8dGV4dCB4PSIxNTAiIHk9IjE0MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5QaG90byBEaXNwbGF5IFRlc3Q8L3RleHQ+CiAgPGNpcmNsZSBjeD0iNzUiIGN5PSIxNjAiIHI9IjE1IiBmaWxsPSIjMDBmZjAwIi8+CiAgPGNpcmNsZSBjeD0iMjI1IiBjeT0iMTYwIiByPSIxNSIgZmlsbD0iI2ZmZmYwMCIvPgo8L3N2Zz4K",
                width: 300,
                height: 200,
                timestamp: new Date().toISOString(),
                hasPoseOverlay: true,
                cameraType: 'front'
            };
            
            dates.forEach((date, index) => {
                const analysisResult = {
                    id: generateUUID(),
                    user_id: currentUser.id,
                    analysis_type: analysisTypes[index],
                    sport: currentUser.primary_sport,
                    analysis_date: date.toISOString(),
                    ...baseScores[index],
                    // üß™ Add sample photo data to test photo display (add to first and third entries)
                    capturedPhoto: (index === 0 || index === 2) ? {
                        ...samplePhotoData,
                        timestamp: date.toISOString(),
                        cameraType: index === 0 ? 'front' : 'back'
                    } : null,
                    recommendations: [
                        "Focus on core strengthening exercises / ‰ΩìÂππÂº∑Âåñ„Ç®„ÇØ„Çµ„Çµ„Ç§„Ç∫„Å´ÈáçÁÇπ„ÇíÁΩÆ„Åè",
                        "Improve hip flexor mobility / ËÇ°Èñ¢ÁØÄÂ±àÁ≠ãÁæ§„ÅÆÂèØÂãïÊÄß„ÇíÂêë‰∏ä„Åï„Åõ„Çã"
                    ]
                };
                sampleData.push(analysisResult);
            });
            
            console.log('üìä Created sample analysis data:', sampleData.length, 'items');
            console.log('üß™ Sample data with photo entries:', sampleData.filter(d => d.capturedPhoto).length);
            return sampleData;
        }
        
        // „Ç¢„Éó„É™Ëµ∑ÂãïÊôÇ„Å´„É≠„Éº„Ç´„É´„Éá„Éº„Çø„Çí„É≠„Éº„Éâ
        function loadLocalUser() {
            try {
                const savedUser = localStorage.getItem('athletecore_user');
                if (savedUser) {
                    currentUser = JSON.parse(savedUser);
                    console.log('Loaded user from local storage:', currentUser);
                }
            } catch (error) {
                console.error('Error loading local user:', error);
            }
        }

        // showDashboard function moved to top
        
        async function updateDashboardContent() {
            // Only perform user check if we're actually on the dashboard screen
            const currentScreen = document.querySelector('.app-screen.active');
            if (!currentScreen || currentScreen.id !== 'dashboard') {
                console.log('üîç updateDashboardContent called but not on dashboard screen, skipping...');
                return;
            }
            
            if (currentUser) {
                // Update greeting with user name
                const greetingElement = document.querySelector('#dashboard h1');
                if (greetingElement) {
                    greetingElement.textContent = `Hello, ${currentUser.name}!`;
                }
                
                console.log('üìä Loading analysis history for user:', currentUser.name);
                // Load and display analysis history
                await loadAnalysisHistory();
            } else {
                console.warn('‚ö†Ô∏è No current user found in updateDashboardContent');
                // Only redirect to registration if we're actually trying to show dashboard
                console.log('üîÑ Redirecting to registration from dashboard...');
                setTimeout(() => {
                    showRegistration();
                }, 1000);
            }
        }
        
        // „É≠„Éº„Ç´„É´‰øùÂ≠òÈñ¢Êï∞
        function saveAnalysisResultLocal(resultData) {
            try {
                let results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                
                // Check localStorage size before adding new data
                const currentSize = new Blob([JSON.stringify(results)]).size;
                const newDataSize = new Blob([JSON.stringify(resultData)]).size;
                const totalSize = currentSize + newDataSize;
                
                console.log('üìä Storage size check:', {
                    currentSize: (currentSize / 1024 / 1024).toFixed(2) + 'MB',
                    newDataSize: (newDataSize / 1024 / 1024).toFixed(2) + 'MB',
                    totalSize: (totalSize / 1024 / 1024).toFixed(2) + 'MB',
                    hasPhoto: !!resultData.capturedPhoto
                });
                
                // If total size would exceed 8MB, remove oldest entries with photos first
                while (totalSize > 8 * 1024 * 1024 && results.length > 0) {
                    // Find oldest entry with photo to remove first
                    const oldestWithPhoto = results.find(r => r.capturedPhoto);
                    if (oldestWithPhoto) {
                        const index = results.findIndex(r => r.id === oldestWithPhoto.id);
                        results.splice(index, 1);
                        console.log('üóëÔ∏è Removed oldest analysis with photo to save space');
                    } else {
                        // Remove oldest entry if no photos found
                        results.shift();
                        console.log('üóëÔ∏è Removed oldest analysis to save space');
                    }
                }
                
                // üîç Debug: Check resultData before saving
                console.log('üîç Data being saved:', {
                    id: resultData.id,
                    hasPhoto: !!resultData.capturedPhoto,
                    photoDataSize: resultData.capturedPhoto ? (resultData.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                    photoTimestamp: resultData.capturedPhoto ? resultData.capturedPhoto.timestamp : 'N/A'
                });
                
                results.push(resultData);
                
                // Additional safety: keep maximum 20 entries total
                if (results.length > 20) {
                    results = results.slice(-20);
                }
                
                localStorage.setItem('athletecore_results', JSON.stringify(results));
                
                // üîç Debug: Verify data was saved correctly by re-reading
                const savedResults = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const savedEntry = savedResults.find(r => r.id === resultData.id);
                console.log('‚úÖ Analysis result saved locally:', {
                    id: resultData.id,
                    type: resultData.analysis_type,
                    hasPhoto: !!resultData.capturedPhoto,
                    savedWithPhoto: !!(savedEntry && savedEntry.capturedPhoto),
                    totalEntries: results.length
                });
                
            } catch (error) {
                console.error('‚ùå Error saving analysis result locally:', error);
                
                // If localStorage is full, try to save without photo
                if (error.name === 'QuotaExceededError' && resultData.capturedPhoto) {
                    console.warn('‚ö†Ô∏è Storage full, attempting to save without photo');
                    const resultDataWithoutPhoto = { ...resultData };
                    delete resultDataWithoutPhoto.capturedPhoto;
                    
                    try {
                        let results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                        results.push(resultDataWithoutPhoto);
                        localStorage.setItem('athletecore_results', JSON.stringify(results));
                        console.log('‚úÖ Analysis saved without photo due to storage constraints');
                        
                        // Show user notification
                        showStorageWarning();
                    } catch (secondError) {
                        console.error('‚ùå Failed to save even without photo:', secondError);
                    }
                }
            }
        }
        
        // Show storage warning to user
        function showStorageWarning() {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'fixed top-4 left-4 right-4 bg-yellow-500 text-white p-3 rounded-lg shadow-lg z-50';
            warningDiv.innerHTML = `
                <div class="text-sm font-medium">Storage Almost Full</div>
                <div class="text-xs mt-1">Photo not saved. Consider clearing old analysis data.</div>
                <button onclick="this.parentElement.remove()" class="absolute top-1 right-2 text-white text-lg">√ó</button>
            `;
            document.body.appendChild(warningDiv);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                warningDiv.remove();
            }, 5000);
        }
        
        // Helper function to estimate data size
        function getStorageUsage() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const size = new Blob([JSON.stringify(results)]).size;
                const photosCount = results.filter(r => r.capturedPhoto).length;
                
                return {
                    totalSize: size,
                    totalSizeMB: (size / 1024 / 1024).toFixed(2),
                    entriesCount: results.length,
                    photosCount: photosCount,
                    averagePhotoSize: photosCount > 0 ? (size / photosCount / 1024).toFixed(1) + 'KB' : 'N/A'
                };
            } catch (error) {
                return { error: error.message };
            }
        }
        
        // Show photo capture success feedback
        function showPhotoCaptureFeedback() {
            const feedbackDiv = document.createElement('div');
            feedbackDiv.className = 'fixed top-4 left-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50';
            feedbackDiv.innerHTML = `
                <div class="flex items-center">
                    <div class="text-2xl mr-3">üì∏</div>
                    <div>
                        <div class="text-sm font-medium">Photo Captured!</div>
                        <div class="text-xs mt-1">Analysis saved with pose overlay / ÂßøÂã¢„Ç™„Éº„Éê„Éº„É¨„Ç§‰ªò„Åç„Åß‰øùÂ≠ò</div>
                    </div>
                </div>
            `;
            document.body.appendChild(feedbackDiv);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                feedbackDiv.remove();
            }, 3000);
            
            // Haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate([50, 50, 50]);
            }
        }
        
        // Show photo in full-screen modal
        function showPhotoModal(analysisId) {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const analysis = results.find(result => result.id === analysisId);
                
                if (!analysis || !analysis.capturedPhoto) {
                    console.error('‚ùå Photo not found for analysis:', analysisId);
                    return;
                }
                
                const photo = analysis.capturedPhoto;
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="relative max-w-full max-h-full p-4">
                        <img src="${photo.imageData}" 
                             alt="Analysis Photo" 
                             class="max-w-full max-h-full object-contain rounded-lg shadow-2xl">
                        
                        <!-- Close button -->
                        <button onclick="this.parentElement.parentElement.remove()" 
                                class="absolute top-2 right-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white rounded-full w-10 h-10 flex items-center justify-center text-xl">
                            √ó
                        </button>
                        
                        <!-- Photo info overlay -->
                        <div class="absolute bottom-4 left-4 bg-black bg-opacity-70 text-white p-3 rounded-lg">
                            <div class="text-sm font-medium">${analysis.analysis_type.toUpperCase()} Analysis Photo</div>
                            <div class="text-xs opacity-75">${photo.width} √ó ${photo.height} ‚Ä¢ ${photo.cameraType} camera</div>
                            <div class="text-xs opacity-75">${new Date(photo.timestamp).toLocaleString('ja-JP')}</div>
                        </div>
                        
                        <!-- Action buttons -->
                        <div class="absolute bottom-4 right-4 space-x-2">
                            <button onclick="downloadPhoto('${analysisId}')" 
                                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-sm">
                                üíæ Download
                            </button>
                            <button onclick="sharePhoto('${analysisId}')" 
                                    class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm">
                                üì§ Share
                            </button>
                        </div>
                    </div>
                `;
                
                // Close modal on background click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };
                
                // Close modal on escape key
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
                
                document.body.appendChild(modal);
                console.log('‚úÖ Photo modal displayed');
                
            } catch (error) {
                console.error('‚ùå Error showing photo modal:', error);
            }
        }
        
        // Download photo function
        function downloadPhoto(analysisId) {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const analysis = results.find(result => result.id === analysisId);
                
                if (!analysis || !analysis.capturedPhoto) {
                    console.error('‚ùå Photo not found for download:', analysisId);
                    return;
                }
                
                const photo = analysis.capturedPhoto;
                const link = document.createElement('a');
                link.href = photo.imageData;
                link.download = `AthleteCore_${analysis.analysis_type}_${new Date(analysis.analysis_date).toISOString().slice(0, 19).replace(/[:]/g, '-')}.jpg`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('‚úÖ Photo download initiated');
                
                // Show success feedback
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'fixed bottom-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50';
                feedbackDiv.innerHTML = `
                    <div class="flex items-center">
                        <div class="text-xl mr-2">üíæ</div>
                        <div class="text-sm">Photo Downloaded!</div>
                    </div>
                `;
                document.body.appendChild(feedbackDiv);
                
                setTimeout(() => {
                    feedbackDiv.remove();
                }, 2000);
                
            } catch (error) {
                console.error('‚ùå Error downloading photo:', error);
            }
        }
        
        // Share photo function
        function sharePhoto(analysisId) {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const analysis = results.find(result => result.id === analysisId);
                
                if (!analysis || !analysis.capturedPhoto) {
                    console.error('‚ùå Photo not found for sharing:', analysisId);
                    return;
                }
                
                // Convert base64 to blob for sharing
                const base64Data = analysis.capturedPhoto.imageData.split(',')[1];
                const byteCharacters = atob(base64Data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'image/jpeg' });
                
                const file = new File([blob], `AthleteCore_Analysis_${analysis.analysis_type}.jpg`, { type: 'image/jpeg' });
                
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    navigator.share({
                        title: 'AthleteCore Pro Analysis',
                        text: `My ${analysis.analysis_type} analysis result: ${analysis.overall_score}/100`,
                        files: [file]
                    }).then(() => {
                        console.log('‚úÖ Photo shared successfully');
                    }).catch((error) => {
                        console.log('‚ùå Error sharing photo:', error);
                        fallbackShare(analysisId);
                    });
                } else {
                    fallbackShare(analysisId);
                }
                
            } catch (error) {
                console.error('‚ùå Error sharing photo:', error);
                fallbackShare(analysisId);
            }
        }
        
        // Fallback share function
        function fallbackShare(analysisId) {
            const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
            const analysis = results.find(result => result.id === analysisId);
            
            if (navigator.share) {
                navigator.share({
                    title: 'AthleteCore Pro Analysis',
                    text: `Check out my ${analysis.analysis_type} analysis result: ${analysis.overall_score}/100! üí™`,
                    url: window.location.href
                }).catch(console.error);
            } else {
                // Copy URL to clipboard
                navigator.clipboard.writeText(window.location.href).then(() => {
                    alert('Link copied to clipboard! / „É™„É≥„ÇØ„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                }).catch(() => {
                    alert('Analysis shared! / ÂàÜÊûêÁµêÊûú„ÇíÂÖ±Êúâ„Åó„Åæ„Åó„ÅüÔºÅ');
                });
            }
        }
        
        // Photo Comparison Functions
        let selectedPhotos = [];
        
        function showPhotoComparison() {
            console.log('üìä Showing photo comparison...');
            showScreen('photo-comparison');
            document.getElementById('photo-comparison').classList.add('fade-in');
            loadPhotosForComparison();
        }
        
        function loadPhotosForComparison() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const userResults = results.filter(result => 
                    result.user_id === currentUser.id && result.capturedPhoto
                );
                
                const photoGrid = document.getElementById('photoSelectionGrid');
                
                if (userResults.length === 0) {
                    photoGrid.innerHTML = `
                        <div class="col-span-2 text-center py-8">
                            <div class="text-4xl mb-2">üì∑</div>
                            <p class="text-gray-500">No photos available for comparison</p>
                            <p class="text-sm text-gray-400">ÂÜôÁúü„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì</p>
                        </div>
                    `;
                    return;
                }
                
                photoGrid.innerHTML = userResults.map(analysis => {
                    const photo = analysis.capturedPhoto;
                    const isSelected = selectedPhotos.includes(analysis.id);
                    
                    return `
                        <div class="relative cursor-pointer ${isSelected ? 'ring-4 ring-blue-500' : 'hover:ring-2 hover:ring-gray-300'} rounded-lg transition-all" 
                             onclick="togglePhotoSelection('${analysis.id}')">
                            <img src="${photo.imageData}" 
                                 alt="Analysis Photo" 
                                 class="w-full h-32 object-cover rounded-lg shadow-sm">
                            <div class="absolute top-2 left-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                                ${analysis.overall_score}/100
                            </div>
                            <div class="absolute top-2 right-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                                ${analysis.analysis_type}
                            </div>
                            <div class="absolute bottom-2 left-2 bg-black bg-opacity-70 text-white text-xs px-2 py-1 rounded">
                                ${new Date(analysis.analysis_date).toLocaleDateString('ja-JP', { month: 'short', day: 'numeric' })}
                            </div>
                            ${isSelected ? `
                                <div class="absolute inset-0 bg-blue-500 bg-opacity-20 rounded-lg flex items-center justify-center">
                                    <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center text-lg">
                                        ${selectedPhotos.indexOf(analysis.id) + 1}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
                
                console.log('üì∑ Loaded', userResults.length, 'photos for comparison');
                
            } catch (error) {
                console.error('‚ùå Error loading photos for comparison:', error);
            }
        }
        
        function togglePhotoSelection(analysisId) {
            const index = selectedPhotos.indexOf(analysisId);
            
            if (index > -1) {
                // Remove from selection
                selectedPhotos.splice(index, 1);
            } else {
                // Add to selection (max 2 photos)
                if (selectedPhotos.length < 2) {
                    selectedPhotos.push(analysisId);
                } else {
                    // Replace first selected photo
                    selectedPhotos[0] = selectedPhotos[1];
                    selectedPhotos[1] = analysisId;
                }
            }
            
            console.log('üìä Selected photos:', selectedPhotos);
            
            // Refresh the photo grid
            loadPhotosForComparison();
            
            // Show or hide comparison
            if (selectedPhotos.length === 2) {
                showComparison();
            } else {
                hideComparison();
            }
        }
        
        function showComparison() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const photo1 = results.find(r => r.id === selectedPhotos[0]);
                const photo2 = results.find(r => r.id === selectedPhotos[1]);
                
                if (!photo1 || !photo2) {
                    console.error('‚ùå Photos not found for comparison');
                    return;
                }
                
                // Determine which is "before" and which is "after" based on date
                const [beforeAnalysis, afterAnalysis] = new Date(photo1.analysis_date) < new Date(photo2.analysis_date) 
                    ? [photo1, photo2] : [photo2, photo1];
                
                // Show comparison display
                document.getElementById('comparisonDisplay').classList.remove('hidden');
                document.getElementById('comparisonEmptyState').classList.add('hidden');
                
                // Update photos
                document.getElementById('beforePhoto').src = beforeAnalysis.capturedPhoto.imageData;
                document.getElementById('afterPhoto').src = afterAnalysis.capturedPhoto.imageData;
                
                // Update labels and dates
                document.getElementById('beforeDate').textContent = new Date(beforeAnalysis.analysis_date).toLocaleDateString('ja-JP');
                document.getElementById('afterDate').textContent = new Date(afterAnalysis.analysis_date).toLocaleDateString('ja-JP');
                document.getElementById('beforeScore').textContent = `${beforeAnalysis.overall_score}/100`;
                document.getElementById('afterScore').textContent = `${afterAnalysis.overall_score}/100`;
                
                // Create score comparison
                createScoreComparison(beforeAnalysis, afterAnalysis);
                
                console.log('‚úÖ Comparison displayed successfully');
                
            } catch (error) {
                console.error('‚ùå Error showing comparison:', error);
            }
        }
        
        function createScoreComparison(beforeAnalysis, afterAnalysis) {
            const scoreFields = [
                {key: 'overall_score', label: 'Overall Score / Á∑èÂêà„Çπ„Ç≥„Ç¢'},
                {key: 'hip_flexibility', label: 'Hip Flexibility / ËÇ°Èñ¢ÁØÄÊüîËªüÊÄß'},
                {key: 'postural_stability', label: 'Postural Stability / ÂßøÂã¢ÂÆâÂÆöÊÄß'},
                {key: 'dynamic_balance', label: 'Dynamic Balance / ÂãïÁöÑ„Éê„É©„É≥„Çπ'}
            ];
            
            const comparisonContainer = document.getElementById('scoreComparison');
            const progressContainer = document.getElementById('progressAnalysis');
            
            let improvementCount = 0;
            let totalImprovement = 0;
            
            comparisonContainer.innerHTML = scoreFields.map(field => {
                const beforeScore = beforeAnalysis[field.key] || 0;
                const afterScore = afterAnalysis[field.key] || 0;
                const difference = afterScore - beforeScore;
                const improvement = difference > 0;
                const decline = difference < 0;
                
                if (improvement) {
                    improvementCount++;
                    totalImprovement += difference;
                }
                
                return `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                        <div class="flex-1">
                            <div class="text-sm font-medium text-gray-800">${field.label}</div>
                        </div>
                        <div class="flex items-center space-x-4">
                            <div class="text-sm text-gray-600">${beforeScore}</div>
                            <div class="text-2xl ${improvement ? 'text-green-500' : decline ? 'text-red-500' : 'text-gray-400'}">
                                ${improvement ? '‚Üí' : decline ? '‚Üì' : '='}
                            </div>
                            <div class="text-sm font-medium ${improvement ? 'text-green-600' : decline ? 'text-red-600' : 'text-gray-600'}">
                                ${afterScore}
                            </div>
                            <div class="text-xs ${improvement ? 'text-green-600' : decline ? 'text-red-600' : 'text-gray-400'} min-w-16 text-right">
                                ${difference > 0 ? '+' : ''}${difference}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Generate progress analysis
            const daysDifference = Math.ceil((new Date(afterAnalysis.analysis_date) - new Date(beforeAnalysis.analysis_date)) / (1000 * 60 * 60 * 24));
            const overallImprovement = afterAnalysis.overall_score - beforeAnalysis.overall_score;
            
            let progressText = '';
            if (overallImprovement > 0) {
                progressText = `üéâ Great progress! Your overall score improved by ${overallImprovement} points over ${daysDifference} days. `;
                progressText += `${improvementCount} out of ${scoreFields.length} metrics showed improvement. `;
                progressText += `Á¥†Êô¥„Çâ„Åó„ÅÑÈÄ≤Ê≠©„Åß„ÅôÔºÅ${daysDifference}Êó•Èñì„ÅßÁ∑èÂêà„Çπ„Ç≥„Ç¢„Åå${overallImprovement}ÁÇπÂêë‰∏ä„Åó„Åæ„Åó„Åü„ÄÇ`;
            } else if (overallImprovement < 0) {
                progressText = `üìâ Your overall score decreased by ${Math.abs(overallImprovement)} points over ${daysDifference} days. `;
                progressText += `Focus on consistent training to improve your results. `;
                progressText += `Á∑èÂêà„Çπ„Ç≥„Ç¢„Åå${Math.abs(overallImprovement)}ÁÇπ‰∏ã„Åå„Çä„Åæ„Åó„Åü„ÄÇÁ∂ôÁ∂öÁöÑ„Å™„Éà„É¨„Éº„Éã„É≥„Ç∞„Å´ÈõÜ‰∏≠„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ`;
            } else {
                progressText = `üìä Your overall score remained stable over ${daysDifference} days. `;
                progressText += `Consider varying your training routine for continued improvement. `;
                progressText += `Á∑èÂêà„Çπ„Ç≥„Ç¢„ÅØÂÆâÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊõ¥„Å™„ÇãÂêë‰∏ä„ÅÆ„Åü„ÇÅ„ÄÅ„Éà„É¨„Éº„Éã„É≥„Ç∞ÂÜÖÂÆπ„ÇíÂ§âÂåñ„Åï„Åõ„Çã„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
            }
            
            progressContainer.textContent = progressText;
        }
        
        function hideComparison() {
            document.getElementById('comparisonDisplay').classList.add('hidden');
            document.getElementById('comparisonEmptyState').classList.remove('hidden');
        }
        
        function resetComparison() {
            selectedPhotos = [];
            loadPhotosForComparison();
            hideComparison();
            console.log('üîÑ Comparison reset');
        }
        
        function loadAnalysisHistory() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const historyContainer = document.getElementById('analysisHistory');
                
                // Debug: Check if currentUser exists
                if (!currentUser) {
                    console.warn('‚ùå No current user found for history loading');
                    historyContainer.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">Please register first / „Åæ„ÅöÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>';
                    return;
                }
                
                console.log('üìä Loading history for user:', currentUser.id);
                const userResults = results.filter(result => result.user_id === currentUser.id);
                console.log('üóÇÔ∏è Found analysis results:', userResults.length);
                
                if (userResults.length === 0) {
                    // Add sample data for demonstration if no results exist
                    const sampleData = createSampleAnalysisData();
                    if (sampleData.length > 0) {
                        // Save sample data to localStorage
                        const allResults = [...results, ...sampleData];
                        localStorage.setItem('athletecore_results', JSON.stringify(allResults));
                        console.log('üìù Created sample analysis data for demonstration');
                        // Reload with sample data
                        loadAnalysisHistory();
                        return;
                    }
                    
                    historyContainer.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No analysis yet / „Åæ„Å†ÂàÜÊûê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
                    return;
                }
                
                historyContainer.innerHTML = userResults.slice(-5).reverse().map((analysis, index) => {
                    const date = new Date(analysis.analysis_date).toLocaleDateString('ja-JP');
                    const time = new Date(analysis.analysis_date).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
                    const typeLabel = {
                        'static': 'Static / ÈùôÁöÑ',
                        'dynamic': 'Dynamic / ÂãïÁöÑ',
                        'sport_specific': 'Sport / Á´∂ÊäÄÁâπÂåñ'
                    };
                    
                    return `
                        <div class="bg-white p-3 rounded-lg border border-gray-100 cursor-pointer hover:shadow-md transition-shadow" 
                             onclick="console.log('üñ±Ô∏è Clicked analysis:', '${analysis.id}'); showAnalysisDetail('${analysis.id}');"
                             data-analysis-id="${analysis.id}">
                            <div class="flex justify-between items-center">
                                <div>
                                    <div class="text-sm font-medium brand-color">${typeLabel[analysis.analysis_type] || analysis.analysis_type}</div>
                                    <div class="text-xs text-gray-500">${date} ${time}</div>
                                    <div class="text-xs text-gray-400">ID: ${analysis.id.slice(-8)}</div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-bold ${analysis.overall_score >= 80 ? 'text-green-600' : 'text-orange-600'}">${analysis.overall_score}/100</div>
                                    <div class="text-xs text-gray-400">‚Üí</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add "View All" button if there are more than 5 results
                if (userResults.length > 5) {
                    historyContainer.innerHTML += `
                        <div class="text-center mt-4">
                            <button onclick="showAnalysisHistory()" class="text-blue-600 text-sm font-medium hover:underline">
                                View All History (${userResults.length}) / ÂÖ®Â±•Ê≠¥„ÇíË¶ã„Çã (${userResults.length}‰ª∂)
                            </button>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error loading history:', error);
                document.getElementById('analysisHistory').innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No analysis yet / „Åæ„Å†ÂàÜÊûê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
            }
        }
        
        async function showStaticAnalysis() {
            console.log('üéØ Starting static analysis...');
            showScreen('static-analysis');
            document.getElementById('static-analysis').classList.add('slide-up');
            
            // Initialize MediaPipe if not already done
            if (!pose) {
                console.log('üß† Initializing MediaPipe...');
                const initialized = await initMediaPipe();
                if (!initialized) {
                    console.error('‚ùå Failed to initialize MediaPipe for static analysis');
                    return;
                }
            } else {
                console.log('‚úÖ MediaPipe already initialized');
            }
            
            // Reset to front camera
            currentFacingMode = 'user';
            console.log('üì± Set to front camera mode');
            
            // Initialize camera and pose detection with debug
            setTimeout(async () => {
                console.log('üé• Initializing camera for static analysis...');
                const cameraInitialized = await initCamera('staticCameraFeed', 'staticCameraPlaceholder', 'user');
                
                if (cameraInitialized) {
                    console.log('‚úÖ Camera initialized, waiting for video to be ready...');
                    
                    // Check video element immediately
                    const videoElement = document.getElementById('staticCameraFeed');
                    if (videoElement) {
                        console.log('üì∫ Video element state:', {
                            srcObject: !!videoElement.srcObject,
                            videoWidth: videoElement.videoWidth,
                            videoHeight: videoElement.videoHeight,
                            readyState: videoElement.readyState,
                            display: videoElement.style.display,
                            visibility: videoElement.style.visibility
                        });
                    }
                    
                    // Wait a bit more for video to be ready
                    setTimeout(() => {
                        console.log('üé¨ Starting pose detection...');
                        startPoseDetection('staticCameraFeed', 'staticPoseCanvas', 'staticPoseStatus');
                    }, 1000);
                } else {
                    console.error('‚ùå Camera initialization failed');
                }
            }, 500);
        }
        
        async function showDynamicAnalysis() {
            showScreen('dynamic-analysis');
            document.getElementById('dynamic-analysis').classList.add('slide-up');
            
            // Reset squat counter
            currentSquatCount = 0;
            lastSquatPhase = 'standing';
            const countElement = document.getElementById('squatCount');
            if (countElement) countElement.textContent = '0';
            
            // Initialize MediaPipe if not already done
            if (!pose) {
                const initialized = await initMediaPipe();
                if (!initialized) {
                    console.error('Failed to initialize MediaPipe for dynamic analysis');
                    return;
                }
            }
            
            // Reset to front camera
            currentFacingMode = 'user';
            
            // Initialize camera and pose detection
            setTimeout(async () => {
                const cameraInitialized = await initCamera('dynamicCameraFeed', 'dynamicCameraPlaceholder', 'user');
                if (cameraInitialized) {
                    // Wait a bit more for video to be ready
                    setTimeout(() => {
                        startPoseDetection('dynamicCameraFeed', 'dynamicPoseCanvas', 'dynamicPoseStatus');
                    }, 1000);
                }
            }, 500);
        }
        
        function showSportSpecific() {
            showDynamicAnalysis(); // For demo purposes
        }
        
        function showResults() {
            showScreen('results');
            document.getElementById('results').classList.add('fade-in');
        }
        
        function selectSport(sport) {
            // „Éè„Éó„ÉÜ„Ç£„ÇØ„Çπ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('bg-blue-50', 'brand-color', 'font-medium');
                btn.classList.add('text-gray-600');
            });
            
            event.target.classList.add('bg-blue-50', 'brand-color', 'font-medium');
        }
        
        // Voice speech function for countdown
        let voicesLoaded = false;
        let preferredVoice = null;
        
        // Initialize voices when available
        let speechEnabled = false;
        
        // Web Audio API for reliable sound feedback (alternative to speech synthesis)
        let audioContext = null;
        let soundEnabled = false;
        
        function initializeAudioContext() {
            try {
                if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    soundEnabled = true;
                    console.log('‚úÖ Audio context initialized');
                    return true;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Audio context initialization failed:', error);
            }
            return false;
        }
        
        function playCountdownBeep(frequency = 800, duration = 200, isWarning = false) {
            if (!soundEnabled || !audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different frequencies and patterns for different countdown states
                if (isWarning) {
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.1);
                } else {
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                }
                
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
                
                console.log(`üîä Played beep: ${frequency}Hz for ${duration}ms`);
            } catch (error) {
                console.warn('‚ö†Ô∏è Beep sound failed:', error);
            }
        }
        
        function playSuccessChime() {
            if (!soundEnabled || !audioContext) return;
            
            try {
                // Play a pleasant ascending chime
                const frequencies = [523, 659, 784]; // C, E, G notes
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        playCountdownBeep(freq, 300, false);
                    }, index * 150);
                });
                console.log('üéµ Played success chime');
            } catch (error) {
                console.warn('‚ö†Ô∏è Success chime failed:', error);
            }
        }
        
        function initializeVoices() {
            if ('speechSynthesis' in window) {
                const loadVoices = () => {
                    const voices = speechSynthesis.getVoices();
                    if (voices.length > 0 && !voicesLoaded) {
                        voicesLoaded = true;
                        // Try to find a good English voice
                        preferredVoice = voices.find(voice => 
                            voice.lang.startsWith('en') && 
                            (voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.name.includes('Apple'))
                        ) || voices.find(voice => voice.lang.startsWith('en')) || voices[0];
                        
                        console.log('‚úÖ Voice initialized:', preferredVoice ? preferredVoice.name : 'Default voice');
                        console.log('Available voices:', voices.length);
                        
                        // Test voice functionality
                        if (preferredVoice) {
                            console.log('Selected voice details:', {
                                name: preferredVoice.name,
                                lang: preferredVoice.lang,
                                localService: preferredVoice.localService
                            });
                        }
                    }
                };
                
                // Load voices immediately if available
                loadVoices();
                
                // Also load when voices change (for some browsers)
                speechSynthesis.onvoiceschanged = loadVoices;
                
                // Force load voices after a delay
                setTimeout(loadVoices, 1000);
                setTimeout(loadVoices, 3000); // Additional retry
            } else {
                console.warn('Speech synthesis not supported');
            }
        }
        
        // Enable speech and audio after user interaction
        function enableSpeech() {
            // Enable speech synthesis
            if (!speechEnabled && 'speechSynthesis' in window) {
                try {
                    const testUtterance = new SpeechSynthesisUtterance('');
                    testUtterance.volume = 0;
                    speechSynthesis.speak(testUtterance);
                    speechEnabled = true;
                    console.log('‚úÖ Speech enabled after user interaction');
                } catch (error) {
                    console.error('Failed to enable speech:', error);
                }
            }
            
            // Enable Web Audio API
            if (!soundEnabled) {
                initializeAudioContext();
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('‚úÖ Audio context resumed after user interaction');
                    });
                }
            }
        }
        
        function speakCountdown(text, shouldSpeak = true) {
            // Only speak if enabled and speech synthesis is available
            if (shouldSpeak && 'speechSynthesis' in window && speechEnabled) {
                console.log('üîä Attempting to speak:', text);
                
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                // Small delay to ensure cancellation is processed
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'en-US';
                    utterance.rate = 0.8;  // Slightly slower for clarity
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0; // Maximum volume
                    
                    // Use preferred voice if available
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                        console.log('Using voice:', preferredVoice.name);
                    }
                    
                    // Add comprehensive error handling
                    utterance.onerror = (event) => {
                        console.error('‚ùå Speech synthesis error:', event.error, 'for text:', text);
                    };
                    
                    utterance.onstart = () => {
                        console.log('‚úÖ Speech started:', text);
                    };
                    
                    utterance.onend = () => {
                        console.log('‚úÖ Speech ended:', text);
                    };
                    
                    try {
                        speechSynthesis.speak(utterance);
                        console.log('üîä Speech queued:', text);
                    } catch (error) {
                        console.error('‚ùå Speech synthesis failed:', error);
                    }
                }, 50);
            } else {
                if (!speechEnabled) {
                    console.warn('‚ö†Ô∏è Speech not enabled - user interaction required');
                } else {
                    console.log('Speech not available or disabled');
                }
            }
        }
        
        // Improved static capture with countdown
        async function startStaticCaptureImproved() {
            // Enable speech after user interaction
            enableSpeech();
            
            // Check if we're using front camera for voice enablement
            const isFrontCamera = currentFacingMode === 'user';
            console.log('Starting static capture, front camera:', isFrontCamera, 'facing mode:', currentFacingMode);
            
            // Test voice immediately if front camera
            if (isFrontCamera) {
                console.log('üó£Ô∏è Testing voice before countdown...');
                // Wait a moment for speech to be fully enabled
                setTimeout(() => {
                    speakCountdown('Are you ready', true);
                }, 200);
            }
            
            // Enter fullscreen mode at the start of countdown for better positioning
            console.log('üì± Entering fullscreen mode for static capture');
            enterFullscreenMode('static');
            
            // Keep existing camera view active (no fullscreen overlay to preserve MediaPipe)
            
            // Disable and hide floating button during countdown
            const bottomButton = document.getElementById('staticCaptureBtn');
            const floatingButton = document.getElementById('floatingStaticBtn');
            if (bottomButton) bottomButton.disabled = true;
            if (floatingButton) {
                floatingButton.disabled = true;
                hideFloatingButton('static');
            }
            
            // Show countdown overlay
            const screenElement = document.getElementById('static-analysis');
            
            // Create enhanced countdown overlay with dramatic animations
            const overlay = document.createElement('div');
            overlay.id = 'staticCountdownOverlay';
            overlay.className = 'fixed inset-0 bg-transparent flex items-center justify-center';
            overlay.style.zIndex = '45'; // Above MediaPipe canvas (z-30) but not blocking everything
            overlay.innerHTML = `
                <!-- Minimal Top-Right Counter -->
                <div class="absolute top-4 right-4 text-center text-white bg-black bg-opacity-75 px-3 py-2 rounded-lg shadow-lg border border-white border-opacity-20 backdrop-blur-sm" style="min-width: 80px;">
                    <div class="text-2xl font-bold mb-1 text-white transition-all duration-200 ease-out" id="staticCountdownNumber" style="text-shadow: 0 0 10px rgba(255,255,255,0.6);">10</div>
                    <div class="text-xs opacity-75 mb-1" id="countdownMessage">Are you ready?</div>
                    <div class="w-8 h-0.5 bg-gradient-to-r from-green-400 to-blue-500 rounded-full mx-auto" id="countdownProgress"></div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            let currentCount = 10; // Start at 10 for 10-second countdown
            const countdownNumber = document.getElementById('staticCountdownNumber');
            
            /* 
            Timing Table:
            Time 0s: currentCount=10, first setInterval call ‚Üí currentCount=9 (display "9")
            Time 1s: currentCount=9, second call ‚Üí currentCount=8 (display "8") 
            Time 2s: currentCount=8 ‚Üí currentCount=7 (display "7")
            Time 3s: currentCount=7 ‚Üí currentCount=6 (display "6")
            Time 4s: currentCount=6 ‚Üí currentCount=5 (display "5")
            Time 5s: currentCount=5 ‚Üí currentCount=4 (display "4")
            Time 6s: currentCount=4 ‚Üí currentCount=3 (display "3")
            Time 7s: currentCount=3 ‚Üí currentCount=2 (display "2")
            Time 8s: currentCount=2 ‚Üí currentCount=1 (display "1" + CAPTURE PHOTO)
            Time 9s: currentCount=1 ‚Üí currentCount=0 (display "GO!" + FLASH)
            */
            
            const countdownInterval = setInterval(() => {
                currentCount--;
                
                if (currentCount > 0) {
                    // Enhanced visual countdown with dramatic effects
                    countdownNumber.textContent = currentCount;
                    
                    // CRITICAL: Execute photo capture at count=1 (9 seconds after countdown start) to eliminate timing lag
                    if (currentCount === 1) {
                        console.log('üì∏ Executing photo capture at count=1 (9 seconds after countdown start)');
                        
                        // Perform actual photo capture immediately 
                        setTimeout(() => {
                            // Capture photo with current pose data
                            const analysisData = performPoseAnalysis(currentPoseResults ? currentPoseResults.poseLandmarks : null);
                            
                            let capturedPhoto = null;
                            try {
                                // Determine active video element for static analysis
                                const activeVideo = document.getElementById('staticCameraFeed');
                                if (activeVideo && activeVideo.videoWidth > 0) {
                                    capturedPhoto = capturePhotoWithPoseOverlay(activeVideo, 'staticPoseCanvas', currentPoseResults);
                                    console.log('‚úÖ Photo captured at count=1:', capturedPhoto ? 'Success' : 'Failed');
                                } else {
                                    console.warn('‚ö†Ô∏è No active video for photo capture at count=1');
                                }
                            } catch (captureError) {
                                console.error('‚ùå Photo capture error at count=1:', captureError);
                            }
                            
                            // Store analysis data and photo immediately
                            if (currentUser) {
                                const resultData = {
                                    id: generateUUID(),
                                    user_id: currentUser.id,
                                    analysis_type: 'static',
                                    sport: currentUser.primary_sport,
                                    analysis_date: new Date().toISOString(),
                                    capturedPhoto: capturedPhoto,
                                    repetitions_performed: 0,
                                    ...analysisData
                                };
                                
                                saveAnalysisResultLocal(resultData);
                                
                                if (capturedPhoto) {
                                    console.log('‚úÖ Static analysis with photo saved at count=1');
                                    showPhotoCaptureFeedback();
                                } else {
                                    console.warn('‚ö†Ô∏è Static analysis saved without photo at count=1');
                                }
                            }
                            
                            // Update results display
                            updateResultsDisplay(analysisData);
                            
                        }, 50); // Small delay to ensure pose detection is current
                    }
                    
                    // Dynamic color transitions based on countdown
                    let color, shadowColor, pulseIntensity;
                    if (currentCount > 7) {
                        color = '#10B981'; // Green
                        shadowColor = 'rgba(16,185,129,0.8)';
                        pulseIntensity = '0 0 40px rgba(16,185,129,0.8)';
                    } else if (currentCount > 3) {
                        color = '#F59E0B'; // Amber
                        shadowColor = 'rgba(245,158,11,0.8)';
                        pulseIntensity = '0 0 50px rgba(245,158,11,0.8)';
                    } else {
                        color = '#EF4444'; // Red
                        shadowColor = 'rgba(239,68,68,0.8)';
                        pulseIntensity = '0 0 60px rgba(239,68,68,0.9)';
                    }
                    
                    // Apply dynamic styling - minimal for small display
                    countdownNumber.style.color = color;
                    countdownNumber.style.textShadow = `0 0 10px ${shadowColor}`;
                    countdownNumber.style.transform = 'scale(1.05)';
                    
                    // Add very subtle animation
                    setTimeout(() => {
                        countdownNumber.style.transform = 'scale(1.0)';
                    }, 100);
                    
                    // Update progress bar
                    const progressBar = document.getElementById('countdownProgress');
                    if (progressBar) {
                        const progressWidth = ((10 - currentCount) / 10) * 100;
                        progressBar.style.width = `${progressWidth}%`;
                        progressBar.style.background = color;
                    }
                    
                    // Update message
                    const messageElement = document.getElementById('countdownMessage');
                    if (messageElement && currentCount <= 5) {
                        messageElement.textContent = 'Get ready!';
                    }
                    
                    // No screen flash effect for minimal display
                    
                    // Multi-modal feedback: Voice + Audio + Haptic
                    
                    // Voice countdown only for front camera with slight delay
                    if (isFrontCamera) {
                        setTimeout(() => {
                            speakCountdown(currentCount.toString(), true);
                        }, 100);
                    }
                    
                    // Audio beep feedback (reliable alternative to speech)
                    setTimeout(() => {
                        if (currentCount <= 3) {
                            playCountdownBeep(1000, 150, true); // Higher frequency, warning beep
                        } else if (currentCount <= 5) {
                            playCountdownBeep(800, 200, false); // Medium frequency
                        } else {
                            playCountdownBeep(600, 250, false); // Lower frequency
                        }
                    }, 50);
                    
                    // Enhanced haptic feedback pattern
                    if (navigator.vibrate) {
                        if (currentCount <= 3) {
                            navigator.vibrate([100, 50, 100]); // Urgent pattern
                        } else {
                            navigator.vibrate(80); // Regular pulse
                        }
                    }
                } else {
                    // Count=0: Final UI sequence only (photo already captured at count=1)
                    countdownNumber.textContent = 'GO!';
                    countdownNumber.style.transform = 'scale(1.1)';
                    countdownNumber.style.color = '#10B981'; // Bright green
                    countdownNumber.style.textShadow = '0 0 10px rgba(16,185,129,1)';
                    
                    // Full progress bar
                    const progressBar = document.getElementById('countdownProgress');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                        progressBar.style.background = '#10B981';
                    }
                    
                    // Update message
                    const messageElement = document.getElementById('countdownMessage');
                    if (messageElement) {
                        messageElement.textContent = 'Captured!'; // Changed to past tense since capture already done
                    }
                    
                    // Final "Captured!" multi-modal feedback - immediate since photo already taken
                    
                    // Voice "Captured!" only for front camera - immediate feedback
                    if (isFrontCamera) {
                        setTimeout(() => {
                            speakCountdown('Captured!', true);
                        }, 50); // Faster feedback
                    }
                    
                    // Success audio chime (reliable for all users) - immediate
                    setTimeout(() => {
                        playSuccessChime();
                    }, 100); // Faster audio feedback
                    
                    // Strong haptic feedback for capture complete - immediate
                    if (navigator.vibrate) {
                        navigator.vibrate([150, 30, 150, 30, 150]); // More distinctive pattern for success
                    }
                    
                    // Immediate flash effect at count=0 for better user experience
                    const flash = document.createElement('div');
                    flash.className = 'fixed inset-0 bg-white';
                    flash.style.zIndex = '50'; // Highest priority for immediate visual feedback
                    flash.style.opacity = '0';
                    document.body.appendChild(flash);
                    
                    // Instant flash animation for immediate feedback
                    flash.style.transition = 'opacity 0.1s';
                    flash.style.opacity = '0.8'; // Stronger flash since photo is already taken
                    
                    setTimeout(() => {
                        flash.style.opacity = '0';
                        setTimeout(() => {
                            flash.remove();
                        }, 100);
                    }, 150); // Slightly longer flash for better effect
                    
                    setTimeout(() => {
                        overlay.remove();
                        
                        // Photo capture and analysis already completed at count=1
                        // Just perform UI cleanup
                        console.log('‚úÖ Static capture UI sequence completed');
                        
                        // Re-enable buttons
                        if (bottomButton) {
                            bottomButton.disabled = false;
                            bottomButton.textContent = 'Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã';
                        }
                        if (floatingButton) {
                            floatingButton.disabled = false;
                        }
                        
                        // Exit fullscreen mode after capture
                        console.log('üì± Exiting fullscreen mode after static capture completion');
                        exitFullscreenMode('static');
                        
                        // ÂàÜÊûêÂÆå‰∫Ü„ÅÆÊåØÂãï„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                        if (navigator.vibrate) {
                            navigator.vibrate([200, 100, 200]);
                        }
                        
                        // Show results immediately since analysis is already done
                        showResults();
                    }, 800); // Reduced delay since processing is already complete
                    
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        async function startStaticCapture() {
            console.log('üéØ Starting static capture analysis (after countdown)...');
            
            // Start actual analysis immediately (countdown already done in Improved function)
            isAnalyzing = true;
            
            // Update UI to show analyzing state
            const button = document.getElementById('staticCaptureBtn');
            if (button) {
                button.disabled = true;
                button.textContent = 'Analyzing... / ÂàÜÊûê‰∏≠...';
            }
            
            // Capture pose data for 3 seconds
            let analysisResults = [];
            const captureInterval = setInterval(() => {
                if (currentPoseResults && currentPoseResults.poseLandmarks) {
                    const analysis = performPoseAnalysis(currentPoseResults.poseLandmarks);
                    if (analysis) {
                        analysisResults.push(analysis);
                    }
                }
            }, 100); // Capture every 100ms
            
            setTimeout(async () => {
                    clearInterval(captureInterval);
                    isAnalyzing = false;
                    
                    // üì∏ Capture photo with pose overlay
                    console.log('üì∏ Capturing static analysis photo...');
                    console.log('üé• Current video element state before capture:', {
                        videoId: 'staticCameraFeed',
                        videoExists: !!document.getElementById('staticCameraFeed'),
                        canvasId: 'staticPoseCanvas', 
                        canvasExists: !!document.getElementById('staticPoseCanvas'),
                        hasPoseResults: !!currentPoseResults,
                        hasLandmarks: !!(currentPoseResults && currentPoseResults.poseLandmarks)
                    });
                    
                    const capturedPhoto = capturePhoto('staticCameraFeed', 'staticPoseCanvas', true);
                    
                    console.log('üì∏ Photo capture result:', {
                        captureSuccessful: !!capturedPhoto,
                        hasImageData: !!(capturedPhoto && capturedPhoto.imageData),
                        imageSize: capturedPhoto ? (capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                        dimensions: capturedPhoto ? `${capturedPhoto.width}x${capturedPhoto.height}` : 'N/A',
                        hasPoseOverlay: capturedPhoto ? capturedPhoto.hasPoseOverlay : false
                    });
                    
                    // Process captured analysis data
                    let analysisData;
                    if (analysisResults.length > 0) {
                        analysisData = processStaticAnalysisResults(analysisResults);
                    } else {
                        // Fallback to generated data if no pose detected
                        analysisData = generateAnalysisData('static');
                    }
                    
                    if (currentUser) {
                        const resultData = {
                            id: generateUUID(),
                            user_id: currentUser.id,
                            analysis_type: 'static',
                            sport: currentUser.primary_sport,
                            analysis_date: new Date().toISOString(),
                            capturedPhoto: capturedPhoto, // üì∏ Add photo data
                            ...analysisData
                        };
                        
                        console.log('üíæ Saving analysis result with photo data:', {
                            analysisId: resultData.id,
                            userId: resultData.user_id,
                            hasPhoto: !!resultData.capturedPhoto,
                            photoSize: resultData.capturedPhoto ? (resultData.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                            analysisType: resultData.analysis_type
                        });
                        
                        // „É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò
                        saveAnalysisResultLocal(resultData);
                        
                        // üîç Debug: Immediately verify the data was saved
                        setTimeout(() => {
                            const savedResults = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                            const savedEntry = savedResults.find(r => r.id === resultData.id);
                            console.log('üîç Verification after save:', {
                                entryFound: !!savedEntry,
                                hasPhoto: !!(savedEntry && savedEntry.capturedPhoto),
                                photoDataExists: !!(savedEntry && savedEntry.capturedPhoto && savedEntry.capturedPhoto.imageData)
                            });
                        }, 100);
                        
                        // Show photo capture success
                        if (capturedPhoto) {
                            console.log('‚úÖ Photo captured and saved with analysis');
                            showPhotoCaptureFeedback();
                        } else {
                            console.warn('‚ö†Ô∏è No photo was captured during static analysis');
                        }
                    } else {
                        console.error('‚ùå No currentUser found, cannot save analysis');
                    }
                    
                    updateResultsDisplay(analysisData);
                    
                    // Re-enable button
                    const button = document.getElementById('staticCaptureBtn');
                    if (button) {
                        button.disabled = false;
                        button.textContent = 'Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã';
                    }
                    
                    // ÂàÜÊûêÂÆå‰∫Ü„ÅÆÊåØÂãï„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 100, 200]);
                    }
                    
                    // Exit fullscreen mode after static capture is completed
                    console.log('üì± Exiting fullscreen mode after static capture completion');
                    exitFullscreenMode('static');
                    
                    showResults();
                }, 3000);
        }
        
        // Improved dynamic capture with movement detection
        async function startDynamicCaptureImproved() {
            // Enter fullscreen mode at the start of capture for better positioning
            console.log('üì± Entering fullscreen mode for dynamic capture');
            enterFullscreenMode('dynamic');
            
            // Keep existing camera view active (no fullscreen overlay to preserve MediaPipe)
            
            // Disable and hide floating button during recording
            const bottomButton = document.getElementById('dynamicCaptureBtn');
            const floatingButton = document.getElementById('floatingDynamicBtn');
            if (bottomButton) {
                bottomButton.disabled = true;
                bottomButton.textContent = 'Ready to move... / Âãï‰ΩúÊ∫ñÂÇô‰∏≠...';
            }
            if (floatingButton) {
                floatingButton.disabled = true;
                floatingButton.textContent = 'Ready to move... / Âãï‰ΩúÊ∫ñÂÇô‰∏≠...';
                hideFloatingButton('dynamic');
            }
            
            // Wait for movement to start
            isWaitingForMovement = true;
            movementAnalysisData = [];
            isAnalyzing = true;
            
            // Show waiting indicator
            const screenElement = document.getElementById('dynamic-analysis');
            const waitingOverlay = document.createElement('div');
            waitingOverlay.id = 'dynamicWaitingOverlay';
            waitingOverlay.className = 'fixed top-20 left-4 right-4 text-center';
            waitingOverlay.style.zIndex = '45'; // Above MediaPipe canvas but not blocking everything
            waitingOverlay.innerHTML = `
                <div class="bg-blue-600 bg-opacity-80 text-white px-4 py-3 rounded-lg shadow-lg border border-white border-opacity-20">
                    <div class="text-lg font-medium mb-1">ü§∏‚Äç‚ôÇÔ∏è Ready to start!</div>
                    <div class="text-sm">Start moving to begin recording</div>
                    <div class="text-xs opacity-75">Âãï„ÅçÂßã„ÇÅ„Çã„Å®Èå≤Áîª„ÅåÈñãÂßã„Åï„Çå„Åæ„Åô</div>
                </div>
            `;
            document.body.appendChild(waitingOverlay);
            
            let previousLandmarks = null;
            const checkMovementInterval = setInterval(() => {
                if (currentPoseResults && currentPoseResults.poseLandmarks) {
                    const landmarks = currentPoseResults.poseLandmarks;
                    
                    if (previousLandmarks) {
                        // Calculate movement intensity between frames
                        let totalMovement = 0;
                        const keyJoints = [11, 12, 23, 24, 25, 26]; // shoulders, hips, knees
                        
                        keyJoints.forEach(index => {
                            const current = landmarks[index];
                            const previous = previousLandmarks[index];
                            if (current && previous && current.visibility > 0.5) {
                                const movement = Math.abs(current.x - previous.x) + Math.abs(current.y - previous.y);
                                totalMovement += movement;
                            }
                        });
                        
                        const movementIntensity = totalMovement / keyJoints.length;
                        
                        // Detect significant movement (threshold can be adjusted)
                        if (movementIntensity > 0.01 && !movementStartTime) {
                            movementStartTime = Date.now();
                            isWaitingForMovement = false;
                            clearInterval(checkMovementInterval);
                            waitingOverlay.remove();
                            
                            // Voice announcement removed - only for static front camera
                            // Strong haptic feedback for movement start
                            if (navigator.vibrate) {
                                navigator.vibrate([200, 100, 200]);
                            }
                            
                            // Start 15-second recording timer
                            startRecordingTimer(screenElement, 15, () => {
                                // Recording complete
                                isAnalyzing = false;
                                
                                // Exit fullscreen mode
                                exitFullscreenMode('dynamic');
                                
                                // Re-enable buttons
                                if (bottomButton) {
                                    bottomButton.disabled = false;
                                    bottomButton.textContent = 'Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã';
                                }
                                if (floatingButton) {
                                    floatingButton.disabled = false;
                                    floatingButton.textContent = 'Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã';
                                }
                                
                                // üì∏ Capture photo with pose overlay at end of movement
                                console.log('üì∏ Capturing dynamic analysis photo...');
                                console.log('üé• Current video element state before capture:', {
                                    videoId: 'dynamicCameraFeed',
                                    videoExists: !!document.getElementById('dynamicCameraFeed'),
                                    canvasId: 'dynamicPoseCanvas', 
                                    canvasExists: !!document.getElementById('dynamicPoseCanvas'),
                                    hasPoseResults: !!currentPoseResults,
                                    hasLandmarks: !!(currentPoseResults && currentPoseResults.poseLandmarks)
                                });
                                
                                const capturedPhoto = capturePhoto('dynamicCameraFeed', 'dynamicPoseCanvas', true);
                                
                                console.log('üì∏ Photo capture result:', {
                                    captureSuccessful: !!capturedPhoto,
                                    hasImageData: !!(capturedPhoto && capturedPhoto.imageData),
                                    imageSize: capturedPhoto ? (capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A',
                                    dimensions: capturedPhoto ? `${capturedPhoto.width}x${capturedPhoto.height}` : 'N/A',
                                    hasPoseOverlay: capturedPhoto ? capturedPhoto.hasPoseOverlay : false
                                });
                                
                                // Process movement analysis data
                                let analysisData;
                                if (movementAnalysisData.length > 0) {
                                    analysisData = processDynamicAnalysisResults(movementAnalysisData, currentSquatCount);
                                } else {
                                    analysisData = generateAnalysisData('dynamic');
                                }
                                
                                if (currentUser) {
                                    const resultData = {
                                        id: generateUUID(),
                                        user_id: currentUser.id,
                                        analysis_type: 'dynamic',
                                        sport: currentUser.primary_sport,
                                        analysis_date: new Date().toISOString(),
                                        capturedPhoto: capturedPhoto, // üì∏ Add photo data
                                        repetitions_performed: currentSquatCount, // Add squat count
                                        ...analysisData
                                    };
                                    
                                    saveAnalysisResultLocal(resultData);
                                    
                                    // Show photo capture success
                                    if (capturedPhoto) {
                                        console.log('‚úÖ Dynamic analysis photo captured and saved');
                                        showPhotoCaptureFeedback();
                                    }
                                }
                                
                                updateResultsDisplay(analysisData);
                                
                                if (navigator.vibrate) {
                                    navigator.vibrate([200, 100, 200]);
                                }
                                
                                // Exit fullscreen mode after dynamic capture is completed
                                console.log('üì± Exiting fullscreen mode after dynamic capture completion');
                                exitFullscreenMode('dynamic');
                                
                                showResults();
                            });
                        }
                    }
                    
                    previousLandmarks = landmarks;
                }
            }, 100);
            
            // Timeout after 30 seconds if no movement detected
            setTimeout(() => {
                if (isWaitingForMovement) {
                    clearInterval(checkMovementInterval);
                    isWaitingForMovement = false;
                    movementStartTime = Date.now();
                    waitingOverlay.remove();
                    
                    // Voice announcement removed - only for static front camera
                    // Force start recording
                    startRecordingTimer(screenElement, 15, () => {
                        // Exit fullscreen mode after timeout completion
                        exitFullscreenMode('dynamic');
                        
                        // Re-enable buttons
                        if (bottomButton) {
                            bottomButton.disabled = false;
                            bottomButton.textContent = 'Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã';
                        }
                        if (floatingButton) {
                            floatingButton.disabled = false;
                            floatingButton.textContent = 'Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã';
                        }
                        
                        // Auto-complete logic same as above
                        startDynamicCapture();
                    });
                }
            }, 30000);
        }
        
        // Recording timer function
        function startRecordingTimer(screenElement, seconds, onComplete) {
            const timerOverlay = document.createElement('div');
            timerOverlay.id = 'dynamicTimerOverlay';
            timerOverlay.className = 'fixed top-16 left-4 right-4 text-center';
            timerOverlay.style.zIndex = '45'; // Above MediaPipe canvas but not blocking everything
            timerOverlay.innerHTML = `
                <div class="bg-red-600 bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-lg border border-white border-opacity-20">
                    <div class="text-sm font-medium flex items-center justify-center">
                        <div class="w-2 h-2 bg-white rounded-full animate-pulse mr-2"></div>
                        REC
                    </div>
                    <div class="text-2xl font-bold" id="dynamicTimer">${seconds}</div>
                    <div class="text-xs opacity-75">Keep moving! / Âãï„ÅçÁ∂ö„Åë„Å¶„Åè„Å†„Åï„ÅÑÔºÅ</div>
                </div>
            `;
            
            document.body.appendChild(timerOverlay);
            
            let currentTime = seconds;
            const timerElement = document.getElementById('dynamicTimer');
            
            // Start recording data collection
            const recordingInterval = setInterval(() => {
                if (currentPoseResults && currentPoseResults.poseLandmarks) {
                    const analysis = performPoseAnalysis(currentPoseResults.poseLandmarks);
                    const movement = detectMovement(currentPoseResults.poseLandmarks);
                    
                    if (analysis && movement) {
                        movementAnalysisData.push({
                            ...analysis,
                            movement: movement,
                            timestamp: Date.now()
                        });
                        
                        // Update squat count and phase
                        const squatDetection = detectSquat(currentPoseResults.poseLandmarks);
                        if (squatDetection.isSquat && squatDetection.phase !== lastSquatPhase) {
                            if (squatDetection.phase === 'bottom' && lastSquatPhase === 'down') {
                                // Squat completed
                            }
                            lastSquatPhase = squatDetection.phase;
                        }
                    }
                }
            }, 50);
            
            const timerInterval = setInterval(() => {
                currentTime--;
                
                if (currentTime > 0) {
                    timerElement.textContent = currentTime;
                    
                    // Change color in last 5 seconds
                    if (currentTime <= 5) {
                        timerElement.style.color = '#FCD34D'; // Yellow
                        timerElement.parentElement.classList.remove('bg-red-600');
                        timerElement.parentElement.classList.add('bg-yellow-600');
                        
                        // Voice countdown removed - only for static front camera
                        if (navigator.vibrate) {
                            navigator.vibrate(30);
                        }
                    }
                    
                    // Pulsing effect in last 3 seconds
                    if (currentTime <= 3) {
                        timerElement.style.transform = 'scale(1.2)';
                        setTimeout(() => {
                            timerElement.style.transform = 'scale(1)';
                        }, 300);
                    }
                } else {
                    // Recording complete
                    clearInterval(timerInterval);
                    clearInterval(recordingInterval);
                    timerOverlay.remove();
                    
                    // Voice completion announcement removed - only for static front camera
                    // Strong completion haptic
                    if (navigator.vibrate) {
                        navigator.vibrate([300, 100, 300]);
                    }
                    
                    onComplete();
                }
            }, 1000);
        }
        
        async function startDynamicCapture() {
            // Start movement detection and recording
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Ready to move... / Âãï‰ΩúÊ∫ñÂÇô‰∏≠...';
            
            // Wait for movement to start
            await waitForMovementStart(() => {
                // Movement detected - start 15 second recording
                button.textContent = 'Recording... / Èå≤Áîª‰∏≠...';
                showRecordingTimer('dynamic', 15, async () => {
                    isAnalyzing = false;
                    
                    // Process movement analysis data
                    let analysisData;
                    if (movementAnalysisData.length > 0) {
                        analysisData = processDynamicAnalysisResults(movementAnalysisData, currentSquatCount);
                    } else {
                        // Fallback to generated data
                        analysisData = generateAnalysisData('dynamic');
                    }
                    
                    if (currentUser) {
                        const resultData = {
                            id: generateUUID(),
                            user_id: currentUser.id,
                            analysis_type: 'dynamic',
                            sport: currentUser.primary_sport,
                            analysis_date: new Date().toISOString(),
                            ...analysisData
                        };
                        
                        // „É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò
                        saveAnalysisResultLocal(resultData);
                    }
                    
                    updateResultsDisplay(analysisData);
                    
                    // ÂàÜÊûêÂÆå‰∫Ü„ÅÆÊåØÂãï„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 100, 200]);
                    }
                    
                    // Exit fullscreen mode after dynamic capture is completed (fallback path)
                    console.log('üì± Exiting fullscreen mode after dynamic capture completion (fallback)');
                    exitFullscreenMode('dynamic');
                    
                    showResults();
                });
            });
        }
        
        function generateAnalysisData(type) {
            const sport = currentUser ? currentUser.primary_sport : 'general';
            
            // Sport-specific analysis parameters
            const sportProfiles = {
                soccer: {
                    static: {
                        base: { overall_score: 82, hip_flexibility: 90, postural_stability: 75, dynamic_balance: 85 },
                        variance: 8,
                        focus: ['hip_flexibility', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 88, hip_flexibility: 85, postural_stability: 82, dynamic_balance: 92 },
                        variance: 6,
                        focus: ['dynamic_balance']
                    }
                },
                basketball: {
                    static: {
                        base: { overall_score: 78, hip_flexibility: 80, postural_stability: 85, dynamic_balance: 85 },
                        variance: 10,
                        focus: ['postural_stability', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 85, hip_flexibility: 82, postural_stability: 88, dynamic_balance: 90 },
                        variance: 7,
                        focus: ['postural_stability']
                    }
                },
                baseball: {
                    static: {
                        base: { overall_score: 83, hip_flexibility: 78, postural_stability: 88, dynamic_balance: 80 },
                        variance: 9,
                        focus: ['postural_stability']
                    },
                    dynamic: {
                        base: { overall_score: 80, hip_flexibility: 85, postural_stability: 85, dynamic_balance: 82 },
                        variance: 8,
                        focus: ['hip_flexibility']
                    }
                },
                tabletennis: {
                    static: {
                        base: { overall_score: 85, hip_flexibility: 82, postural_stability: 90, dynamic_balance: 88 },
                        variance: 7,
                        focus: ['postural_stability']
                    },
                    dynamic: {
                        base: { overall_score: 87, hip_flexibility: 80, postural_stability: 92, dynamic_balance: 90 },
                        variance: 5,
                        focus: ['postural_stability', 'dynamic_balance']
                    }
                },
                volleyball: {
                    static: {
                        base: { overall_score: 80, hip_flexibility: 85, postural_stability: 82, dynamic_balance: 88 },
                        variance: 8,
                        focus: ['hip_flexibility', 'dynamic_balance']
                    },
                    dynamic: {
                        base: { overall_score: 86, hip_flexibility: 88, postural_stability: 85, dynamic_balance: 92 },
                        variance: 6,
                        focus: ['dynamic_balance']
                    }
                }
            };
            
            // Default profile if sport not found
            const profile = sportProfiles[sport] || sportProfiles.soccer;
            const typeProfile = profile[type];
            
            // Generate scores with sport-specific variance
            const scores = {};
            Object.keys(typeProfile.base).forEach(key => {
                const baseScore = typeProfile.base[key];
                const variance = typeProfile.variance;
                scores[key] = Math.max(0, Math.min(100, baseScore + (Math.random() - 0.5) * variance * 2));
                scores[key] = Math.round(scores[key]);
            });
            
            // Generate sport-specific recommendations
            const sportRecommendations = {
                soccer: [
                    "Enhance ball control balance drills / „Éú„Éº„É´„Ç≥„É≥„Éà„É≠„Éº„É´„Éê„É©„É≥„Çπ„Éâ„É™„É´„ÅÆÂº∑Âåñ",
                    "Focus on single-leg stability for shooting / „Ç∑„É•„Éº„ÉàÊôÇ„ÅÆÁâáË∂≥ÂÆâÂÆöÊÄß„Å´ÈõÜ‰∏≠",
                    "Improve hip flexor mobility for agility / ÊïèÊç∑ÊÄßÂêë‰∏ä„ÅÆ„Åü„ÇÅ„ÅÆËÇ°Èñ¢ÁØÄÂ±àÁ≠ãÁæ§„ÅÆÂèØÂãïÊÄßÊîπÂñÑ",
                    "Strengthen core for better shooting accuracy / „Çà„ÇäËâØ„ÅÑ„Ç∑„É•„Éº„ÉàÁ≤æÂ∫¶„ÅÆ„Åü„ÇÅ„ÅÆ‰ΩìÂππÂº∑Âåñ"
                ],
                basketball: [
                    "Practice jump landing mechanics / „Ç∏„É£„É≥„ÉóÁùÄÂú∞„É°„Ç´„Éã„ÇØ„Çπ„ÅÆÁ∑¥Áøí",
                    "Improve ankle stability for court movements / „Ç≥„Éº„ÉàÂãï‰Ωú„ÅÆ„Åü„ÇÅ„ÅÆË∂≥È¶ñÂÆâÂÆöÊÄßÂêë‰∏ä",
                    "Enhance lateral movement balance / Ê®™ÊñπÂêëÂãï‰Ωú„Éê„É©„É≥„Çπ„ÅÆÂº∑Âåñ",
                    "Strengthen posterior chain for jumping / „Ç∏„É£„É≥„Éó„ÅÆ„Åü„ÇÅ„ÅÆÂæåÈù¢Á≠ãÁæ§Âº∑Âåñ"
                ],
                baseball: [
                    "Focus on rotational power development / ÂõûËª¢„Éë„ÉØ„ÉºÈñãÁô∫„Å´ÈõÜ‰∏≠",
                    "Improve shoulder girdle stability / ËÇ©Áî≤Â∏ØÂÆâÂÆöÊÄß„ÅÆÂêë‰∏ä",
                    "Enhance hip-shoulder separation / ËÖ∞„Å®ËÇ©„ÅÆÂàÜÈõ¢Âãï‰Ωú„ÅÆÂº∑Âåñ",
                    "Strengthen obliques for batting power / „Éê„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Éë„ÉØ„Éº„ÅÆ„Åü„ÇÅ„ÅÆËÖπÊñúÁ≠ãÂº∑Âåñ"
                ],
                tabletennis: [
                    "Practice quick lateral movements / Á¥†Êó©„ÅÑÊ®™ÊñπÂêëÂãï‰Ωú„ÅÆÁ∑¥Áøí",
                    "Improve wrist and forearm stability / ÊâãÈ¶ñ„ÉªÂâçËÖï„ÅÆÂÆâÂÆöÊÄßÂêë‰∏ä",
                    "Enhance reaction time balance drills / ÂèçÂøúÊôÇÈñì„Éê„É©„É≥„Çπ„Éâ„É™„É´„ÅÆÂº∑Âåñ",
                    "Focus on core stability for quick returns / Á¥†Êó©„ÅÑ„É™„Çø„Éº„É≥„ÅÆ„Åü„ÇÅ„ÅÆ‰ΩìÂππÂÆâÂÆöÊÄß"
                ],
                volleyball: [
                    "Practice spike approach mechanics / „Çπ„Éë„Ç§„ÇØ„Ç¢„Éó„É≠„Éº„ÉÅ„É°„Ç´„Éã„ÇØ„Çπ„ÅÆÁ∑¥Áøí",
                    "Improve shoulder flexibility for serves / „Çµ„Éº„Éñ„ÅÆ„Åü„ÇÅ„ÅÆËÇ©ÊüîËªüÊÄßÂêë‰∏ä",
                    "Enhance vertical jump stability / ÂûÇÁõ¥„Ç∏„É£„É≥„ÉóÂÆâÂÆöÊÄß„ÅÆÂº∑Âåñ",
                    "Strengthen legs for better blocking / „Çà„ÇäËâØ„ÅÑ„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„Åü„ÇÅ„ÅÆËÑöÂäõÂº∑Âåñ"
                ]
            };
            
            const recommendations = sportRecommendations[sport] || sportRecommendations.soccer;
            
            return {
                ...scores,
                recommendations: recommendations.slice(0, 2 + Math.floor(Math.random() * 2))
            };
        }
        
        function updateResultsDisplay(analysisData) {
            // Update the results screen with actual data
            document.querySelector('#results .text-4xl').textContent = `${analysisData.overall_score}/100`;
            
            // Update individual scores
            document.getElementById('hip-score').textContent = `${analysisData.hip_flexibility}%`;
            document.getElementById('posture-score').textContent = `${analysisData.postural_stability}%`;
            document.getElementById('balance-score').textContent = `${analysisData.dynamic_balance}%`;
            
            // Create chart
            createAnalysisChart(analysisData);
        }
        
        function createAnalysisChart(data) {
            const ctx = document.getElementById('analysisChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.analysisChart instanceof Chart) {
                window.analysisChart.destroy();
            }
            
            window.analysisChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [
                        'Hip Flexibility\nËÇ°Èñ¢ÁØÄÊüîËªüÊÄß',
                        'Postural Stability\nÂßøÂã¢ÂÆâÂÆöÊÄß',
                        'Dynamic Balance\nÂãïÁöÑ„Éê„É©„É≥„Çπ',
                        'Overall Performance\nÁ∑èÂêà„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ'
                    ],
                    datasets: [{
                        label: 'Current Score',
                        data: [
                            data.hip_flexibility,
                            data.postural_stability,
                            data.dynamic_balance,
                            data.overall_score
                        ],
                        backgroundColor: 'rgba(30, 58, 138, 0.2)',
                        borderColor: 'rgba(30, 58, 138, 0.8)',
                        borderWidth: 2,
                        pointBackgroundColor: 'rgba(30, 58, 138, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(30, 58, 138, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            pointLabels: {
                                font: {
                                    size: 10
                                },
                                color: '#374151'
                            },
                            ticks: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        function shareResults() {
            if (navigator.share) {
                navigator.share({
                    title: 'AthleteCore Pro - ÂàÜÊûêÁµêÊûú',
                    text: `ÁßÅ„ÅÆÂßøÂã¢ÂàÜÊûê„Çπ„Ç≥„Ç¢: ${document.querySelector('#results .text-4xl').textContent}`,
                    url: window.location.href
                }).catch(console.error);
            } else {
                alert('Results shared! / ÁµêÊûú„ÇíÂÖ±Êúâ„Åó„Åæ„Åó„ÅüÔºÅ');
            }
        }
        
        // Analysis History Functions
        function showAnalysisHistory() {
            console.log('üóÇÔ∏è Showing analysis history...');
            showScreen('analysis-history');
            document.getElementById('analysis-history').classList.add('fade-in');
            loadFullAnalysisHistory();
        }
        
        function loadFullAnalysisHistory() {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const userResults = results.filter(result => result.user_id === currentUser.id);
                const timeline = document.getElementById('historyTimeline');
                const emptyState = document.getElementById('historyEmptyState');
                
                if (userResults.length === 0) {
                    timeline.innerHTML = '';
                    emptyState.classList.remove('hidden');
                    return;
                }
                
                emptyState.classList.add('hidden');
                
                // Group by date for better organization
                const groupedResults = groupAnalysisByDate(userResults);
                
                timeline.innerHTML = Object.keys(groupedResults).reverse().map(dateKey => {
                    const analyses = groupedResults[dateKey];
                    const displayDate = new Date(dateKey).toLocaleDateString('ja-JP', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric',
                        weekday: 'short'
                    });
                    
                    return `
                        <div class="mb-6">
                            <div class="flex items-center mb-3">
                                <div class="w-3 h-3 bg-blue-600 rounded-full mr-3"></div>
                                <h3 class="text-lg font-semibold text-gray-800">${displayDate}</h3>
                                <div class="flex-1 h-px bg-gray-200 ml-4"></div>
                            </div>
                            <div class="ml-6 space-y-3">
                                ${analyses.map(analysis => createTimelineItem(analysis)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error loading full analysis history:', error);
                document.getElementById('historyTimeline').innerHTML = `
                    <div class="text-center py-8">
                        <p class="text-red-500">Error loading history</p>
                        <p class="text-sm text-gray-500">Â±•Ê≠¥„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</p>
                    </div>
                `;
            }
        }
        
        function groupAnalysisByDate(analyses) {
            return analyses.reduce((groups, analysis) => {
                const date = new Date(analysis.analysis_date).toDateString();
                if (!groups[date]) {
                    groups[date] = [];
                }
                groups[date].push(analysis);
                return groups;
            }, {});
        }
        
        function createTimelineItem(analysis) {
            const time = new Date(analysis.analysis_date).toLocaleTimeString('ja-JP', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            const typeLabel = {
                'static': 'Static Analysis / ÈùôÁöÑÂàÜÊûê',
                'dynamic': 'Dynamic Analysis / ÂãïÁöÑÂàÜÊûê',
                'sport_specific': 'Sport-Specific / Á´∂ÊäÄÁâπÂåñ'
            };
            
            const typeIcon = {
                'static': 'üì∑',
                'dynamic': 'üé•', 
                'sport_specific': '‚öΩ'
            };
            
            const scoreColor = analysis.overall_score >= 90 ? 'text-green-600' :
                              analysis.overall_score >= 80 ? 'text-blue-600' :
                              analysis.overall_score >= 70 ? 'text-yellow-600' :
                              analysis.overall_score >= 60 ? 'text-orange-600' : 'text-red-600';
            
            const scoreBg = analysis.overall_score >= 90 ? 'bg-green-50' :
                           analysis.overall_score >= 80 ? 'bg-blue-50' :
                           analysis.overall_score >= 70 ? 'bg-yellow-50' :
                           analysis.overall_score >= 60 ? 'bg-orange-50' : 'bg-red-50';
            
            return `
                <div class="bg-white p-4 rounded-xl border border-gray-100 shadow-sm cursor-pointer hover:shadow-md transition-all duration-200" onclick="showAnalysisDetail('${analysis.id}')">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <div class="text-2xl">${typeIcon[analysis.analysis_type] || 'üìä'}</div>
                            <div>
                                <div class="font-semibold text-gray-800">${typeLabel[analysis.analysis_type] || analysis.analysis_type}</div>
                                <div class="text-sm text-gray-500">${time}</div>
                                ${analysis.sport ? `<div class="text-xs text-gray-400">${getSportLabel(analysis.sport)}</div>` : ''}
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="px-3 py-2 ${scoreBg} rounded-lg">
                                <div class="text-xl font-bold ${scoreColor}">${analysis.overall_score}</div>
                                <div class="text-xs text-gray-500">/ 100</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quick Stats Preview -->
                    <div class="mt-3 pt-3 border-t border-gray-100">
                        <div class="grid grid-cols-3 gap-2 text-center">
                            <div>
                                <div class="text-sm font-medium text-gray-600">${analysis.hip_flexibility || '--'}</div>
                                <div class="text-xs text-gray-500">Hip / ËÇ°Èñ¢ÁØÄ</div>
                            </div>
                            <div>
                                <div class="text-sm font-medium text-gray-600">${analysis.postural_stability || '--'}</div>
                                <div class="text-xs text-gray-500">Posture / ÂßøÂã¢</div>
                            </div>
                            <div>
                                <div class="text-sm font-medium text-gray-600">${analysis.dynamic_balance || '--'}</div>
                                <div class="text-xs text-gray-500">Balance / „Éê„É©„É≥„Çπ</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-2 text-right">
                        <span class="text-xs text-gray-400">Tap for details / „Çø„ÉÉ„Éó„ÅßË©≥Á¥∞ ‚Üí</span>
                    </div>
                </div>
            `;
        }
        
        function getSportLabel(sport) {
            const sportLabels = {
                'soccer': 'Soccer / „Çµ„ÉÉ„Ç´„Éº',
                'basketball': 'Basketball / „Éê„Çπ„Ç±',
                'baseball': 'Baseball / ÈáéÁêÉ',
                'tabletennis': 'Table Tennis / ÂçìÁêÉ',
                'volleyball': 'Volleyball / „Éê„É¨„Éº'
            };
            return sportLabels[sport] || sport;
        }
        
        function filterAnalysisHistory(type) {
            // Update filter buttons
            document.querySelectorAll('[id^="filter"]').forEach(btn => {
                btn.classList.remove('bg-blue-50', 'brand-color', 'font-medium');
                btn.classList.add('text-gray-600');
            });
            
            document.getElementById(`filter${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('bg-blue-50', 'brand-color', 'font-medium');
            document.getElementById(`filter${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.remove('text-gray-600');
            
            // Filter and display results
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                let userResults = results.filter(result => result.user_id === currentUser.id);
                
                if (type !== 'all') {
                    userResults = userResults.filter(result => result.analysis_type === type);
                }
                
                const timeline = document.getElementById('historyTimeline');
                const emptyState = document.getElementById('historyEmptyState');
                
                if (userResults.length === 0) {
                    timeline.innerHTML = '';
                    emptyState.classList.remove('hidden');
                    return;
                }
                
                emptyState.classList.add('hidden');
                const groupedResults = groupAnalysisByDate(userResults);
                
                timeline.innerHTML = Object.keys(groupedResults).reverse().map(dateKey => {
                    const analyses = groupedResults[dateKey];
                    const displayDate = new Date(dateKey).toLocaleDateString('ja-JP', {
                        year: 'numeric',
                        month: 'long', 
                        day: 'numeric',
                        weekday: 'short'
                    });
                    
                    return `
                        <div class="mb-6">
                            <div class="flex items-center mb-3">
                                <div class="w-3 h-3 bg-blue-600 rounded-full mr-3"></div>
                                <h3 class="text-lg font-semibold text-gray-800">${displayDate}</h3>
                                <div class="flex-1 h-px bg-gray-200 ml-4"></div>
                            </div>
                            <div class="ml-6 space-y-3">
                                ${analyses.map(analysis => createTimelineItem(analysis)).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error filtering analysis history:', error);
            }
        }
        
        function showAnalysisDetail(analysisId) {
            console.log('üìä Showing analysis detail for:', analysisId);
            
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                console.log('üóÉÔ∏è Available results:', results.length);
                console.log('üîç Looking for ID:', analysisId);
                
                const analysis = results.find(result => result.id === analysisId);
                
                if (!analysis) {
                    console.error('‚ùå Analysis not found:', analysisId);
                    console.log('Available IDs:', results.map(r => r.id));
                    
                    // Show error message to user
                    alert('ÂàÜÊûê„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì / Analysis data not found');
                    return;
                }
                
                // üîç Debug: Check photo data in retrieved analysis
                console.log('‚úÖ Found analysis:', {
                    id: analysis.id,
                    type: analysis.analysis_type,
                    hasPhoto: !!analysis.capturedPhoto,
                    photoData: analysis.capturedPhoto ? {
                        hasImageData: !!analysis.capturedPhoto.imageData,
                        imageDataLength: analysis.capturedPhoto.imageData ? analysis.capturedPhoto.imageData.length : 0,
                        width: analysis.capturedPhoto.width,
                        height: analysis.capturedPhoto.height,
                        timestamp: analysis.capturedPhoto.timestamp,
                        cameraType: analysis.capturedPhoto.cameraType
                    } : null
                });
                
                showScreen('analysis-detail');
                document.getElementById('analysis-detail').classList.add('slide-up');
                
                // Populate detail content
                const detailContent = document.getElementById('analysisDetailContent');
                if (!detailContent) {
                    console.error('‚ùå Detail content element not found');
                    return;
                }
                
                detailContent.innerHTML = createAnalysisDetailContent(analysis);
                
                // Create detailed chart if element exists
                setTimeout(() => {
                    const chartCanvas = document.getElementById('detailAnalysisChart');
                    if (chartCanvas) {
                        createDetailedAnalysisChart(analysis);
                        console.log('‚úÖ Chart created successfully');
                    } else {
                        console.warn('‚ö†Ô∏è Chart canvas not found');
                    }
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Error showing analysis detail:', error);
                alert('ÂàÜÊûêË©≥Á¥∞„ÅÆË°®Á§∫„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü / Error displaying analysis details');
            }
        }
        
        function createAnalysisDetailContent(analysis) {
            const date = new Date(analysis.analysis_date).toLocaleDateString('ja-JP', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                weekday: 'long'
            });
            const time = new Date(analysis.analysis_date).toLocaleTimeString('ja-JP');
            
            const typeLabel = {
                'static': 'Static Posture Analysis / ÈùôÁöÑÂßøÂã¢ÂàÜÊûê',
                'dynamic': 'Dynamic Movement Analysis / ÂãïÁöÑÂãï‰ΩúÂàÜÊûê',
                'sport_specific': 'Sport-Specific Analysis / Á´∂ÊäÄÁâπÂåñÂàÜÊûê'
            };
            
            const scoreGrade = analysis.overall_score >= 90 ? 'A+' :
                              analysis.overall_score >= 80 ? 'A' :
                              analysis.overall_score >= 70 ? 'B' :
                              analysis.overall_score >= 60 ? 'C' : 'D';
            
            return `
                <!-- Header Info -->
                <div class="bg-white rounded-xl p-6 mb-6 shadow-sm">
                    <div class="text-center">
                        <div class="text-4xl font-bold brand-color mb-2">${analysis.overall_score}/100</div>
                        <div class="text-2xl font-bold text-gray-600 mb-1">Grade ${scoreGrade}</div>
                        <div class="text-lg text-gray-700 mb-2">${typeLabel[analysis.analysis_type] || analysis.analysis_type}</div>
                        <div class="text-sm text-gray-500">${date}</div>
                        <div class="text-sm text-gray-500">${time}</div>
                        ${analysis.sport ? `<div class="text-sm text-gray-500 mt-1">${getSportLabel(analysis.sport)}</div>` : ''}
                        ${analysis.repetitions_performed ? `<div class="text-sm text-blue-600 mt-1">Repetitions: ${analysis.repetitions_performed}</div>` : ''}
                    </div>
                </div>
                
                ${analysis.capturedPhoto ? `
                <!-- Captured Photo with Pose Analysis -->
                <div class="bg-white rounded-xl p-4 mb-6 shadow-sm border-2 border-green-200">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold brand-color">üì∏ Analysis Photo / ÂàÜÊûêÂÜôÁúü</h3>
                        <div class="text-xs text-green-600 font-medium">
                            ‚úÖ Photo Available | ${analysis.capturedPhoto.hasPoseOverlay ? 'ü¶¥ With pose overlay' : 'üì∑ Original photo'}
                        </div>
                    </div>
                    <div class="relative">
                        <img src="${analysis.capturedPhoto.imageData}" 
                             alt="Analysis Photo" 
                             class="w-full h-auto rounded-lg shadow-md cursor-pointer hover:shadow-lg transition-shadow border border-gray-200"
                             onclick="showPhotoModal('${analysis.id}')"
                             style="max-height: 400px; object-fit: contain; background: #f3f4f6;"
                             onload="console.log('‚úÖ Photo loaded successfully for analysis:', '${analysis.id}')"
                             onerror="console.error('‚ùå Photo failed to load for analysis:', '${analysis.id}')">
                        <div class="absolute top-2 right-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                            ${analysis.capturedPhoto.cameraType === 'front' ? 'ü§≥ Front Camera' : 'üì∑ Back Camera'}
                        </div>
                        <div class="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                            ${analysis.capturedPhoto.width} √ó ${analysis.capturedPhoto.height}
                        </div>
                        <div class="absolute top-2 left-2 bg-green-500 bg-opacity-80 text-white text-xs px-2 py-1 rounded">
                            Photo ID: ${analysis.id.slice(-8)}
                        </div>
                    </div>
                    <div class="mt-3 text-center">
                        <button onclick="showPhotoModal('${analysis.id}')" 
                                class="text-blue-600 text-sm hover:underline">
                            üîç View Full Size / „Éï„É´„Çµ„Ç§„Ç∫„ÅßË°®Á§∫
                        </button>
                        <button onclick="downloadPhoto('${analysis.id}')" 
                                class="ml-4 text-green-600 text-sm hover:underline">
                            üíæ Download Photo / ÂÜôÁúü„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
                        </button>
                    </div>
                    <!-- üîç Debug Info -->
                    <div class="mt-2 p-2 bg-gray-50 rounded text-xs">
                        <strong>Debug Info:</strong><br>
                        Photo Data Length: ${analysis.capturedPhoto.imageData ? (analysis.capturedPhoto.imageData.length / 1024).toFixed(1) + 'KB' : 'N/A'}<br>
                        Timestamp: ${analysis.capturedPhoto.timestamp}<br>
                        Has Pose Overlay: ${analysis.capturedPhoto.hasPoseOverlay ? 'Yes' : 'No'}
                    </div>
                </div>
                ` : `
                <!-- No Photo Available -->
                <div class="bg-yellow-50 border-2 border-yellow-200 rounded-xl p-4 mb-6">
                    <div class="flex items-center">
                        <div class="text-2xl mr-3">üì∑</div>
                        <div>
                            <h3 class="text-lg font-semibold text-yellow-800">No Photo Available</h3>
                            <p class="text-sm text-yellow-700">This analysis was performed without photo capture.</p>
                            <p class="text-xs text-yellow-600">ÂÜôÁúü„ÅåÊíÆÂΩ±„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</p>
                        </div>
                    </div>
                    <!-- üîç Debug Info -->
                    <div class="mt-3 p-2 bg-yellow-100 rounded text-xs">
                        <strong>Debug Info:</strong><br>
                        Analysis ID: ${analysis.id}<br>
                        Analysis Type: ${analysis.analysis_type}<br>
                        Has capturedPhoto property: ${analysis.hasOwnProperty('capturedPhoto') ? 'Yes' : 'No'}<br>
                        capturedPhoto value: ${JSON.stringify(analysis.capturedPhoto)}
                    </div>
                </div>
                `}
                
                <!-- Detailed Chart -->
                <div class="bg-white rounded-xl p-4 mb-6 shadow-sm">
                    <h3 class="text-lg font-semibold brand-color mb-4">Performance Breakdown / „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË©≥Á¥∞</h3>
                    <div style="height: 300px;">
                        <canvas id="detailAnalysisChart"></canvas>
                    </div>
                </div>
                
                <!-- Detailed Scores -->
                <div class="space-y-4 mb-6">
                    <div class="bg-white p-4 rounded-xl shadow-sm">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-semibold brand-color">Hip Flexibility</div>
                                <div class="text-sm text-gray-500">ËÇ°Èñ¢ÁØÄÊüîËªüÊÄß</div>
                            </div>
                            <div class="text-right">
                                <div class="text-2xl font-bold ${analysis.hip_flexibility >= 80 ? 'text-green-600' : analysis.hip_flexibility >= 60 ? 'text-yellow-600' : 'text-red-600'}">${analysis.hip_flexibility}%</div>
                                <div class="text-xs text-gray-500">${getScoreLabel(analysis.hip_flexibility)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-white p-4 rounded-xl shadow-sm">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-semibold brand-color">Postural Stability</div>
                                <div class="text-sm text-gray-500">ÂßøÂã¢ÂÆâÂÆöÊÄß</div>
                            </div>
                            <div class="text-right">
                                <div class="text-2xl font-bold ${analysis.postural_stability >= 80 ? 'text-green-600' : analysis.postural_stability >= 60 ? 'text-yellow-600' : 'text-red-600'}">${analysis.postural_stability}%</div>
                                <div class="text-xs text-gray-500">${getScoreLabel(analysis.postural_stability)}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-white p-4 rounded-xl shadow-sm">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-semibold brand-color">Dynamic Balance</div>
                                <div class="text-sm text-gray-500">ÂãïÁöÑ„Éê„É©„É≥„Çπ</div>
                            </div>
                            <div class="text-right">
                                <div class="text-2xl font-bold ${analysis.dynamic_balance >= 80 ? 'text-green-600' : analysis.dynamic_balance >= 60 ? 'text-yellow-600' : 'text-red-600'}">${analysis.dynamic_balance}%</div>
                                <div class="text-xs text-gray-500">${getScoreLabel(analysis.dynamic_balance)}</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Recommendations -->
                ${analysis.recommendations && analysis.recommendations.length > 0 ? `
                    <div class="bg-white rounded-xl p-4 mb-6 shadow-sm">
                        <h3 class="text-lg font-semibold brand-color mb-4">Recommendations / Êé®Â•®‰∫ãÈ†Ö</h3>
                        <div class="space-y-3">
                            ${analysis.recommendations.map(rec => `
                                <div class="flex items-start">
                                    <div class="w-2 h-2 bg-blue-500 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                                    <p class="text-sm text-gray-700">${rec}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Action Buttons -->
                <div class="space-y-3">
                    <button onclick="shareAnalysisDetail('${analysis.id}')" class="w-full bg-gray-100 text-gray-700 font-medium py-3 px-6 rounded-xl">
                        Share This Analysis / „Åì„ÅÆÂàÜÊûê„ÇíÂÖ±Êúâ
                    </button>
                    <button onclick="showAnalysisHistory()" class="w-full brand-bg text-white font-medium py-4 px-8 rounded-xl text-lg">
                        Back to History / Â±•Ê≠¥„Å´Êàª„Çã
                    </button>
                </div>
            `;
        }
        
        function getScoreLabel(score) {
            if (score >= 90) return 'Excellent / ÂÑ™ÁßÄ';
            if (score >= 80) return 'Good / ËâØÂ•Ω';
            if (score >= 70) return 'Fair / ÊôÆÈÄö';
            if (score >= 60) return 'Needs Work / Ë¶ÅÊîπÂñÑ';
            return 'Poor / ‰∏çËâØ';
        }
        
        function createDetailedAnalysisChart(analysis) {
            const canvas = document.getElementById('detailAnalysisChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.detailAnalysisChart instanceof Chart) {
                window.detailAnalysisChart.destroy();
            }
            
            window.detailAnalysisChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [
                        'Hip Flexibility\nËÇ°Èñ¢ÁØÄÊüîËªüÊÄß',
                        'Postural Stability\nÂßøÂã¢ÂÆâÂÆöÊÄß',
                        'Dynamic Balance\nÂãïÁöÑ„Éê„É©„É≥„Çπ',
                        'Overall Performance\nÁ∑èÂêà„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ'
                    ],
                    datasets: [{
                        label: 'Current Score',
                        data: [
                            analysis.hip_flexibility,
                            analysis.postural_stability,
                            analysis.dynamic_balance,
                            analysis.overall_score
                        ],
                        backgroundColor: 'rgba(30, 58, 138, 0.2)',
                        borderColor: 'rgba(30, 58, 138, 0.8)',
                        borderWidth: 3,
                        pointBackgroundColor: 'rgba(30, 58, 138, 1)',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(30, 58, 138, 1)',
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            pointLabels: {
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                },
                                color: '#374151'
                            },
                            ticks: {
                                display: true,
                                stepSize: 20,
                                font: {
                                    size: 10
                                },
                                color: '#9CA3AF',
                                backdropColor: 'rgba(255, 255, 255, 0.8)'
                            }
                        }
                    }
                }
            });
        }
        
        function shareAnalysisDetail(analysisId) {
            try {
                const results = JSON.parse(localStorage.getItem('athletecore_results') || '[]');
                const analysis = results.find(result => result.id === analysisId);
                
                if (!analysis) return;
                
                const date = new Date(analysis.analysis_date).toLocaleDateString('ja-JP');
                const typeLabel = {
                    'static': 'Static Analysis',
                    'dynamic': 'Dynamic Analysis',
                    'sport_specific': 'Sport-Specific Analysis'
                };
                
                if (navigator.share) {
                    navigator.share({
                        title: 'AthleteCore Pro - ÂàÜÊûêÁµêÊûú',
                        text: `${typeLabel[analysis.analysis_type]} (${date})\nOverall Score: ${analysis.overall_score}/100\nHip Flexibility: ${analysis.hip_flexibility}%\nPostural Stability: ${analysis.postural_stability}%\nDynamic Balance: ${analysis.dynamic_balance}%`,
                        url: window.location.href
                    }).catch(console.error);
                } else {
                    // Fallback: copy to clipboard
                    const shareText = `AthleteCore Pro Analysis Results\n${typeLabel[analysis.analysis_type]} (${date})\nOverall Score: ${analysis.overall_score}/100`;
                    navigator.clipboard.writeText(shareText).then(() => {
                        alert('Analysis results copied to clipboard! / ÂàÜÊûêÁµêÊûú„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                    }).catch(() => {
                        alert('Analysis results shared! / ÂàÜÊûêÁµêÊûú„ÇíÂÖ±Êúâ„Åó„Åæ„Åó„ÅüÔºÅ');
                    });
                }
            } catch (error) {
                console.error('Error sharing analysis detail:', error);
                alert('Analysis results shared! / ÂàÜÊûêÁµêÊûú„ÇíÂÖ±Êúâ„Åó„Åæ„Åó„ÅüÔºÅ');
            }
        }

        // PWAÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞
        function showInstallPrompt() {
            if (!isInstalled && deferredPrompt) {
                // „Ç§„É≥„Çπ„Éà„Éº„É´„Éú„Çø„É≥„ÇíË°®Á§∫
                const installButton = document.createElement('button');
                installButton.textContent = '„Ç¢„Éó„É™„Çí„Ç§„É≥„Çπ„Éà„Éº„É´';
                installButton.className = 'fixed bottom-4 right-4 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg z-50';
                installButton.id = 'installButton';
                installButton.onclick = installApp;
                document.body.appendChild(installButton);
            }
        }

        function hideInstallPrompt() {
            const installButton = document.getElementById('installButton');
            if (installButton) {
                installButton.remove();
            }
        }

        async function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`PWA„Ç§„É≥„Çπ„Éà„Éº„É´ÁµêÊûú: ${outcome}`);
                deferredPrompt = null;
                hideInstallPrompt();
            }
        }

        function showUpdateAvailable() {
            const updateNotification = document.createElement('div');
            updateNotification.innerHTML = `
                <div class="fixed top-4 left-4 right-4 bg-blue-600 text-white p-4 rounded-lg shadow-lg z-50">
                    <p class="text-sm mb-2">Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅåÂà©Áî®ÂèØËÉΩ„Åß„Åô</p>
                    <button onclick="updateApp()" class="bg-white text-blue-600 px-3 py-1 rounded text-sm">
                        Êõ¥Êñ∞
                    </button>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-white">
                        √ó
                    </button>
                </div>
            `;
            document.body.appendChild(updateNotification);
        }

        function updateApp() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(registration => {
                    registration.update();
                    window.location.reload();
                });
            }
        }

        // „Ç™„Éï„É©„Ç§„É≥/„Ç™„É≥„É©„Ç§„É≥Áä∂ÊÖã„ÅÆÁõ£Ë¶ñ
        function updateOnlineStatus() {
            const isOnline = navigator.onLine;
            const statusIndicator = document.getElementById('connectionStatus');
            
            if (!statusIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'connectionStatus';
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs';
                document.body.appendChild(indicator);
            }
            
            const indicator = document.getElementById('connectionStatus');
            
            if (isOnline) {
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs bg-green-500 text-white';
                indicator.textContent = '„Ç™„É≥„É©„Ç§„É≥';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            } else {
                indicator.className = 'fixed top-0 left-0 right-0 z-50 text-center py-1 text-xs bg-red-500 text-white';
                indicator.textContent = '„Ç™„Éï„É©„Ç§„É≥ - ‰∏ÄÈÉ®Ê©üËÉΩ„ÅåÂà∂Èôê„Åï„Çå„Åæ„Åô';
                indicator.style.display = 'block';
            }
        }

        // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„Å®„Ç™„É≥„É©„Ç§„É≥Áä∂ÊÖãÂ§âÊõ¥ÊôÇ„Å´ÂÆüË°å
        window.addEventListener('load', function() {
            console.log('üîÑ Page loaded, checking for smart reload state...');
            updateOnlineStatus();
            
            // Check for smart reload state restoration IMMEDIATELY
            const restored = restoreAfterSmartReload();
            
            if (restored) {
                console.log('‚úÖ Smart reload state restoration initiated successfully');
            } else {
                console.log('üîÑ No smart reload state found, normal initialization will proceed');
            }
            
            // Auto-test navigation after load (DISABLED for stable operation)
            // setTimeout(() => {
            //     // Force athlete welcome display first
            //     if (window.debugForceAthleteWelcome) {
            //         console.log('üèÜ Forcing Dior Sport Athlete Welcome...');
            //         window.debugForceAthleteWelcome();
            //     }
            //     
            //     setTimeout(() => {
            //         if (window.debugNavigation) {
            //             console.log('üß™ Running automatic navigation debug...');
            //             window.debugNavigation();
            //             
            //             // Test continue button after registration test
            //             setTimeout(() => {
            //                 if (window.debugContinueButton) {
            //                     console.log('üß™ Testing Continue button...');
            //                     window.debugContinueButton();
            //                 }
            //             }, 1000);
            //         }
            //     }, 1000);
            // }, 1500);
        });
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // „Éê„ÉÉ„ÉÜ„É™„ÉºÁä∂ÊÖã„ÅÆÁõ£Ë¶ñÔºàÂØæÂøú„Éñ„É©„Ç¶„Ç∂„ÅÆ„ÅøÔºâ
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                function updateBatteryInfo() {
                    if (battery.level < 0.2 && !battery.charging) {
                        console.log('„Éê„ÉÉ„ÉÜ„É™„ÉºÊÆãÈáè„ÅåÂ∞ë„Å™„Åè„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÁúÅÈõªÂäõ„É¢„Éº„Éâ„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    }
                }
                
                battery.addEventListener('levelchange', updateBatteryInfo);
                battery.addEventListener('chargingchange', updateBatteryInfo);
                updateBatteryInfo();
            });
        }
    </script>
    
    <!-- Floating Capture Buttons -->
    <button id="floatingStaticBtn" class="floating-capture-btn" onclick="startStaticCaptureImproved()">
        <span id="floatingStaticText">Start 10s Countdown / 10Áßí„Ç´„Ç¶„É≥„Éà„ÉÄ„Ç¶„É≥ÈñãÂßã</span>
    </button>
    <button id="floatingDynamicBtn" class="floating-capture-btn" onclick="startDynamicCaptureImproved()">
        Start Auto Recording / Ëá™ÂãïÈå≤ÁîªÈñãÂßã
    </button>
</body>
</html>
